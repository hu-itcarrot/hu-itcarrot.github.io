<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胡萝卜</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-11T04:54:22.796Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>itcarrot</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis面试</title>
    <link href="http://example.com/2023/08/11/Redis/"/>
    <id>http://example.com/2023/08/11/Redis/</id>
    <published>2023-08-11T04:49:34.431Z</published>
    <updated>2023-08-11T04:54:22.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h1><h2 id="1、缓存穿透"><a href="#1、缓存穿透" class="headerlink" title="1、缓存穿透"></a>1、缓存穿透</h2><p>查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，导致每次请求都会查询数据库</p><h3 id="1-1-解决方法"><a href="#1-1-解决方法" class="headerlink" title="1.1 解决方法"></a>1.1 解决方法</h3><ol><li><p>缓存空数据，查询返回的数据为空，仍把这个数据缓存</p><p> 1.1 缺点：消耗内存，可能会发生不一致的问题</p></li><li><p>布隆过滤器</p><p> ​<img src="/images/Redis/image-20230808162355-thy0rgk.png" alt="image">​</p><p> 主要是通过数组来判断的，但是会出现误判</p><p> 2.1 缺点： 实现复杂，存在误判</p></li></ol><h2 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h2><p>当给某个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把数据库压垮</p><p>​<img src="/images/Redis/image-20230808163212-ex1ivgu.png" alt="image">​</p><h3 id="2-1-解决方法"><a href="#2-1-解决方法" class="headerlink" title="2.1 解决方法"></a>2.1 解决方法</h3><ol><li><p>互斥锁</p><p> ​<img src="/images/Redis/image-20230808163423-5qnd3cs.png" alt="image"></p><p> 强一致，性能差</p></li><li><p>逻辑过期</p><p> ​<img src="/images/Redis/image-20230808163644-3hoxaas.png" alt="image"></p><p> 高可用，性能优，不能保证数据的绝对一致</p><p> ‍</p></li></ol><h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3 缓存雪崩"></a>3 缓存雪崩</h2><p>指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量的请求到达数据库，带来巨大的压力</p><p>​<img src="/images/Redis/image-20230808163953-je11knl.png" alt="image">​</p><h3 id="3-1-解决方法"><a href="#3-1-解决方法" class="headerlink" title="3.1 解决方法"></a>3.1 解决方法</h3><ol><li>给不同的key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性   如：哨兵模式，集群模式</li><li>给缓存业务添加降级限流策略        如：nigix或者springcloud gateway</li><li>给业务添加多级缓存</li></ol><h2 id="4-redis作为缓存，mysql的数据如何与redis进行同步？（双写一致性）"><a href="#4-redis作为缓存，mysql的数据如何与redis进行同步？（双写一致性）" class="headerlink" title="4 redis作为缓存，mysql的数据如何与redis进行同步？（双写一致性）"></a>4 redis作为缓存，mysql的数据如何与redis进行同步？（双写一致性）</h2><h3 id="4-1-双写一致性"><a href="#4-1-双写一致性" class="headerlink" title="4.1 双写一致性"></a>4.1 双写一致性</h3><p>当修改了数据库中的数据也要同时更新缓存中的数据，缓存中的数据要和数据库中的数据保存一致</p><p>​<img src="/images/Redis/image-20230808164715-hkasqms.png" alt="image">​</p><ol><li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，然后写入缓存，设置超时时间</p></li><li><p>写操作：延迟双删</p><p> ​<img src="/images/Redis/image-20230808165328-k87t9b6.png" alt="image">​</p><p> 应该是先删除缓存还是先删除数据库？</p><ol><li><p>先删除缓存，在操作数据库</p><p> ​​<img src="/images/Redis/image-20230808165122-62xckbu.png" alt="image">​</p><p> 会出现脏数据的现象</p></li><li><p>先操作数据库，在删除缓存</p><p> ​<img src="/images/Redis/image-20230808165301-9hhowvf.png" alt="image">​</p><p> 也会出现问题</p></li><li><p>可以使用分布式锁实现</p><p> ​<img src="/images/Redis/image-20230808165524-bf2r5ms.png" alt="image">​</p></li><li><p>​<img src="/images/Redis/image-20230808165623-sf8h7bz.png" alt="image">​</p></li><li><p>最好的方式</p><p> 使用mq实现</p><p> ​<img src="/images/Redis/image-20230808165954-7v6voiv.png" alt="image">​</p></li></ol></li></ol><h2 id="5-redis-作为缓存，数据的持久化是怎么做的？"><a href="#5-redis-作为缓存，数据的持久化是怎么做的？" class="headerlink" title="5 redis 作为缓存，数据的持久化是怎么做的？"></a>5 redis 作为缓存，数据的持久化是怎么做的？</h2><h3 id="5-1-RDB"><a href="#5-1-RDB" class="headerlink" title="5.1 RDB"></a>5.1 RDB</h3><pre><code>RDB 全称 Redis Database Backup file （ Redis 数据备份文件），也被叫做 Redis 数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据</code></pre><h4 id="5-1-1-RDB的执行原理"><a href="#5-1-1-RDB的执行原理" class="headerlink" title="5.1.1 RDB的执行原理"></a>5.1.1 RDB的执行原理</h4><pre><code>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RGB文件。</code></pre><p>​<img src="/images/Redis/image-20230809141944-yfp19h5.png" alt="image">​</p><h3 id="5-2-AOF"><a href="#5-2-AOF" class="headerlink" title="5.2 AOF"></a>5.2 AOF</h3><p>​<img src="/images/Redis/image-20230809142125-ib692pw.png" alt="image">​</p><p>​<img src="/images/Redis/image-20230809142416-jd2sk3o.png" alt="image">​</p><h2 id="6-假如redis的key过期后，会立即删除吗？"><a href="#6-假如redis的key过期后，会立即删除吗？" class="headerlink" title="6 假如redis的key过期后，会立即删除吗？"></a>6 假如redis的key过期后，会立即删除吗？</h2><h3 id="6-1-惰性删除"><a href="#6-1-惰性删除" class="headerlink" title="6.1 惰性删除"></a>6.1 惰性删除</h3><pre><code>置该key过期时间后，我们不需要去管他，当需要该key时，我们再检查其是否过期，如果过期，我们就删除，反之返回该key</code></pre><h3 id="6-2-定期删除"><a href="#6-2-定期删除" class="headerlink" title="6.2 定期删除"></a>6.2 定期删除</h3><pre><code>每隔一段时间，我们就对key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key）</code></pre><p>两种模式：</p><ol><li>Slow模式是定时任务，执行频率默认为 10hz ，每次不超过 25ms ，以通过修改配置文件 redis.conf 的 hz 选项来调整这个次数</li><li>FAST 模式执行频率不固定，但两次间隔不低于 2ms ，每次耗时不超过 1ms</li></ol><h2 id="7-假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）"><a href="#7-假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）" class="headerlink" title="7 假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）"></a>7 假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）</h2><pre><code>数据的淘汰策略：当 Redis 中的内存不够用时，此时在向 Redis 中添加新的 key ，那么 Redis 就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</code></pre><p>Redis支持8种不同的策略来选择要删除的key:</p><ol><li>noeviction ： 不淘汰任何 key ，但是内存满时不允许写入新数据，默认就是这种策略</li><li>volatile-ttl ： 对设置了 TTL 的 key ，比较 key 的剩余 TTL 值， TTL 越小越先被淘汰</li><li>allkeys-random ：对全体 key ，随机进行淘汰。</li><li>volatile-random ：对设置了 TTL 的 key ，随机进行淘汰。</li><li>allkeys-lru ： 对全体 key ，基于 LRU 算法进行淘汰。LRU 最近最少使用，LFU：最少频率使用</li><li>volatile-lru ： 对设置了 TTL 的 key ，基于 LRU 算法进行淘汰</li><li>allkeys-lfu ： 对全体 key ，基于 LFU 算法进行淘汰</li><li>volatile-lfu ： 对设置了 TTL 的 key ，基于 LFU 算法进行淘汰</li></ol><h3 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h3><ol><li>优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。</li><li>如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用allkeys-random ，随机选择淘汰。</li><li>如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。</li><li>如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。</li></ol><p>​<img src="/images/Redis/image-20230809144042-ilo0hwj.png" alt="image">​</p><h2 id="8-redis-分布式锁，是如何实现的？（场景：集群情况下的定时任务，抢单，幂等性）"><a href="#8-redis-分布式锁，是如何实现的？（场景：集群情况下的定时任务，抢单，幂等性）" class="headerlink" title="8 redis 分布式锁，是如何实现的？（场景：集群情况下的定时任务，抢单，幂等性）"></a>8 redis 分布式锁，是如何实现的？（场景：集群情况下的定时任务，抢单，幂等性）</h2><p>​<img src="/images/Redis/image-20230809152440-30ijpgb.png" alt="image">​</p><p>redisson实现的分布式锁可重入</p><h4 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h4><p>使用红锁：不能只在一个redis实例上创建锁，应该在多个redis实例上进行创建锁</p><p>‍</p><h3 id="9-Redis集群有哪些方案？"><a href="#9-Redis集群有哪些方案？" class="headerlink" title="9 Redis集群有哪些方案？"></a>9 Redis集群有哪些方案？</h3><p>在redis中提供的集群方案总共有三种</p><ol><li>主从复制</li><li>哨兵模式</li><li>分片集群</li></ol><h3 id="9-1-主从复制"><a href="#9-1-主从复制" class="headerlink" title="9.1 主从复制"></a>9.1 主从复制</h3><pre><code>​![image](images/Redis/image-20230809153853-mqeh8xp.png)​</code></pre><p>​<img src="/images/Redis/image-20230809154024-2ryn0dj.png" alt="image">​</p><h3 id="9-2-哨兵模式"><a href="#9-2-哨兵模式" class="headerlink" title="9.2 哨兵模式"></a>9.2 哨兵模式</h3><p>redis提供了哨兵机制来实现主从集群的自动故障恢复，主要作用：</p><ol><li><p>监控：哨兵会不断检查master和slave是否按预期工作</p></li><li><p>自动故障恢复：如果master故障，哨兵会将一个slave提升为master。当故障实例恢复后也以新的master为主</p></li><li><p>通知：哨兵充当redis客户端的服务发现来源，当集群发生故障转移时，会将最新的信息推送给redis客户端</p><p> ‍</p></li></ol><h4 id="哨兵选主的规则"><a href="#哨兵选主的规则" class="headerlink" title="哨兵选主的规则"></a>哨兵选主的规则</h4><ol><li>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</li><li>然后判断从节点的 slave-priority 值，越小优先级越高</li><li>如果 slave-prority 一样，则判断 slave 节点的 offset 值，越大优先级越高</li><li>最后是判断 slave 节点的运行 id 大小，越小优先级越高。</li></ol><h4 id="redis集群（哨兵模式-脑裂"><a href="#redis集群（哨兵模式-脑裂" class="headerlink" title="redis集群（哨兵模式)脑裂"></a>redis集群（哨兵模式)脑裂</h4><h3 id="9-3-分片集群结构"><a href="#9-3-分片集群结构" class="headerlink" title="9.3 分片集群结构"></a>9.3 分片集群结构</h3><p>​<img src="/images/Redis/image-20230810155824-giv8bdl.png" alt="image">​</p><p>‍</p><h3 id="10-其他问题"><a href="#10-其他问题" class="headerlink" title="10 其他问题"></a>10 其他问题</h3><p>‍</p><p>​<img src="/images/Redis/image-20230810160110-cjjfubw.png" alt="image">​</p><p>‍</p><h4 id="10-1-用户空间和内核空间"><a href="#10-1-用户空间和内核空间" class="headerlink" title="10.1 用户空间和内核空间"></a>10.1 用户空间和内核空间</h4><p>​<img src="/images/Redis/image-20230810160326-2xgdntq.png" alt="image">​</p><h4 id="10-2-阻塞IO"><a href="#10-2-阻塞IO" class="headerlink" title="10.2 阻塞IO"></a>10.2 阻塞IO</h4><p>阶段一：</p><ol><li>用户进程尝试读取数据（比如网卡数据)</li><li>此时数据尚未到达，内核需要等待数据</li><li>此时用户进程也处于阻塞状态</li></ol><p>阶段二：</p><ol><li>数据到达并拷贝到内核缓冲去，代表已就绪</li><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程接触阻塞，处理数据</li></ol><p>​<img src="/images/Redis/image-20230810160820-nxdnvl1.png" alt="image">​</p><h4 id="10-3-非阻塞IO"><a href="#10-3-非阻塞IO" class="headerlink" title="10.3 非阻塞IO"></a>10.3 非阻塞IO</h4><p>阶段一：</p><ol><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，知道数据就绪</li></ol><p>阶段二：</p><ol><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程接触阻塞，处理数据</li></ol><p>‍</p><p>​<img src="/images/Redis/image-20230810161058-khx69qo.png" alt="image">​</p><h4 id="10-4-IO多路复用"><a href="#10-4-IO多路复用" class="headerlink" title="10.4 IO多路复用"></a>10.4 IO多路复用</h4><p>IO多路复用：是利用单个线程来同时监听多个 Socket ，并在某个 Socket 可读、可写时得到通知，从而避免无效的等待，充分利用 CPU 资源。</p><p>阶段一：</p><ol><li>用户进程调用 select ，指定要监听的 Socket 集合</li><li>内核监听对应的多个 socket</li><li>任意一个或多个 socket 数据就绪则返回 readable</li><li>此过程中用户进程阻塞</li></ol><p>阶段二：</p><ol><li>用户进程找到就绪的 socket</li><li>依次调用 recvfrom 读取数据</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ol><p>​<img src="/images/Redis/image-20230810161339-yz88h2v.png" alt="image">​</p><p>‍</p><p>‍</p><p>‍</p><h2 id="End-SpringBoot整合Redis"><a href="#End-SpringBoot整合Redis" class="headerlink" title="End SpringBoot整合Redis"></a>End SpringBoot整合Redis</h2><h3 id="1、-配置类"><a href="#1、-配置类" class="headerlink" title="1、 配置类"></a>1、 配置类</h3><pre><code class="java">@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        template.setConnectionFactory(factory);        //key序列化方式        template.setKeySerializer(redisSerializer);        //value序列化        template.setValueSerializer(jackson2JsonRedisSerializer);        //value hashmap序列化        template.setHashValueSerializer(jackson2JsonRedisSerializer);        return template;    &#125;    @Bean    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        //解决查询缓存转换异常的问题        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        // 配置序列化（解决乱码的问题）,过期时间600秒        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofSeconds(600))                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))                .disableCachingNullValues();        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)                .cacheDefaults(config)                .build();        return cacheManager;    &#125;&#125;</code></pre><h3 id="2、springboot-缓存注解说明"><a href="#2、springboot-缓存注解说明" class="headerlink" title="2、springboot 缓存注解说明"></a>2、springboot 缓存注解说明</h3><h4 id="2-1-缓存-Cacheable"><a href="#2-1-缓存-Cacheable" class="headerlink" title="2.1 缓存@Cacheable"></a>2.1 缓存@Cacheable</h4><pre><code>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不 存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</code></pre><table><thead><tr><th>属性&#x2F;方法名</th><th>解释</th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><h4 id="2-2-缓存-CachePut"><a href="#2-2-缓存-CachePut" class="headerlink" title="2.2 缓存@CachePut"></a>2.2 缓存@CachePut</h4><pre><code>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存 中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。</code></pre><table><thead><tr><th>属性&#x2F;方法名</th><th>解释</th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><h4 id="2-3-缓存-CacheEvict"><a href="#2-3-缓存-CacheEvict" class="headerlink" title="2.3 缓存@CacheEvict"></a>2.3 缓存@CacheEvict</h4><pre><code>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上</code></pre><table><thead><tr><th>属性&#x2F;方法名</th><th>解释</th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr><tr><td>allEntries</td><td>是否清空所有缓存，默认为 false。如果指定为 true，则方法调用 后将立即清空所有的缓存</td></tr><tr><td>beforeInvo cation</td><td>是否在方法执行前就清空，默认为 false。如果指定为 true，则在 方法执行前就会清空缓存</td></tr></tbody></table><h3 id="3-使用过程"><a href="#3-使用过程" class="headerlink" title="3 使用过程"></a>3 使用过程</h3><p>在需要存储数据的方法上面添加@Cacheable注解，注解里面写入需要添加的key和value</p><p>​<img src="/images/Redis/image-20230810113504-vc3csy9.png" alt="image">​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h1 id=&quot;一、使用场景&quot;&gt;&lt;a href=&quot;#一、使用场景&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>热部署</title>
    <link href="http://example.com/2023/08/04/Devtools/"/>
    <id>http://example.com/2023/08/04/Devtools/</id>
    <published>2023-08-04T09:03:52.602Z</published>
    <updated>2023-08-04T09:05:22.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热部署Devtools"><a href="#热部署Devtools" class="headerlink" title="热部署Devtools"></a>热部署Devtools</h1><h4 id="第一步-添加依赖"><a href="#第一步-添加依赖" class="headerlink" title="第一步 添加依赖"></a>第一步 添加依赖</h4><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><h4 id="第二步-添加配置"><a href="#第二步-添加配置" class="headerlink" title="第二步 添加配置"></a>第二步 添加配置</h4><pre><code class="java">&lt;build&gt;    &lt;finalName&gt;你自己的工程名字&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;                &lt;addResources&gt;true&lt;/addResources&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><h4 id="第三步-修改配置"><a href="#第三步-修改配置" class="headerlink" title="第三步 修改配置"></a>第三步 修改配置</h4><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105429-fu9m0yn.png" alt="image">​</p><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105433-2h97hee.png" alt="image">​</p><h4 id="第四步-添加配置"><a href="#第四步-添加配置" class="headerlink" title="第四步 添加配置"></a>第四步 添加配置</h4><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105507-n40ldyf.png" alt="image">​</p><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105512-evt811g.png" alt="image">​</p><p>新版本可能在修改时找不到第一项，需要打开设置进行设置</p><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105627-ficn5z7.png" alt="image">​</p><h4 id="第五步-重启idea"><a href="#第五步-重启idea" class="headerlink" title="第五步 重启idea"></a>第五步 重启idea</h4><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;热部署Devtools&quot;&gt;&lt;a href=&quot;#热部署Devtools&quot; class=&quot;headerlink&quot; title=&quot;热部署Devtools&quot;&gt;&lt;/a&gt;热部署Devtools&lt;/h1&gt;&lt;h4 id=&quot;第一步-添加依赖&quot;&gt;&lt;a href=&quot;#第一步-添加依赖&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dataway</title>
    <link href="http://example.com/2023/07/28/Dataway/"/>
    <id>http://example.com/2023/07/28/Dataway/</id>
    <published>2023-07-28T08:01:17.111Z</published>
    <updated>2023-07-28T08:13:28.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dataway"><a href="#Dataway" class="headerlink" title="Dataway"></a>Dataway</h1><pre><code>Dataway 是基于 DataQL 服务聚合能力，为应用提供的一个接口配置工具，使得使用者无需开发任何代码就配置一个满足需求的接口。整个接口配置、测试、冒烟、发布，一站式都通过 Dataway 提供的 UI 界面完成。UI 会以 Jar 包方式提供并集成到应用中并和应用共享同一个 http 端口，应用无需单独为 Dataway 开辟新的管理端口。这种内嵌集成方式模式的优点是，可以使得大部分老项目都可以在无侵入的情况下直接应用 Dataway。进而改进老项目的迭代效率，大大减少企业项目研发成本。Dataway 工具化的提供 DataQL 配置能力。这种研发模式的变革使得，相当多的需求开发场景只需要配置即可完成交付。从而避免了从数据存取到前端接口之间的一系列开发任务，例如：Mapper、BO、VO、DO、DAO、Service、Controller 统统不在需要。Dataway 是 Hasor 生态中的一员，因此在 Spring 中使用 Dataway 首先要做的就是打通两个生态。根据官方文档中推荐的方式我们将 Hasor 和 Spring Boot 整合起来。</code></pre><h4 id="第一步：-引入相关依赖"><a href="#第一步：-引入相关依赖" class="headerlink" title="第一步： 引入相关依赖"></a>第一步： 引入相关依赖</h4><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;    &lt;version&gt;4.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;    &lt;version&gt;4.1.3-fix20200414&lt;/version&gt;&lt;!-- 4.1.3 包存在UI资源缺失问题 --&gt;&lt;/dependency&gt;</code></pre><p>hasor-spring 负责 Spring 和 Hasor 框架之间的整合。hasor-dataway 是工作在 Hasor 之上，利用 hasor-spring 我们就可以使用 dataway了。</p><h4 id="第二步：配置Dataway-并初始化数据表"><a href="#第二步：配置Dataway-并初始化数据表" class="headerlink" title="第二步：配置Dataway,并初始化数据表"></a>第二步：配置Dataway,并初始化数据表</h4><p>dataway 会提供一个界面让我们配置接口，这一点类似 Swagger 只要jar包集成就可以实现接口配置。找到我们 springboot 项目的配置文件 application.properties</p><pre><code class="java"># 是否启用 Dataway 功能（必选：默认false）HASOR_DATAQL_DATAWAY=true# 是否开启 Dataway 后台管理界面（必选：默认false）HASOR_DATAQL_DATAWAY_ADMIN=true# dataway  API工作路径（可选，默认：/api/）HASOR_DATAQL_DATAWAY_API_URL=/api/# dataway-ui 的工作路径（可选，默认：/interface-ui/）HASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/# SQL执行器方言设置（可选，建议设置）HASOR_DATAQL_FX_PAGE_DIALECT=mysql</code></pre><p>Dataway 一共涉及到 5个可以配置的配置项，但不是所有配置都是必须的。</p><p>其中 HASOR_DATAQL_DATAWAY、HASOR_DATAQL_DATAWAY_ADMIN 两个配置是必须要打开的，默认情况下 Datawaty 是不启用的。</p><p>Dataway 需要两个数据表才能工作，下面是这两个数据表的简表语句。下面这个 SQL 可以在 dataway的依赖 jar 包中 “META-INF&#x2F;hasor-framework&#x2F;mysql” 目录下面找到，建表语句是用 mysql 语法写的。</p><pre><code class="sql">CREATE TABLE `interface_info` (    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;ID&#39;,    `api_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `api_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `api_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0草稿，1发布，2有变更，3禁用&#39;,    `api_comment`     varchar(255)     NULL                  COMMENT &#39;注释&#39;,    `api_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `api_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `api_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `api_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,    PRIMARY KEY (`api_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway 中的API&#39;;CREATE TABLE `interface_release` (    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;Publish ID&#39;,    `pub_api_id`      int(11)      NOT NULL                  COMMENT &#39;所属API ID&#39;,    `pub_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `pub_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `pub_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0有效，1无效（可能被下线）&#39;,    `pub_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `pub_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT &#39;原始查询脚本，仅当类型为SQL时不同&#39;,    `pub_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `pub_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;发布时间（下线不更新）&#39;,    PRIMARY KEY (`pub_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway API 发布历史。&#39;;create index idx_interface_release on interface_release (pub_api_id);</code></pre><h4 id="第三步：-配置数据源"><a href="#第三步：-配置数据源" class="headerlink" title="第三步： 配置数据源"></a>第三步： 配置数据源</h4><p>作为 Spring Boot 项目有着自己完善的数据库方面工具支持。我们这次采用 druid + mysql + spring-boot-starter-jdbc 的方式。</p><p>首先引入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后添加数据源的配置</p><pre><code class="java"># dbspring.datasource.url=jdbc:mysql://xxxxxxx:3306/examplespring.datasource.username=xxxxxspring.datasource.password=xxxxxspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type:com.alibaba.druid.pool.DruidDataSource# druidspring.datasource.druid.initial-size=3spring.datasource.druid.min-idle=3spring.datasource.druid.max-active=10spring.datasource.druid.max-wait=60000spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=adminspring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=1</code></pre><p>如果项目已经集成了自己的数据源，那么可以忽略第三步。</p><h4 id="第四步：把数据源设置到Hasor容器中"><a href="#第四步：把数据源设置到Hasor容器中" class="headerlink" title="第四步：把数据源设置到Hasor容器中"></a>第四步：把数据源设置到Hasor容器中</h4><p>Spring Boot 和 Hasor 本是两个独立的容器框架，我们做整合之后为了使用 Dataway 的能力需要把 Spring 中的数据源设置到 Hasor 中。</p><p>首先新建一个 Hasor 的 模块，并且将其交给 Spring 管理。然后把数据源通过 Spring 注入进来。</p><pre><code class="java">@DimModule@Componentpublic class ExampleModule implements SpringModule &#123;    @Autowired    private DataSource dataSource = null;    @Override    public void loadModule(ApiBinder apiBinder) throws Throwable &#123;        // .DataSource form Spring boot into Hasor        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));    &#125;&#125;</code></pre><p>Hasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。</p><h4 id="第五步：-在springboot中启用Hasor"><a href="#第五步：-在springboot中启用Hasor" class="headerlink" title="第五步： 在springboot中启用Hasor"></a>第五步： 在springboot中启用Hasor</h4><pre><code class="java">@EnableHasor()@EnableHasorWeb()@SpringBootApplication(scanBasePackages = &#123; &quot;net.example.hasor&quot; &#125;)public class ExampleApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ExampleApplication.class, args);    &#125;&#125;</code></pre><p>这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。</p><h4 id="第六步：启动应用"><a href="#第六步：启动应用" class="headerlink" title="第六步：启动应用"></a>第六步：启动应用</h4><p>应用在启动过程中会看到 Hasor Boot 的欢迎信息</p><pre><code class="java"> _    _                        ____              _| |  | |                      |  _ \            | || |__| | __ _ ___  ___  _ __  | |_) | ___   ___ | |_|  __  |/ _` / __|/ _ \| &#39;__| |  _ &lt; / _ \ / _ \| __|| |  | | (_| \__ \ (_) | |    | |_) | (_) | (_) | |_|_|  |_|\__,_|___/\___/|_|    |____/ \___/ \___/ \__|</code></pre><p>在后面的日志中还可以看到类似下面这些日志。</p><pre><code class="java">2023-05-18 13:52:59.696 [main] INFO  n.h.core.context.TemplateAppContext - loadModule class net.hasor.dataway.config.DatawayModule2023-05-18 13:52:59.697 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway api workAt /api/2023-05-18 13:52:59.697 [main] INFO  n.h.c.e.AbstractEnvironment - var -&gt; HASOR_DATAQL_DATAWAY_API_URL = /api/.2023-05-18 13:52:59.704 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway admin workAt /interface-ui/2023-05-18 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[901d38f22faa419a8593bb349905ed0e] -&gt; bindType ‘class net.hasor.dataway.web.ApiDetailController’ mappingTo: ‘[/interface-ui/api/api-detail]’.2023-05-18 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[c6eb9f3b3d4c4c8d8a4f807435538172] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryListController’ mappingTo: ‘[/interface-ui/api/api-history]’.2023-05-18 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[eb841dc72ad54023957233ef602c4327] -&gt; bindType ‘class net.hasor.dataway.web.ApiInfoController’ mappingTo: ‘[/interface-ui/api/api-info]’.2023-05-18 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[96aebb46265245459ae21d558e530921] -&gt; bindType ‘class net.hasor.dataway.web.ApiListController’ mappingTo: ‘[/interface-ui/api/api-list]’.2023-05-18 13:52:59.718 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7467c07f160244df8f228321f6262d3d] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryGetController’ mappingTo: ‘[/interface-ui/api/get-history]’.2023-05-18 13:52:59.719 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[97d8da5363c741ba99d87c073a344412] -&gt; bindType ‘class net.hasor.dataway.web.DisableController’ mappingTo: ‘[/interface-ui/api/disable]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[8ddc3316ef2642dfa4395ca8ac0fff04] -&gt; bindType ‘class net.hasor.dataway.web.SmokeController’ mappingTo: ‘[/interface-ui/api/smoke]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[cc06c5fb343b471aacedc58fb2fe7bf8] -&gt; bindType ‘class net.hasor.dataway.web.SaveApiController’ mappingTo: ‘[/interface-ui/api/save-api]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7915b2b1f89a4e73891edab0264c9bd4] -&gt; bindType ‘class net.hasor.dataway.web.PublishController’ mappingTo: ‘[/interface-ui/api/publish]’.2023-05-18 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[0cfa34586455414591bdc389bff23ccb] -&gt; bindType ‘class net.hasor.dataway.web.PerformController’ mappingTo: ‘[/interface-ui/api/perform]’.2023-05-18 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[37fe4af3e2994acb8deb72d21f02217c] -&gt; bindType ‘class net.hasor.dataway.web.DeleteController’ mappingTo: ‘[/interface-ui/api/delete]’.</code></pre><p>当看到 “dataway api workAt &#x2F;api&#x2F;” 、 dataway admin workAt &#x2F;interface-ui&#x2F; 信息时，就可以确定 Dataway 的配置已经生效了。</p><h4 id="第七步：访问接口管理页面进行接口配置"><a href="#第七步：访问接口管理页面进行接口配置" class="headerlink" title="第七步：访问接口管理页面进行接口配置"></a>第七步：访问接口管理页面进行接口配置</h4><p>在浏览器中输入 “<a href="http://127.0.0.1:8080/interface-ui/%E2%80%9D">http://127.0.0.1:8080/interface-ui/”</a> 就可以看到期待已久的界面了。</p><p>​<img src="/images/dataway_01-20230725172609-ps05uve.png" alt="dataway_01">​</p><h4 id="第八步：-新建一个接口"><a href="#第八步：-新建一个接口" class="headerlink" title="第八步： 新建一个接口"></a>第八步： 新建一个接口</h4><p>Dataway 提供了2中语言模式，我们可以使用强大的 DataQL 查询语言，也可以直接使用 SQL 语言（在 Dataway 内部 SQL 语言也会被转换为 DataQL 的形式执行。）</p><p>​<img src="/images/dataway_02-20230725172622-doddtt6.png" alt="dataway_02">​</p><p>首先我们在 SQL 模式下尝试执行一条 select 查询，立刻就可以看到这条 SQL 的查询结果。</p><p>​<img src="/images/dataway_03-20230725172638-uv4y73g.png" alt="dataway_03">​</p><p>同样的方式我们使用 DataQL 的方式需要这样写：</p><pre><code class="java">var query = @@sql()&lt;%    select * from interface_info%&gt;return query()</code></pre><p>其中 var query &#x3D; @@sql()&lt;% … %&gt; 是用来定义SQL外部代码块，并将这个定义存入 query 变量名中。&lt;% %&gt; 中间的就是 SQL 语句。</p><p>最后在 DataQL 中调用这个代码块，并返回查询结果。</p><p>当接口写好之后就可以保存发布了，为了测试方便，我选用 GET 方式。</p><p>​<img src="/images/dataway_04-20230725172731-a2q09dl.png" alt="dataway_04">​</p><p>接口发布之后我们直接请求：<a href="http://127.0.0.1:8080/api/demos%EF%BC%8C%E5%B0%B1%E7%9C%8B%E5%88%B0%E6%9C%9F%E5%BE%85%E5%B7%B2%E4%B9%85%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BA%86%E3%80%82">http://127.0.0.1:8080/api/demos，就看到期待已久的接口返回值了。</a></p><p>​<img src="/images/dataway_05-20230725172743-p1b6cbj.png" alt="dataway_05">​</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>经过上面的几个步骤我们介绍了如何基于 Spring Boot 项目使用 Dataway 来简单的配置接口。Dataway 的方式确实给人耳目一新，一个接口竟然可以如此简单的配置出来无需开发任何一行代码，也不需要做任何 Mapping 实体映射绑定。</p><p>‍</p><h4 id="最后放几个有用的链接："><a href="#最后放几个有用的链接：" class="headerlink" title="最后放几个有用的链接："></a>最后放几个有用的链接：</h4><ul><li><p>Dataway官方手册：</p><p>​<code>https://www.hasor.net/web/dataway/about.html</code>​​</p></li><li><p>Dataway 在 OSC 上的项目地址，欢迎收藏：</p><p><a href="https://www.oschina.net/p/dataway">https://www.oschina.net/p/dataway</a></p></li><li><p>DataQL 手册地址：</p><p><a href="https://www.hasor.net/web/dataql/what_is_dataql.html">https://www.hasor.net/web/dataql/what_is_dataql.html</a></p></li><li><p>Hasor 项目的首页：</p><p><a href="https://www.hasor.net/web/index.html">https://www.hasor.net/web/index.html</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dataway&quot;&gt;&lt;a href=&quot;#Dataway&quot; class=&quot;headerlink&quot; title=&quot;Dataway&quot;&gt;&lt;/a&gt;Dataway&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Dataway 是基于 DataQL 服务聚合能力，为应用提供的一个接口配置工具，使</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://example.com/2023/07/04/docker/"/>
    <id>http://example.com/2023/07/04/docker/</id>
    <published>2023-07-04T10:48:34.000Z</published>
    <updated>2023-07-04T11:00:43.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h2><h3 id="1、查看镜像——docker-images"><a href="#1、查看镜像——docker-images" class="headerlink" title="1、查看镜像——docker images"></a>1、查看镜像——docker images</h3><pre><code># 查看下载到本地的所有镜像docker imagesREPOSITORY   TAG       IMAGE ID       CREATED      SIZEnginx        latest    ae2feff98a0c   9 days ago   133MB--------------------------------------------------------------------------------REPOSITORY：镜像属于的仓库；TAG：镜像的标签信息，标记同一个仓库中的不同镜像；IMAGE ID：镜像的唯一ID 号，唯一标识一个镜像，经过md5方式加密过；CREATED：镜像创建时间；VIRTUAL SIZE：镜像大小；</code></pre><p><img src="/images/docker_images.png" alt="图片"></p><h3 id="2、查看所有状态容器——docker-ps-a"><a href="#2、查看所有状态容器——docker-ps-a" class="headerlink" title="2、查看所有状态容器——docker ps -a"></a>2、查看所有状态容器——docker ps -a</h3><pre><code>docker ps -a    #-a 选项可以显示所有的容器 CONTAINER ID   IMAGE         COMMAND                  CREATED        STATUS                      PORTS     NAMES58a0aad139d3   nginx         &quot;/docker-entrypoint.…&quot;   2 hours ago    Exited (0) 21 minutes ago             dazzling_wescoff ##字段说明CONTAINER ID：容器的ID号IMAGE：加载的镜像COMMAND ：运行的程序CREATED ：创建时间STATUS：当前的状态PORTS：端口映射NAMES：名称</code></pre><h3 id="3、docker——run-命令"><a href="#3、docker——run-命令" class="headerlink" title="3、docker——run 命令"></a>3、docker——run 命令</h3><pre><code>docker run hello-world</code></pre><h3 id="4、查看docker版本信息——docker-v"><a href="#4、查看docker版本信息——docker-v" class="headerlink" title="4、查看docker版本信息——docker -v"></a>4、查看docker版本信息——docker -v</h3><pre><code>docker versiondocker -v</code></pre><h3 id="5、查看docker信息——docker-info"><a href="#5、查看docker信息——docker-info" class="headerlink" title="5、查看docker信息——docker info"></a>5、查看docker信息——docker info</h3><pre><code>docker info#可以用该命令统计每一个状态的容器有多少个 Client: Context:    default  Debug Mode: false Plugins:  app: Docker App (Docker Inc., v0.9.1-beta3)  buildx: Docker Buildx (Docker Inc., v0.7.1-docker)  scan: Docker Scan (Docker Inc., v0.12.0) Server: Containers: 1  #容器连接数量  Running: 0   #正在运行的容器数量  Paused: 0   #暂停的容器数量  Stopped: 1  #停止的容器数量 Images: 2    #统计的镜像数量 Server Version: 20.10.12   #docker版本 Storage Driver: overlay2   #存储引擎，早期有一段用的是aufa存储引擎，可以把多个目录叠在在一起后挂载到同一个目录一下  Backing Filesystem: xfs    #后端的文件系统  Supports d_type: true           Native Overlay Diff: true  userxattr: false Logging Driver: json-file Cgroup Driver: cgroupfs   #linux中资源控制，资源管理的驱动：cgroupfs  Cgroup Version: 1     Plugins:  #插件  Volume: local  #镜像默认保存位置。可以不保存在本地，docker是以引擎的方式架设在linux之上的。  Network: bridge host ipvlan macvlan null overlay  #所支持的默认的网络类型。bridge（桥接）、host（主机）、ipvlan（三层模式划分vlan）、macvlan（二层模式划分vlan）、null（躺平：不与别人交互）、overlay（叠加网络）  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive   Runtimes: io.containerd.runc.v2   io.containerd.runtime.v1.linux runc  #运行时 Default Runtime: runc  #默认运行时的版本 Init Binary: docker-init containerd version: 7b11cfaabd73bb80907dd23182b9347b4245eb5d runc version: v1.0.2-0-g52b36a2 init version: de40ad0 Security Options:  seccomp   Profile: default Kernel Version: 3.10.0-693.el7.x86_64 Operating System: CentOS Linux 7 (Core) OSType: linux Architecture: x86_64 CPUs: 4   #总计cpu Total Memory: 1.718GiB #总计内存 Name: docker ID: DT7Y:MDZR:NVOS:NQBJ:C2RV:L5IS:OSLD:E3DG:3PSN:EJDH:ZYMU:42HS Docker Root Dir: /var/lib/docker  #docker家目录 Debug Mode: false Registry: https://index.docker.io/v1/  #默认仓库 Labels: Experimental: false Insecure Registries:  127.0.0.0/8 Registry Mirrors:    https://4abdkxlk.mirror.aliyuncs.com/ Live Restore Enabled: false</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、基本操作&quot;&gt;&lt;a href=&quot;#一、基本操作&quot; class=&quot;headerlink&quot; title=&quot;一、基本操作&quot;&gt;&lt;/a&gt;一、基本操作&lt;/h2&gt;&lt;h3 id=&quot;1、查看镜像——docker-images&quot;&gt;&lt;a href=&quot;#1、查看镜像——docker-i</summary>
      
    
    
    
    
    <category term="基本操作" scheme="http://example.com/tags/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/07/03/hello-world/"/>
    <id>http://example.com/2023/07/03/hello-world/</id>
    <published>2023-07-03T09:57:59.685Z</published>
    <updated>2023-07-04T10:47:14.690Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
