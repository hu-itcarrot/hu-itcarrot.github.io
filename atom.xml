<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胡萝卜</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-10T08:57:08.148Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>itcarrot</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://example.com/2023/05/04/%E9%83%A8%E7%BD%B2/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2023/05/04/%E9%83%A8%E7%BD%B2/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2023-05-04T04:22:33.000Z</published>
    <updated>2023-12-10T08:57:08.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h1 id="1、-什么是负载均衡"><a href="#1、-什么是负载均衡" class="headerlink" title="1、 什么是负载均衡"></a>1、 什么是负载均衡</h1><p>负载均衡的主要作用是为多个后端服务提供负载均衡功能，依据不同的负载均衡算法让这些服务可以分摊流量。负载均衡的历史非常悠久，从演进路径上看大致可以分为以下这几个阶段：</p><ul><li>第一阶段：这一阶段的负载均衡通常由硬件设备组成，具有高性能、高可靠性的特点，但灵活性较差，价格昂贵。比较典型的是 F5 这种基于硬件的负载均衡。</li><li>第二阶段：负载均衡开始以软件形式实现，使其更加灵活和可扩展，通常以软件分发的形式出现，因此价格也比较低廉，比如 LVS 就属于这一类。</li><li>第三阶段：随着云计算技术的兴起，负载均衡也开始有了云版本，这个版本的负载均衡其中一个好处是可以帮助企业以更低的成本获得高性能的负载均衡服务，另一个好处是它能够利用云计算的可扩展性和弹性的特点来提高整体可用性。例如 AWS 的 Classic Load Balancer、Application Load Balancer、Network Load Balancer 等。</li></ul><p>负载均衡除了用于分摊流量、提高网络的伸缩性外，还可以用于提升网络安全。比如可以将内网服务器与外网进行隔离，防止互联网的恶意攻击和访问。一个简单的使用场景就是，一个包含敏感信息的内部服务器，负载均衡可以把内部服务器隔离在内网中，这样就能有效保护内部服务器的安全。</p><p>​<img src="/images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/d1e85b13cc28a1297775db720186ec90-20231210095848-uvu6tun.png" alt="d1e85b13cc28a1297775db720186ec90">​</p><h1 id="2、-什么是API网关（Gateway"><a href="#2、-什么是API网关（Gateway" class="headerlink" title="2、 什么是API网关（Gateway)"></a>2、 什么是API网关（Gateway)</h1><p>API 网关简单来说是一种主要工作在七层，专门用于 API 的管理和流量转发的基础设施，并在此基础上拥有负载均衡所不具备的强大的扩展性，比如：认证、可观测性、自定义插件等等。简单来说，包括但不限于以下这些特点：</p><ul><li>丰富的路由策略：API 网关工作在七层，所以它可以解析到 HTTP&#x2F;HTTPS 层的数据。因此它可以根据请求的 Path 或 Domain 甚至是 Header 作为条件，将请求转发到不同的上游服务器。</li><li>认证：可以在API层面支持多种多样的认证方式来避免非法请求，比如 OAuth2、JWT 等等，直接将认证这部分服务独立出来，不侵入或者少侵入业务代码。</li><li>限流：支持对不同程度的路由进行细粒度的限流，防止恶意攻击，防止后端服务雪崩。</li><li>可观测性：可观察性是指从系统外部观察系统内部程序的运行状态和资源使用情况的能力。API 网关支持将日志对接到 Kafka、 Google Cloud Logging Service、Elasticsearch 等，支持将相关 metrics 接入到 prometheus、datadog 等。</li><li>扩展：因为 API 网关自身是网关身份，这就注定对它要求是能适配各家公司不同应用场景，比如不同的鉴权、灰度、安全策略、日志收集等，必须允许用户自由选择所需扩展或者自定义开发，因此扩展性很强，允许选择的扩展种类也十分丰富。以 Apache APISIX 举例，光是认证的扩展就有 13 款，几乎涵盖了市面上常见的认证需求。</li></ul><p>目前市面上有许多 API 网关，比如 Apache APISIX、Kong、Tyk、Zuul 等，开发者可以根据自己的需求选择合适的 API 网关。</p><p>​<img src="/images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/bd795aac8984543e5f4edd2eea111c59-20231210095925-68mnino.png" alt="bd795aac8984543e5f4edd2eea111c59">​</p><h1 id="3、API-网关与负载均衡主要区别"><a href="#3、API-网关与负载均衡主要区别" class="headerlink" title="3、API 网关与负载均衡主要区别"></a>3、API 网关与负载均衡主要区别</h1><p>​<img src="/images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/6d7cef370327c06e47cf822eb1cd6d63-20231210095942-e9b9b6t.png" alt="6d7cef370327c06e47cf822eb1cd6d63">​</p><p>首先，他们主要工作的侧重点不同。虽然说 API 网关和负载均衡都支持四层和七层的代理。但是，API 网关主要侧重于七层，而负载均衡主要侧重于四层。</p><p>工作在四层的负载均衡拥有许多有利的特点，首先是它相比于 API 网关减少了协议解析的损耗，具有更强的吞吐能力。其次就是它支持透传客户端 IP 地址，而 API 网关，一般是通过 HTTP 头方式传递客户端 IP 地址。</p><p>​<img src="/images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/455ba57c2ea3a110b2c12f6f961aa5b6-20231210095955-k18jen7.png" alt="455ba57c2ea3a110b2c12f6f961aa5b6">​</p><p>其次就是功能的丰富程度不同。负载均衡的 HTTP 七层处理能力比较弱，往往不包含认证、授权、鉴权、复杂路由逻辑、日志收集等功能。API 网关则具有相当强大的七层协议处理能力，可以在此基础上，附加各种各样的功能扩展，比如权限控制、日志、API 管理、Serverless 等等。</p><p>现如今，科技公司的产品需求变幻莫测，对于很多公司来说支持自定义开发是刚需。API 网关支持各式的自定义开发，比如支持丰富的编程语言，支持在流量转发的不同阶段注入自定义的处理逻辑，而负载均衡基本不支持任何自定义功能开发。</p><p>微信搜索公众号：Java项目精选，回复：java 领取资料 。</p><p>还有一点就是负载均衡通常采用流量直接分发的形式做负载均衡，它通过算法将流量数据直接发向某个后端服务器节点。这意味着后端等待接收流量的每一个服务实例行为都必须是一致的，这减少了一定的灵活性。而 API 网关则是以 URL Path 、Domain、Header 等维度进行流量分发，后端等待接收流量的服务实例可以多种多样，可以是某个 Private API，也可以是某个 gRPC 的 API。这就使流量分发变得十分地灵活。</p><h1 id="4、使用场景"><a href="#4、使用场景" class="headerlink" title="4、使用场景"></a>4、使用场景</h1><p>​<img src="/images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/a2010c0c7247eb576bafa67903eb72db-20231210100016-224ji3n.png" alt="a2010c0c7247eb576bafa67903eb72db">​</p><p>API 网关对于采用了微服务架构的系统是刚需。首先它可以方便地管理和路由多种不同的后端服务，其次可以提供许多高级功能，比如身份验证、授权、限流、转发、日志记录等功能。这样不同的微服务之间无需重复实现限流、认证等功能，让微服务的每个服务的功能实现更加纯粹，减少研发成本。</p><p>由于微服务的特点是服务种类多，工作在四层的负载均衡不太适合对种类繁多后端服务做负载均衡，它更适合用于单体后端服务。即使是工作在七层的负载均衡，因为一般不能提供较为丰富的高级功能，相比于 API 网关在微服务上优势也不明显。</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;h1 id=&quot;1、-什么是负载均衡&quot;&gt;&lt;a href=&quot;#1、-什么是负载均衡&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="部署" scheme="http://example.com/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>消息机制全解析Handler</title>
    <link href="http://example.com/2022/12/04/Android/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90Handler/"/>
    <id>http://example.com/2022/12/04/Android/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90Handler/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:08:29.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息机制全解析Handler"><a href="#消息机制全解析Handler" class="headerlink" title="消息机制全解析Handler"></a>消息机制全解析Handler</h1><h1 id="1、什么是Handler消息传递机制"><a href="#1、什么是Handler消息传递机制" class="headerlink" title="1、什么是Handler消息传递机制"></a>1、什么是Handler消息传递机制</h1><h2 id="1-1-Handler的组成"><a href="#1-1-Handler的组成" class="headerlink" title="1.1 Handler的组成"></a>1.1 Handler的组成</h2><p>Handler消息传递机制，从名字看就可以联想到是Handler会发送出一个一个消息，同时系统会根据每一个不同的消息进行不同的处理流程。具体如何实现，直接上图。</p><p>​<img src="https://uploadfiles.nowcoder.com/images/20220925/545613072_1664094379565/D7F0DF4708C16259BF43603986AF8234" alt="图片说明" title="图片标题"> 图片来自参考目录1。</p><p>Handler由3个模块组成，Handler、MessageQueue、Looper：</p><ul><li>Handler：主要作用是发送信息以及处理信息（为何发送还自己处理？），其中发送的信息叫作Message，可以传递数据哦；</li><li>MessageQueue：消息队列，由一个一个Message汇成，遵循先进先出规则，由Looper进行管理；</li><li>Looper：从MessageQueue里读取消息，并按消息分发机制分配到目标Handler进行消息处理。</li></ul><h2 id="1-2-Handler的使用和代码实例"><a href="#1-2-Handler的使用和代码实例" class="headerlink" title="1.2 Handler的使用和代码实例"></a>1.2 Handler的使用和代码实例</h2><p>结合1.1小节，简述下完整的流程：</p><ol><li>Handler通过sendMessage()发送消息Message，每个Message都在MessageQueue里排队。</li><li>Looper通过loop()从MessageQueue里读取Message，并按消息分发机制分配到目标Handler进行消息处理。</li><li>目标Handler收到需要处理的Message时，调用自己的handleMessage()方法来处理Message，因此自定义的Handler都需要重写handlerMessage方法。</li></ol><pre><code class="java">private void updateBluetoothStatus(int state) &#123;    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            ...            //1. 子线程执行完耗时操作后，触发更新蓝牙列表            if (mHandler != null) &#123;                mHandler.removeMessages(H.MSG_XURUI_BLUETOOTH_LIST);                mHandler.sendEmptyMessage(H.MSG_XURUI_BLUETOOTH_LIST);            &#125;        &#125;    &#125;).start();&#125;private void updateBluetoothList() &#123;    //3. 更新蓝牙列表&#125;private static class H extends BaseHandler&lt;BlueToothTestActivity&gt; &#123;    public static final int MSG_XURUI_BLUETOOTH_LIST = 100;    public H(BlueToothTestActivity activity) &#123;        super(activity);    &#125;    @Override    protected void handleMessage(BlueToothTestActivity activity, Message msg) &#123;        if (msg.what == MSG_XURUI_BLUETOOTH_LIST) &#123;            //2. 通过Handler机制调用updateBluetoothList            activity.updateBluetoothList();        &#125;    &#125;&#125;</code></pre><p>我们可以看到子线程执行完耗时操作后，需要更新UI的时候，需要返回到主线程（子线程不能或不建议更新UI），因此在子线程通过Handler机制，很容易切换到Handler所在的主线程去执行updateBluetoothList()函数来更新UI。</p><p>仔细的同学应该有看到BaseHandler类，为何要封装Handler的基类，这是工程上提高代码稳定性的常用做法，后续马上揭晓，但需循序渐进，我们先看看Handler源码。</p><h1 id="2、源码分析"><a href="#2、源码分析" class="headerlink" title="2、源码分析"></a>2、源码分析</h1><p>因为Handler在面试中的地位，良心建议，再难都必须过一遍源码，我尽量讲的更容易理解。</p><h2 id="2-1-Handler机制源码分析"><a href="#2-1-Handler机制源码分析" class="headerlink" title="2.1 Handler机制源码分析"></a>2.1 Handler机制源码分析</h2><p>创建Handler只要执行。。。，其源码见下分析：</p><pre><code class="java">public Handler() &#123;    this(null, false);&#125;public Handler(Callback callback, boolean async) &#123;    //1：获取Looper    mLooper = Looper.myLooper();    //如果获取不到Looper会提示我们要事先运行Looper.prepare()    if (mLooper == null) &#123;        throw new RuntimeException(            &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()                    + &quot; that has not called Looper.prepare()&quot;);    &#125;    //2：消息队列，来自Looper对象    mQueue = mLooper.mQueue;    mCallback = callback;    //设置消息为异步处理方式    mAsynchronous = async;&#125;</code></pre><p>注释2很重要，如果面试官问Looper和MessageQueue怎么关联在一起？那么现在就知道是在Handler的构造函数中关联的。重点继续看看注释1，Looper.myLooper()做了什么？</p><pre><code class="java"> public static @Nullable Looper myLooper() &#123;        return sThreadLocal.get();//1    &#125;</code></pre><p>从注释1看出来，仅仅是从sThreadLocal获取一个Looper变量。思路继续，我们从sThreadLocal变量入手，如何初始化的？在哪里使用？有get()那就一定有set()。继续研究源码：</p><pre><code class="java">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();public static void prepare() &#123;    prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123;    if (sThreadLocal.get() != null) &#123;        //1：一个线程只能有一个 Looper        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);    &#125;    sThreadLocal.set(new Looper(quitAllowed));//2&#125;</code></pre><p>如果某些数据在不同的线程作用域下有各自的数据副本，那么可以用ThreadLocal对数据进行线程隔离。从两个两个函数很容易知道，通过调用Looper.prepare()函数即可执行到注释2，将新new出来的Looper放到sThreadLocal里，供Looper.myLooper()去获取。</p><p>如果已经有实际开发经验的同学可能会想到通过Android studio创建的MainActivity可以直接用Handler，然而上一段才说使用Handler需要提前执行Looper.prepare()函数。其实这不矛盾，因为MainActivity所以在的主线程ActivityThread的main()函数已经自动执行了Looper.prepare()函数。 ActivityThread的main方法源码如下：</p><pre><code class="JAVA">    public static void main(String[] args) &#123;    ...        Looper.prepareMainLooper(); //1        Looper.loop();        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);    &#125;      public static void prepareMainLooper() &#123;        prepare(false); //2        synchronized (Looper.class) &#123;            if (sMainLooper != null) &#123;                throw new IllegalStateException(&quot;The main Looper has                 already been prepared.&quot;);            &#125;            sMainLooper = myLooper();        &#125;    &#125;</code></pre><p>ActivityThread的main方法通过调用prepareMainLooper()进而调用prepare(false)方法，进而new一个Looper放到sThreadLocal里。</p><h2 id="2-2-Handler发送信息的方法有几种"><a href="#2-2-Handler发送信息的方法有几种" class="headerlink" title="2.2 Handler发送信息的方法有几种"></a>2.2 Handler发送信息的方法有几种</h2><p>最重要的源码已经分析完了，我们先来看看Hander如何发送信息。发送消息有两种方式，post和send。</p><h3 id="2-2-1-post方法"><a href="#2-2-1-post方法" class="headerlink" title="2.2.1 post方法"></a>2.2.1 post方法</h3><p>post方法有以下两个函数post()和postDelayed()，用法是Handler.post(Runnable r)，举个例子：</p><pre><code class="java">public void readLog() &#123;    myHandler.post(XRReadLog);&#125;Runnable XRReadLog = new Runnable() &#123;        @Override        public void run() &#123;           // do something        &#125;    &#125;;</code></pre><p>用法非常简单，进一步看看post源码：</p><pre><code class="java">public final boolean post(Runnable r)&#123;        return  sendMessageDelayed(getPostMessage(r), 0);    &#125;    public final boolean postDelayed(Runnable r, long delayMillis)&#123;        return sendMessageDelayed(getPostMessage(r), delayMillis);    &#125;</code></pre><p>可以看到只是调用了sendMessageDelayed()，这就是send方法了。</p><p><strong>注</strong>：getPostMessage()方法是将Runnable转换为Message，因为sendMessageDelayed接收的是Message参数。</p><pre><code class="java"> private static Message getPostMessage(Runnable r) &#123;        Message m = Message.obtain();        m.callback = r;        return m;    &#125;</code></pre><h3 id="2-2-2-send方法"><a href="#2-2-2-send方法" class="headerlink" title="2.2.2 send方法"></a>2.2.2 send方法</h3><p>send方法有3个，函数作用从名称上就可以一眼看出：</p><ul><li>sendMessage()：发送带有数据的信息</li><li>sendMessageDelayed()：发送带有数据的信息并延迟执行</li><li>sendEmptyMessage()：发送空信息 就以sendMessageDelayed为例看看使用方法：</li></ul><pre><code class="java">Message logMessage = Message.obtain();logMessage.what = WIFI_CONNECT_LOG; //信息的名称logMessage.arg1 = 1;logMessage.obj = &quot;some thing&quot;;      //信息所携带的数据myHandler.sendMessageDelayed(logMessage，1000); //延迟1000毫秒执行</code></pre><p>用法也比较简单，根据自己需要决定是否携带数据，是否延迟执行。看一下源码：</p><pre><code class="java">  public final boolean sendMessage(Message msg)&#123;        return sendMessageDelayed(msg, 0);    &#125;    public final boolean sendEmptyMessage(int what)&#123;        return sendEmptyMessageDelayed(what, 0);    &#125;    public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123;        if (delayMillis &lt; 0) &#123;            delayMillis = 0;        &#125;        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);//1    &#125;</code></pre><p>可以看出来，无论是post还是send，最后都是用SystemClock.uptimeMillis()获取系统开机到当前的时间，加上我们设置的delayMillis时间，并调用sendMessageAtTime()方法做进一步逻辑。</p><p><strong>住</strong>：不能用System.currentTimeMilis（系统时间），因为用户很可能自己修改系统时间。</p><pre><code class="java">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;        MessageQueue queue = mQueue;        if (queue == null) &#123;            RuntimeException e = new RuntimeException(                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);            Log.w(&quot;Looper&quot;, e.getMessage(), e);            return false;        &#125;        return enqueueMessage(queue, msg, uptimeMillis);    &#125;    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;        msg.target = this;        if (mAsynchronous) &#123;            msg.setAsynchronous(true);        &#125;        //转到 MessageQueue 的 enqueueMessage 方法        return queue.enqueueMessage(msg, uptimeMillis);//1    &#125;</code></pre><p>通过注释1，Handler发送的消息最终发送到消息队列。2.5小节详细讲queue.enqueueMessage()，我们先一起看一下Message和Looper的源码，这样可以更好的理解。</p><h2 id="2-3-Message源码分析"><a href="#2-3-Message源码分析" class="headerlink" title="2.3 Message源码分析"></a>2.3 Message源码分析</h2><p>Handler机制传递的Message是怎么生成的，每个Message里面都有什么数据。看下源码就可以很清楚的了解了：</p><pre><code class="java">public final class Message implements Parcelable &#123;      public int what;//消息的标识      //系统自带的两个参数，注意是int型的，其他类型数据不能放这里    public int arg1;    public int arg2;    long when;  //处理消息的相对时间    Bundle data;//可以使用message.setData()使用bundle的实型传参    Handler target;    Runnable callback;      Message next;//消息池是以链表结构存储 Message    private static Message sPool;//消息池中的头节点      public Message() &#123;    &#125;      //1:直接通过链表操作获得 Message （注释1）    public static Message obtain() &#123;        synchronized (sPoolSync) &#123;            if (sPool != null) &#123;                //取出头节点返回                Message m = sPool;                sPool = m.next;                m.next = null;                m.flags = 0; // clear in-use flag                sPoolSize--;                return m;            &#125;        &#125;        return new Message();    &#125;      //回收消息    public void recycle() &#123;        if (isInUse()) &#123;            if (gCheckRecycle) &#123;                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;                        + &quot;is still in use.&quot;);            &#125;            return;        &#125;        recycleUnchecked();    &#125;    void recycleUnchecked() &#123; //2        //清空消息的所有标志信息        flags = FLAG_IN_USE;        what = 0;        arg1 = 0;        arg2 = 0;        obj = null;        replyTo = null;        sendingUid = -1;        when = 0;        target = null;        callback = null;        data = null;        synchronized (sPoolSync) &#123;            if (sPoolSize &lt; MAX_POOL_SIZE) &#123;                //链表头插法                next = sPool;                sPool = this;                sPoolSize++;            &#125;        &#125;    &#125;&#125;</code></pre><p>通过源码，首先要知道Message可以传递数据，主要的方式有：</p><ul><li>what：用户自定义的消息识别标识</li><li>arg1和arg2:只能传递int型参数</li><li>obj：可以传递object类型参数，用得最多的就是传递String</li><li>data：可以使用bundle类型传递 可以看看2.2.2小节的代码案例加深理解，所以在上面注释2的recycleUnchecked()方法里需要把对应的变量重置。</li></ul><p>同时，从2.2.2小节的代码案例也可以看到我是用Message.obtain()来获得一个Message实例的，因为这种方案是直接从Message的消息池里直接获取，避免了new Message()的重复创建开销。</p><h2 id="2-4-Looper源码分析"><a href="#2-4-Looper源码分析" class="headerlink" title="2.4 Looper源码分析"></a>2.4 Looper源码分析</h2><p>在2.1小节，就有分析到Looper.myLooper()、Looper.prepare() 、 Looper.prepareMainLooper()这三个方法，在此再做个复习：</p><ul><li>Looper.myLooper()：从sThreadLocal获取已创建的Looper实例；</li><li>Looper.prepare()：创建Looper实例；</li><li>Looper.prepareMainLooper() ：主线程main函数中调用的方法，在该方法里会调用到Looper.prepare()来创建Looper实例。 剩下的源码还有：</li></ul><pre><code class="java">public final class Looper &#123;    final MessageQueue mQueue;    final Thread mThread;      private Looper(boolean quitAllowed) &#123;        mQueue = new MessageQueue(quitAllowed); //1:在此创建MessageQueue        mThread = Thread.currentThread();    &#125;      public void quit() &#123;        mQueue.quit(false);    &#125;    public void quitSafely() &#123;        mQueue.quit(true);    &#125;      public static void loop() &#123; //2        final Looper me = myLooper();        if (me == null) &#123;            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);        &#125;        final MessageQueue queue = me.mQueue;        for (;;) &#123;            //3；从MessageQueue 中取消息            Message msg = queue.next(); // might block            if (msg == null) &#123;                // No message indicates that the message queue is quitting.                return;            &#125;        //4:通过 Handler 分发消息            msg.target.dispatchMessage(msg);            //5:回收消息            msg.recycleUnchecked();        &#125;    &#125;&#125;</code></pre><p>从注释1可以知道，MessageQueue是在Looper构建函数里生成的。这个知识点要记一下。</p><p>关键是看看注释2，这是整个Handler最重要的源码了，前面所有的源码都最终服务与loop()方法！从源码就能知道该方法中一直在死循环做三件事：</p><ol><li>调用next方法从MessageQueue里获取Message；</li><li>通过dispatchMessage方法将Message分配到目标Handler；</li><li>通过recycleUnchecked方法回收Message；</li></ol><p>其中next()函数待会分析MessageQueue一并分析，现在看看Handler.dispatchMessage 做了什么事：</p><pre><code class="java">public void dispatchMessage(Message msg) &#123;    if (msg.callback != null) &#123;        //通过 handler.pos 形式传入的 Runnable，对应2.2.1小节        handleCallback(msg); //1    &#125; else &#123;        if (mCallback != null) &#123;            //以 Handler(Handler.Callback) 写法            if (mCallback.handleMessage(msg)) &#123; //2                return;            &#125;        &#125;        //以 Handler()&#123;&#125; 写法        handleMessage(msg); //3    &#125;&#125;private static void handleCallback(Message message) &#123;    message.callback.run(); //4&#125;</code></pre><p>可以看出dispatchMessage()就是按照既定的优先级策略，决定Message由谁去处理，我们优先级由高到低介绍：</p><ol><li>handleCallback(msg)：对应注释1，Message里自带的callback优先级最高，实际是调用注释4，最终调用Runnable重写的run()，对应案例可以看看2.2.1小节，getPostMessage(Runnable r)方法。</li><li>mCallback.handleMessage(msg)：也就是Handler.Callback 写法，可以看出这个方法是有返回值的，如果返回true则注释3不会运行到；代码案例见下：</li></ol><pre><code class="java">//创建mCallbackprivate final Handler.Callback mCallback = new Handler.Callback() &#123;    @Override    public boolean handleMessage(Message msg) &#123;switch (msg.what) &#123;        case MSG_DELETE_INFORMATION: &#123;         //do something        &#125;    &#125;&#125;//创建mHandler，并传入mCallbackmHandler = new Handler(this.getMainLooper(), mCallback);//使用mHandler.sendEmptyMessageDelayed(MSG_DELETE_INFORMATION, 1000);</code></pre><ol start="3"><li>handleMessage(msg)：重写handlerMessage()方法，优先级最低，代码案例见下：</li></ol><pre><code class="java">public class BaseHandler extends Handler &#123;       @Override    public void handleMessage(Message msg) &#123;        //do something    &#125;&#125;</code></pre><h2 id="2-5-MessageQueue源码分析"><a href="#2-5-MessageQueue源码分析" class="headerlink" title="2.5 MessageQueue源码分析"></a>2.5 MessageQueue源码分析</h2><p>恭喜你看到这里，这是最后一个源码分析了。 经过上面的分析，我们还遗留了两个关于MessageQueue的函数没有分析，分别是enqueueMessage()和next()。</p><h3 id="2-5-1-存放信息的方法：enqueueMessage"><a href="#2-5-1-存放信息的方法：enqueueMessage" class="headerlink" title="2.5.1 存放信息的方法：enqueueMessage()"></a>2.5.1 存放信息的方法：enqueueMessage()</h3><p>回到2.2.2小节Handler发送消息的函数最后调用了queue.enqueueMessage()将要发送的Message发送到MessageQueue里做处理。</p><pre><code class="java">boolean enqueueMessage(Message msg, long when) &#123;    ...    synchronized (this) &#123;        if (mQuitting) &#123;  //正在退出时，回收msg，加入到消息池            msg.recycle();            return false;        &#125;        msg.markInUse();        msg.when = when;        Message p = mMessages;        boolean needWake;        if (p == null || when == 0 || when &lt; p.when) &#123;            //p为null(代表MessageQueue没有消息）或者msg的触发时间是队列中最早的， 则进入该该分支            msg.next = p;            mMessages = msg;            needWake = mBlocked;         &#125; else &#123;            //将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非            //消息队头存在barrier，并且此时Message是队列中最早的异步消息。            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();            Message prev;            //遍历链表，找到合适位置插入新的消息            for (;;) &#123;                prev = p;                p = p.next;                if (p == null || when &lt; p.when) &#123; //2                    break;                &#125;                if (needWake &amp;&amp; p.isAsynchronous()) &#123;                    needWake = false;                &#125;            &#125;            msg.next = p;            prev.next = msg;        &#125;        if (needWake) &#123;            nativeWake(mPtr);        &#125;    &#125;    return true;&#125;</code></pre><p>如果是第一个触发的信息，则作为对头的消息，否则在注释2，根据when（相对时间）的大小排序找到合适的插入位置。到此就完成了Handler通过调用post或者send方法将一个Message发送到MessageQueue并放在合适的链表位置的逻辑。那么该如何取出来呢？</p><h3 id="2-5-2-获取消息的方法：next"><a href="#2-5-2-获取消息的方法：next" class="headerlink" title="2.5.2 获取消息的方法：next()"></a>2.5.2 获取消息的方法：next()</h3><pre><code class="java">Message next() &#123;    int pendingIdleHandlerCount = -1; // 循环迭代的首次为-1    int nextPollTimeoutMillis = 0; //代表下一个消息到来前，还需要等待的时长    for (;;) &#123;        if (nextPollTimeoutMillis != 0) &#123;            Binder.flushPendingCommands();        &#125;        //1:阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回        nativePollOnce(ptr, nextPollTimeoutMillis);            synchronized (this) &#123;            // 开始尝试获取信息，获取到就返回信息            final long now = SystemClock.uptimeMillis();            Message prevMsg = null;            //取出头节点 Message            Message msg = mMessages;            //2:当消息Handler为空时，在队列中找到下一个异步消息。            if (msg != null &amp;&amp; msg.target == null) &#123;                do &#123;                    prevMsg = msg;                    msg = msg.next;                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());            &#125;            //3:如果消息不为空，根据Message的相对时间判断（when变量）立即取出还是延迟取出            if (msg != null) &#123;                if (now &lt; msg.when) &#123;                    // 下一个消息还没有准备好。设置一个下一轮的等待时间nextPollTimeoutMillis                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                &#125; else &#123;                    // 消息准备好了则成功从MessageQueue里获取一个Message并返回                    mBlocked = false;                    if (prevMsg != null) &#123;                        prevMsg.next = msg.next;                    &#125; else &#123;                        mMessages = msg.next;                    &#125;                    msg.next = null;                    msg.markInUse();                    return msg;                &#125;            &#125; else &#123;                // No more messages.（没有消息，-1代表一直等待）                nextPollTimeoutMillis = -1;            &#125;    &#125;&#125;</code></pre><p>获取一个Message的步骤如下：</p><ol><li>注释1是阻塞操作，nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长，当为-1时代表一直等待。当等待时间到了或者消息队列被唤醒，则开始从队列里获取信息；</li><li>注释2，如果获取的信息是空的，则找下一个节点；</li><li>注释3，获取到非空的信息后，判断是否立刻取出来还是等待一段时间后取出，但最后都会成功返回一个Message；</li><li>如果队列里没有信息了，则在for循环里又回到了注释1进行阻塞等待。</li></ol><p>也就是说next()方法根据消息出发的相对时间，返回下一条需要执行的消息,队列中消息为空时，则会进行阻塞操作。</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息机制全解析Handler&quot;&gt;&lt;a href=&quot;#消息机制全解析Handler&quot; class=&quot;headerlink&quot; title=&quot;消息机制全解析Handler&quot;&gt;&lt;/a&gt;消息机制全解析Handler&lt;/h1&gt;&lt;h1 id=&quot;1、什么是Handler消息传递机</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Activity</title>
    <link href="http://example.com/2022/12/04/Android/Activity/"/>
    <id>http://example.com/2022/12/04/Android/Activity/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:05:26.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h3 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h3><p>onCreate() -&gt; onStart() -&gt; onReume()-&gt;onPouse()-&gt;onStop()-&gt; onDestroy()</p><p>打开新的activity：onCreate() -&gt; onStart() -&gt; onReume()</p><p>Activity A -&gt; Activity B  : onPouse()-&gt;onStop()-&gt;onCreate() -&gt; onStart() -&gt; onReume()</p><p>返回到Activity A： OnRestart()-&gt;onStart-&gt;onResume()</p><p>按back按键回退Activity时，onPause()-&gt;onStop()-&gt;onDestroy()</p><p>‍</p><h3 id="2、切换横竖屏时，生命周期的变化"><a href="#2、切换横竖屏时，生命周期的变化" class="headerlink" title="2、切换横竖屏时，生命周期的变化"></a>2、切换横竖屏时，生命周期的变化</h3><h4 id="2-1-正常情况"><a href="#2-1-正常情况" class="headerlink" title="2.1 正常情况"></a>2.1 正常情况</h4><pre><code class="java">onPause()-&gt;onSaveInstanceState()-&gt;onStop()-&gt;onDestroy()-&gt;onCreate() -&gt; onStart()-&gt;onStartInstanceState()-&gt;onResume()</code></pre><h4 id="2-2-配置android-configChanges"><a href="#2-2-配置android-configChanges" class="headerlink" title="2.2 配置android:configChanges"></a>2.2 配置android:configChanges</h4><p>配置完成避免重走生命周期</p><pre><code class="android">android:configChanges = &quot;orientation | screenSize&quot;</code></pre><p>不会重新走一遍生命周期，而是调用onConfigurationChanged方法</p><h3 id="3、Activity启动模式"><a href="#3、Activity启动模式" class="headerlink" title="3、Activity启动模式"></a>3、Activity启动模式</h3><p>四大启动模式</p><p>Strandard：标准模式</p><p>SingleTop：栈顶复用模式</p><p>SingleTask：栈内复用模式</p><p>Single Instance：单例模式</p><h4 id="3-1-Strandard模式"><a href="#3-1-Strandard模式" class="headerlink" title="3.1 Strandard模式"></a>3.1 Strandard模式</h4><pre><code class="java">默认的启动模式，新启动的Activity就直接加入到栈中，先进先出的原则，同一个Activity会重复创建</code></pre><h4 id="3-2-SingleTop模式"><a href="#3-2-SingleTop模式" class="headerlink" title="3.2 SingleTop模式"></a>3.2 SingleTop模式</h4><pre><code class="java">SingleTop模式每次会从栈顶拿activity，两种情况1、如果栈顶不是当前的Activity，就会创建Activity添加到栈顶2、如果当前的栈顶就是当前的Activity，直接通过onNewInstant()方法拿到当前的Activity</code></pre><h4 id="3-3-SingleTask模式"><a href="#3-3-SingleTask模式" class="headerlink" title="3.3 SingleTask模式"></a>3.3 SingleTask模式</h4><pre><code class="java">SingTask模式属于栈内模式1、如果当前栈中不存在当前的Activity，就直接创建2、如果当前的栈中存在当前的Activity，就弹出该Activity上面的所有的Activity，将它置为栈顶</code></pre><h4 id="3-4-SingleInstance-模式"><a href="#3-4-SingleInstance-模式" class="headerlink" title="3.4 SingleInstance 模式"></a>3.4 SingleInstance 模式</h4><pre><code class="java">SingleInstance模式每次进行启动Activity时，都会创建一个栈进行保存，当使用到该Activity时，就会从指定的栈中取出当前的Activity</code></pre><h3 id="3、如何设置启动模式"><a href="#3、如何设置启动模式" class="headerlink" title="3、如何设置启动模式"></a>3、如何设置启动模式</h3><h4 id="3-1-通过清单文件AndroidManifest-xml配置Activity的启动模式"><a href="#3-1-通过清单文件AndroidManifest-xml配置Activity的启动模式" class="headerlink" title="3.1 通过清单文件AndroidManifest.xml配置Activity的启动模式"></a>3.1 通过清单文件AndroidManifest.xml配置Activity的启动模式</h4><pre><code class="android">android:launchMode=&quot;standard&quot;</code></pre><h4 id="3-2-直接再代码中实现"><a href="#3-2-直接再代码中实现" class="headerlink" title="3.2 直接再代码中实现"></a>3.2 直接再代码中实现</h4><pre><code class="java">Intent intent = new Intent(this, lyActivity.class);intent.addFlags(Intent.FLAC_ACTIVITY_NEW_TASK);starthctivity(intent)</code></pre><p>注：第二种的优先级会高于第一种，两者都存在使用第二种</p><h3 id="4、Activity的启动流程"><a href="#4、Activity的启动流程" class="headerlink" title="4、Activity的启动流程"></a>4、Activity的启动流程</h3><h4 id="4-1-跨进程启动"><a href="#4-1-跨进程启动" class="headerlink" title="4.1 跨进程启动"></a>4.1 跨进程启动</h4><ol><li>点击App图标，Launcher进程会采用Binder IPC向系统system_server进程发起startActivity的请求；</li><li>system_server进程收到请求后，向zygote进程发送创建进程的请求；</li><li>zygote进程fork出新的子进程，即App进程</li><li>App进程，通过Binder IPC向system_server进程发起attachApplication请求；</li><li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向APP进程发送scheduleLaunchActivity请求</li><li>App进程的binder线程在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息，主线程收到message后，通过反射机制创建目标Activity，并回调Activity.onCreate()方法。</li></ol><h4 id="4-2-进程内启动"><a href="#4-2-进程内启动" class="headerlink" title="4.2 进程内启动"></a>4.2 进程内启动</h4><ol><li>请求进程A：startActivity-》system_server进程：AMS（ActivityManagerService)</li><li>解析Activity信息、处理请求参数、消息处理</li><li>回到请求进程A：Application Thread-&gt;ActivityThread-&gt;Activity生命周期</li></ol><h3 id="5-ANR的四种场景"><a href="#5-ANR的四种场景" class="headerlink" title="5 ANR的四种场景"></a>5 ANR的四种场景</h3><ol><li>Input Dispatching timeout：5s 内未响应键盘输入、触摸事件等</li><li>Service TimeOut :service 未在规定时间执行完成：前台服务20s，后台服务200s</li><li>BroadCaseQueue TimeOut：未在规定时间内处理完广播，前台广播10s内，后台广播60s内</li><li>Content Provider TimeOut：public在10s内没有完成</li></ol><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Activity&quot;&gt;&lt;a href=&quot;#Activity&quot; class=&quot;headerlink&quot; title=&quot;Activity&quot;&gt;&lt;/a&gt;Activity&lt;/h1&gt;&lt;h3 id=&quot;1、生命周期&quot;&gt;&lt;a href=&quot;#1、生命周期&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>ContentProvider内容提供者</title>
    <link href="http://example.com/2022/12/04/Android/ContentProvider%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85/"/>
    <id>http://example.com/2022/12/04/Android/ContentProvider%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:06:17.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContentProvider内容提供者"><a href="#ContentProvider内容提供者" class="headerlink" title="ContentProvider内容提供者"></a>ContentProvider内容提供者</h1><p>‍</p><h1 id="1、-什么是内容提供者"><a href="#1、-什么是内容提供者" class="headerlink" title="1、 什么是内容提供者"></a>1、 什么是内容提供者</h1><p>之前有说过可以用Intent在组件中传递数据，那么其数据的大小是否有限制呢？很明显是有限制的，Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。因此我们就可以通过ContentProvider进行进程间的数据传递，也就是ContentProvider是一种进程间的数据传递的方式。 一般来说，Android数据存储的方式有：文件，数据库，网络，SharePreferences，ContentProvider。 <img src="https://uploadfiles.nowcoder.com/images/20220920/545613072_1663655781215/73009B82B7DEC08BC50ACE3F65947160" alt="图片说明"> 上图是网上找到的一个图片，然而从图上可以明显的知道，ContentProvider更准确来说只是一个中间者的身份，真正存储数据的是数据库和文件等形式，这一点要分清楚！</p><h1 id="2、ContentProvider-使用方法"><a href="#2、ContentProvider-使用方法" class="headerlink" title="2、ContentProvider 使用方法"></a>2、ContentProvider 使用方法</h1><h2 id="2-1-ContentResolver和url"><a href="#2-1-ContentResolver和url" class="headerlink" title="2.1 ContentResolver和url"></a>2.1 ContentResolver和url</h2><p>介绍ContentProvider的使用，就需要先了解ContentResolver和url。 url相信很多读者都知道是统一资源标识符。ContentProvider使用表的形式来组织数据，无论数据的来源是什么，ConentProvider 都会认为是一种表，然后把数据组织成表格。因此就需要一个url来定位需要操作的是哪个数据。下面是网上看到的自定义url的组成图，和大家分享下。 <img src="https://uploadfiles.nowcoder.com/images/20220920/545613072_1663655801033/5F9096BCFD7A7CD3E50FE6B5A9C077A2" alt="图片说明">​</p><p>ContentResolver统一管理不同 ContentProvider间的操作。因为同一个进程可能有多个ContentProvider，如果每一个都需要单独去管理，那么花费的成本自然很好。因此希望有一个类，专门对多个ContentProvider做统一管理，ContentResolver就出现了。</p><h2 id="2-2-使用ContentProvider在两个进程进行数据传递"><a href="#2-2-使用ContentProvider在两个进程进行数据传递" class="headerlink" title="2.2 使用ContentProvider在两个进程进行数据传递"></a>2.2 使用ContentProvider在两个进程进行数据传递</h2><p>面试中较少会问ContentProvider如何使用，反而会问实现的原理，在此为了让读者知道怎么用，进一步了解ContentProvider是什么，我简单描述下两个怎么通过ContentProvider进行数据传递，但不会涉及完整的代码实现。下面选用数据存储方式是数据库的形式，讲一下完整使用流程。</p><h3 id="进程A："><a href="#进程A：" class="headerlink" title="进程A："></a>进程A：</h3><ol><li>创建数据库类：MyDBHelper，该类主要完成数据库创建和对应表格的创建；</li></ol><pre><code class="java">public class DBHelper extends SQLiteOpenHelper &#123;    ...    @Override    public void onCreate(SQLiteDatabase db) &#123;        // 创建两个表格:用户表和兴趣表    &#125;    ...&#125;</code></pre><ol start="2"><li>实现自定义MyProvider类，继承ContentProvider，并重写增删改查接口；</li></ol><pre><code class="java">public class MyProvider extends ContentProvider &#123;    @Override    public boolean onCreate() &#123;        // 在onCreate对数据库进行初始化        return true;    &#125;    /**     * 添加数据     */    @Override    public Uri insert(Uri uri, ContentValues values) &#123;        // 根据url找到需要操作的表格        String table = getTableName(uri);        // 向该表添加数据        db.insert(table, null, values);        // 当该URI对应的ContentProvider类里面的数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）        mContext.getContentResolver().notifyChange(uri, null);        return uri;    &#125;    // 以下接口也需要重写，此处略    query();  查询数据    update(); 更新数据    delete(); 删除数据    ...&#125;</code></pre><ol start="3"><li>注册自定义MyProvider类：在Manifest中声明它的Uri和权限</li></ol><pre><code class="java">&lt;provider    android:name=&quot;MyProvider&quot;   android:authorities=&quot;com.xurui.myprovider&quot;      // 声明外界进程可访问该Provider的权限（读 &amp; 写），具体可以参考本文第三节   android:permission=&quot;com.xurui.PROVIDER&quot;         // 设置此provider是否可以被其他进程使用   android:exported=&quot;true&quot;   android:enabled=&quot;true&quot;  /&gt;</code></pre><h3 id="进程B"><a href="#进程B" class="headerlink" title="进程B"></a>进程B</h3><ol><li>在Manifest声明可访问的权限</li></ol><pre><code class="java"> // 声明本应用可允许通信的权限（全权限），需要和进程A保持一致    &lt;uses-permission android:name=&quot;com.xurui.PROVIDER&quot;/&gt;</code></pre><ol start="2"><li>访问MyProvider，进行增加数据操作</li></ol><pre><code class="java">public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        // 设置URI        Uri uri_user = Uri.parse(&quot;content:/com.xurui.myprovider/user&quot;);        // 插入表中数据        ContentValues values = new ContentValues();        values.put(&quot;_id&quot;, 1);        values.put(&quot;name&quot;, &quot;CVTE_Jordan&quot;);        // 获取ContentResolver        ContentResolver resolver =  getContentResolver();        // 通过ContentResolver 根据URI 向ContentProvider中插入数据        resolver.insert(uri_user,values);    &#125;&#125;   </code></pre><h1 id="3、ContentProvider的权限管理-读写分离，权限控制-精确到表级，URL控制"><a href="#3、ContentProvider的权限管理-读写分离，权限控制-精确到表级，URL控制" class="headerlink" title="3、ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)"></a>3、ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)</h1><p>对于由ContentProvider公开出来的数据，它应该是存储在应用内存中的数据。而对于一些存储在外存上的数据，对于ContentProvider，需要在AndroidManifest.xml文件中配置节点的属性，来实现权限控制。通常使用一些属性设置:</p><ul><li>android:grantUriPermssions：临时许可标志。</li><li>android:permission：Provider读写权限。</li><li>android:readPermission：Provider的读权限。</li><li>android:writePermission：Provider的写权限。</li><li>android:enabled：标记允许系统启动Provider。</li><li>android:exported：标记允许其他应用程序使用这个Provider。</li><li>android:multiProcess：标记允许系统启动Provider相同的进程中调用客户端。</li></ul><h1 id="4、说说ContentProvider、ContentResolver、ContentObserver-之间的关系？"><a href="#4、说说ContentProvider、ContentResolver、ContentObserver-之间的关系？" class="headerlink" title="4、说说ContentProvider、ContentResolver、ContentObserver 之间的关系？"></a>4、说说ContentProvider、ContentResolver、ContentObserver 之间的关系？</h1><p>在我个人开发中，后面两个类反而比ContentProvider用的更多，来看看其联系：</p><ul><li>ContentProvider：内容提供者，主要作用就是管理数据，比如最常见的增删改查操作，同时为这些数据的访问提供了统一的接口，实现进程间的数据传递和共享；</li><li>ContentResolver：内容解析者，ContentResolver可以为不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</li><li>ContentObserver：内容观察者，观察ContentProvider中的数据变化，有变化的时候执行特定操作。本人用的最多的是监听Settings数据库的变化。由于ContentObserver的生命周期不同步于Activity和Service等，因此，在不需要时，需要手动的调用unregisterContentObserver()去取消注册。</li></ul><pre><code class="java">//注册smsContentObserver用于监听短信数据库变化if (smsContentObserver != null) &#123;     getContentResolver().registerContentObserver(Uri.parse(&quot;content://sms&quot;),     true, smsContentObserver);// 注册监听短信数据库的变化     Log.i(TAG, &quot;注册监听短信数据库的变化&quot;);&#125;</code></pre><h1 id="5、ContentProvider-实现原理"><a href="#5、ContentProvider-实现原理" class="headerlink" title="5、ContentProvider 实现原理"></a>5、ContentProvider 实现原理</h1><p>ContentProvider的底层采用了<strong>Binder机制</strong>，后续文章会普及Binder机制，这里可以理解为一种Android跨进程通讯的机制，简单的用法是进程A可以通过Binder获得进程B的本地代理，通过本地代理，就可以在进程A里面的调用进程B的方法。在ContentProvider的实现原理中，通过ContentResolver可以查找对应给定Uri的ContentProvider，返回对应的本地代理 BinderProxy，通过这个BinderProxy就可以调用insert、delete接口。</p><h2 id="5-1-ContentProvider的底层是采用Android中的Binder机制，既然已经有了binder实现了进程间通信了为什么还会需要contentProvider？"><a href="#5-1-ContentProvider的底层是采用Android中的Binder机制，既然已经有了binder实现了进程间通信了为什么还会需要contentProvider？" class="headerlink" title="5.1 ContentProvider的底层是采用Android中的Binder机制，既然已经有了binder实现了进程间通信了为什么还会需要contentProvider？"></a>5.1 ContentProvider的底层是采用Android中的Binder机制，既然已经有了binder实现了进程间通信了为什么还会需要contentProvider？</h2><h4 id="原因1：从架构层次看"><a href="#原因1：从架构层次看" class="headerlink" title="原因1：从架构层次看"></a>原因1：从架构层次看</h4><p>一个软件平台至少由业务层、数据访问层、数据层构成。其中业务层就是一系列的App，数据层就是数据库，文件，网络等存储方式。那么为了降低业务层和数据层的耦合程度，我们希望数据访问层也可以有一个个独立的组件，对业务层提供统一调用接口，对数据层可以针对不同数据存储类型有不同的实现方式。这样业务层不需要关心下层的具体实现，只需要按约定好的标准接口去增删改查即可。这个独立的组件就是ContentProvider。</p><h4 id="原因2：从传输效率看"><a href="#原因2：从传输效率看" class="headerlink" title="原因2：从传输效率看"></a>原因2：从传输效率看</h4><p>不同的进程可以通过Binder、Intent去传输数据，但如果数据量大的时候，就都不适用了。而ContentProvider进行数据传输的方式是采用匿名共享内存机制，众所周知，共享内存可以高效地传递大量数据。因此，结合了Binder机制和匿名共享内存机制的ContentProvider就更加适合不同进程间传递数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ContentProvider内容提供者&quot;&gt;&lt;a href=&quot;#ContentProvider内容提供者&quot; class=&quot;headerlink&quot; title=&quot;ContentProvider内容提供者&quot;&gt;&lt;/a&gt;ContentProvider内容提供者&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Broadcast广播机制</title>
    <link href="http://example.com/2022/12/04/Android/Broadcast%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/12/04/Android/Broadcast%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:06:06.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Broadcast广播机制"><a href="#Broadcast广播机制" class="headerlink" title="Broadcast广播机制"></a>Broadcast广播机制</h1><h3 id="1、注册方式"><a href="#1、注册方式" class="headerlink" title="1、注册方式"></a>1、注册方式</h3><h4 id="1-1-静态注册"><a href="#1-1-静态注册" class="headerlink" title="1.1 静态注册"></a>1.1 静态注册</h4><p>使用清单文件进行注册</p><p>在AndroidManifest.xml清单文件里直接声明的方式叫做静态注册。</p><pre><code class="java">&lt;receiver     //此广播接收者类是mXRReceiver    android:name=&quot;.mXRReceiver&quot; &gt;    //用于系统启动完成时，接收系统发送的广播    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><pre><code class="java">&lt;receiver  android:enabled=[&quot;true&quot; | &quot;false&quot;]  //此broadcastReceiver能否接收其他App的发出的广播  //默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false  android:exported=[&quot;true&quot; | &quot;false&quot;]  android:icon=&quot;drawable resource&quot;  android:label=&quot;string resource&quot;  //继承BroadcastReceiver子类的类名  android:name=&quot;.mXRReceiver&quot;  //具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收；  android:permission=&quot;string&quot;  //BroadcastReceiver运行所处的进程  //默认为app的进程，可以指定独立的进程  //注：Android四大基本组件都可以通过此属性指定自己的独立进程  android:process=&quot;string&quot; &gt;  //用于指定此广播接收器将接收的广播类型  //本示例中给出的是用于系统启动完成时，接收系统发送的广播  &lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;  &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><p>‍</p><h4 id="1-2-动态注册"><a href="#1-2-动态注册" class="headerlink" title="1.2 动态注册"></a>1.2 动态注册</h4><p>在代码中进行注册</p><pre><code class="java">private void initBroadcastReceiver() &#123;    if (mXRBroadcastReceiver == null) &#123;        mXRBroadcastReceiver = new BroadcastReceiver() &#123;            @Override            public void onReceive(Context context, Intent intent) &#123;                ...            &#125;        &#125;;        IntentFilter intentFilter = new IntentFilter();        intentFilter.addAction(Intent.BOOT_COMPLETE);        registerReceiver(mXRBroadcastReceiver, intentFilter);    &#125;&#125;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>注意：动态广播最好在Activity的onResume()注册、onPause()注销。一旦忘记注销，那么就会造成内存泄露哦。</p><p>‍</p><h3 id="2-Broadcast的分类"><a href="#2-Broadcast的分类" class="headerlink" title="2 Broadcast的分类"></a>2 Broadcast的分类</h3><p>1、普通广播</p><p>2、系统广播</p><p>3、有序广播</p><p>4、粘性广播</p><p>5、本地广播</p><h4 id="2-1-普通广播"><a href="#2-1-普通广播" class="headerlink" title="2.1 普通广播"></a>2.1 普通广播</h4><pre><code>也就是标准广播，是一种完全异步执行的广播，和学校大喇叭完全一样，发出广播后，所有广播接收者都能收到广播，且没有优先之分，上面程序都是普通广播。</code></pre><h4 id="2-2-系统广播"><a href="#2-2-系统广播" class="headerlink" title="2.2 系统广播"></a>2.2 系统广播</h4><table><thead><tr><th>监听网络变化</th><th>android.net.conn.CONNECTIVITY_CHANGE</th></tr></thead><tbody><tr><td>关闭或打开飞行模式</td><td>Intent.ACTION_AIRPLANE_MODE_CHANGED</td></tr><tr><td>充电时或电量发生变化</td><td>Intent.ACTION_BATTERY_CHANGED</td></tr><tr><td>电池电量低</td><td>Intent.ACTION_BATTERY_LOW</td></tr><tr><td>电池电量充足（即从电量低变化到饱满时会发出广播</td><td>Intent.ACTION_BATTERY_OKAY</td></tr><tr><td>系统启动完成后(仅广播一次)</td><td>Intent.ACTION_BOOT_COMPLETED</td></tr><tr><td>按下照相时的拍照按键(硬件按键)时</td><td>Intent.ACTION_CAMERA_BUTTON</td></tr><tr><td>屏幕锁屏</td><td>Intent.ACTION_CLOSE_SYSTEM_DIALOGS</td></tr><tr><td>设备当前设置被改变时(界面语言、设备方向等)</td><td>Intent.ACTION_CONFIGURATION_CHANGED</td></tr><tr><td>插入耳机时</td><td>Intent.ACTION_HEADSET_PLUG</td></tr><tr><td>未正确移除SD卡但已取出来时(正确移除方法:</td><td></td></tr><tr><td>设置–SD卡和设备内存–卸载SD卡)</td><td>Intent.ACTION_MEDIA_BAD_REMOVAL</td></tr><tr><td>插入外部储存装置（如SD卡）</td><td>Intent.ACTION_MEDIA_CHECKING</td></tr><tr><td>成功安装APK</td><td>Intent.ACTION_PACKAGE_ADDED</td></tr><tr><td>成功删除APK</td><td>Intent.ACTION_PACKAGE_REMOVED</td></tr><tr><td>重启设备</td><td>Intent.ACTION_REBOOT</td></tr><tr><td>屏幕被关闭</td><td>Intent.ACTION_SCREEN_OFF</td></tr><tr><td>屏幕被打开</td><td>Intent.ACTION_SCREEN_ON</td></tr><tr><td>关闭系统时</td><td>Intent.ACTION_SHUTDOWN</td></tr><tr><td>重启设备</td><td>Intent.ACTION_REBOOT</td></tr></tbody></table><h4 id="2-3-有序广播"><a href="#2-3-有序广播" class="headerlink" title="2.3 有序广播"></a>2.3 有序广播</h4><pre><code>有序广播是一种同步执行的广播，按广播接收者的优先级由高到低排序，轮流接收到广播，且前面的广播接收者可以拦截该广播，这样后面的广播接收者就无法接收到该广播了。同时，前面的广播接受者也可以修改该广播并不做拦截，这样下一个接收到的广播就是被修改过的。 设置广播接收者的优先级可以用priority属性，数字越高代表优先级越高，最高是1000.</code></pre><pre><code class="java">&lt;receiver     //此广播接收者类是mXRReceiver    android:name=&quot;.mXRReceiver&quot; &gt;    //用于系统启动完成时，接收系统发送的广播    &lt;intent-filter android:priority=&quot;1000&quot;&gt;        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><h4 id="2-4-本地广播"><a href="#2-4-本地广播" class="headerlink" title="2.4 本地广播"></a>2.4 本地广播</h4><p>BroadcastReceiver可用于不同应用之间传递消息，但难免会出现这两种情况：</p><ul><li>我们的App注册了广播接收者A，同时其他App可能要完成某个操作，碰巧发送了符合接收者A过滤条件的广播，导致我们的App就一直错误的接收到了这个广播；</li><li>我们的App注册了广播接收者A，同时其他App也碰巧注册了和我们同样过滤条件的广播接收者，这样就导致本来是我们App接收的广播，其他App也接收到了；</li></ul><p>基于这两大问题，LocalBroadcastManager就可以很好的解决该问题。LocalBroadcastManager用于应用内部传递消息，比broadcastReceiver更加<strong>高效和安全</strong>。</p><h5 id="2-4-1-为何更加安全"><a href="#2-4-1-为何更加安全" class="headerlink" title="2.4.1 为何更加安全"></a>2.4.1 为何更加安全</h5><p>BroadcastReceiver是以 Binder 通讯方式为底层实现的机制不同，众所周知Binder是跨进程的。而LocalBroadcastManager 是利用应用内部的Handler来实现，只是利用到了 IntentFilter 的 match 功能，因为是 Handler 实现的应用内的通信，自然安全性更好，效率更高。</p><h5 id="2-4-2-如何实现本地广播"><a href="#2-4-2-如何实现本地广播" class="headerlink" title="2.4.2 如何实现本地广播"></a>2.4.2 如何实现本地广播</h5><p>方法一：把全局广播改为本地广播</p><ul><li>注册广播时将exported属性设置为false，表示该广播接收者不对外；</li><li>在广播发送和接收时，增设相应权限permission，用于权限验证；</li><li>发送广播时通过intent.setPackage(packageName)指定该广播接收器所在的包名，因此保证该发送出去的广播只会发送到指定包名的App内的广播接收者。</li></ul><h3 id="3、APP1-能否接收到APP2-的广播"><a href="#3、APP1-能否接收到APP2-的广播" class="headerlink" title="3、APP1 能否接收到APP2 的广播"></a>3、APP1 能否接收到APP2 的广播</h3><p>当然能，只要使用全局的BroadCastRecevier能进行跨进程通信，不过只能被动接收广播。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Broadcast广播机制&quot;&gt;&lt;a href=&quot;#Broadcast广播机制&quot; class=&quot;headerlink&quot; title=&quot;Broadcast广播机制&quot;&gt;&lt;/a&gt;Broadcast广播机制&lt;/h1&gt;&lt;h3 id=&quot;1、注册方式&quot;&gt;&lt;a href=&quot;#1、注</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>AsyncTask全解析</title>
    <link href="http://example.com/2022/12/04/Android/AsyncTask%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2022/12/04/Android/AsyncTask%E5%85%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:05:44.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AsyncTask全解析"><a href="#AsyncTask全解析" class="headerlink" title="AsyncTask全解析"></a>AsyncTask全解析</h1><h1 id="1、AsyncTask介绍"><a href="#1、AsyncTask介绍" class="headerlink" title="1、AsyncTask介绍"></a>1、AsyncTask介绍</h1><p>回顾上一节的问题：更新UI的方式有哪些？答案有：</p><ul><li>Activity.runOnUiThread(Runnable)</li><li>View.post(Runnable)，View.postDelay(Runnable, long)</li><li>Handler</li><li>AsyncTask</li><li>Rxjava</li><li>LiveData</li></ul><p>本文的主角AsyncTask，本人现在用得比较少，更多用的是Rxjava。同时面试的时候知道AsyncTask是什么？怎么用？有什么不足之处或者需要注意什么？懂了这三个问题一般就可以了。至于看源码，可当作进阶，个人建议还是有必要学习一下的。那么AssyncTask究竟是什么呢？</p><p>AsyncTask是一个轻量级的异步任务类，可以在线程池里执行比较耗时的后台任务，然后把执行的进度和最后的结果传递给主进程，并在主进程中更新UI。使用容易，而且好理解。</p><h2 id="1-1-AsyncTask的使用"><a href="#1-1-AsyncTask的使用" class="headerlink" title="1.1 AsyncTask的使用"></a>1.1 AsyncTask的使用</h2><p>同样从使用入手，看看代码。以下代码以往文件里写数据为例：</p><pre><code>private class FileTestTask extends AsyncTask&lt;Void, Long, Boolean&gt; &#123; //1    @Override    protected void onPreExecute() &#123;        //初始化一些数据        initProcessInfo();    &#125;    @Override    protected Long doInBackground(Void... integers) &#123;        //创建目录        ...        while (mTotalWriteSize &lt;= mInitFreeDataValue) &#123;            ...            mTotalWriteSize += writeSize / 1024 / 1024; // M            //2：反馈当前任务进度            publishProgress(mTotalWriteSize);        &#125;        return true;    &#125;    @Override    protected void onProgressUpdate(Long... progresses) &#123; //3        if (progresses != null &amp;&amp; progresses.length &gt;= 1) &#123;            updateProcessInfo(progresses[0]); //更新进度条        &#125;    &#125;    @Override    protected void onPostExecute(Boolean result) &#123; //4        if (result) &#123;            updateContentInfo(R.string.text_show_result_test_over);        &#125; else &#123;            updateContentInfo(R.string.text_show_result_fail);        &#125;    &#125;&#125;//主线程中使用自定义的FileTestTaskif (mFileTestTask == null) &#123;    mFileTestTask = new FileTestTask();    mFileTestTask.execute();&#125;</code></pre><h2 id="1-2-核心方法"><a href="#1-2-核心方法" class="headerlink" title="1.2 核心方法"></a>1.2 核心方法</h2><ul><li><p>onPreExecute()：字面上就是“提前执行”，会在后台任务开始前调用，并在主线程中执行，因此常用于初始化一些数据和界面。</p></li><li><p>doInBackground(Params…)：字面上是“在背后处理”，就是在后台处理所有耗时的任务，这些任务都会在子线程中处理。有两个需要注意的点：</p><ul><li>不能在这个函数进行UI操作，因为该函数是在子线程运行的。如果需要更新当前任务完成进度条，需要运行publishProgress(Progress…)，如上面的注释2，而最终是调用onProgressUpdate()去更新进度条；</li><li>执行完之后可以通过return将执行的结果返回，返回的结果会在onPostExecute()里执行，如注释4，我这边只是更新了一个文字内容。</li></ul></li><li><p>onProgressUpdate(Progress…)：如上一段所述，调用publishProgress(Progress…)后会把参数（如当前任务处理的进度）传递给onProgressUpdate()并被调用，因为该方法在主进程进行，因此可以进行UI修改。</p></li><li><p>onPostExecute()：如上所述，doInBackground()会把执行结果返回给 onPostExecute()并被调用，该方法也在主线程运行，可以做一些结尾的动作，如提示任务完成等。</p></li></ul><p>上面几个核心方法的调用顺序为： onPreExecute() –&gt; doInBackground() –&gt; publishProgress() –&gt; onProgressUpdate() –&gt; onPostExecute()。</p><p>如果不需要更新进度则为onPreExecute() –&gt; doInBackground() –&gt; onPostExecute()。</p><h2 id="1-3-三个泛型类参数"><a href="#1-3-三个泛型类参数" class="headerlink" title="1.3 三个泛型类参数"></a>1.3 三个泛型类参数</h2><p>在1.1小节案例代码里的注释1 可以看到AsyncTask&lt;Void, Long, Boolean&gt;，其原型是 AsyncTask&lt;Params, Progress, Result&gt;，这三个泛型类参数含义如下：</p><ul><li>Params：开始异步任务执行时传入的参数类型，对应doInBackground()，本案例是Void，代表不需要传入参数；</li><li>Progress：异步任务执行过程中，返回下载进度值的类型，对应onProgressUpdate()，本案例是Long，代表目前已经写入的字节数；</li><li>Result：异步任务执行完成后，返回的结果类型，对应onPostExecute()，本案例返回的是Boolean类型，true代表任务完成；</li></ul><h1 id="2、AsyncTask使用心得"><a href="#2、AsyncTask使用心得" class="headerlink" title="2、AsyncTask使用心得"></a>2、AsyncTask使用心得</h1><h2 id="2-1-AsyncTask的使用注意事项"><a href="#2-1-AsyncTask的使用注意事项" class="headerlink" title="2.1 AsyncTask的使用注意事项"></a>2.1 AsyncTask的使用注意事项</h2><p>从第1小节，我们了解了AsyncTask的使用方法和步骤，现在再强调几个注意点，不仅面试官可能会问到，平时自己工作中也要多注意：</p><ul><li>AsyncTask的实例需要在UI线程也就是主线程中创建，调用execute()开始执行任务时，也要在主线程执行；</li><li>不要手动调用onPreExecute()，doInBackground(Params… params)，onProgressUpdate(Progress… values)，onPostExecute(Result result)这几个方法；</li><li>只有onPreExecute()，onProgressUpdate(Progress… values)，onPostExecute(Result result)可以执行UI相关操作，doInBackground(Params… params)不能更改UI界面；</li><li>一个任务实例只能执行一次execute()，执行多次会报异常。</li></ul><h2 id="2-2-AsyncTask的不足之处"><a href="#2-2-AsyncTask的不足之处" class="headerlink" title="2.2 AsyncTask的不足之处"></a>2.2 AsyncTask的不足之处</h2><ol><li>生命周期</li></ol><p>AsyncTask不与任何组件绑定生命周期，因此会出现组件生命周期结束了，但AsyncTask还存在，所以需要在onDestroy()调用 cancel(boolean)，手动结束AsyncTask；</p><ol start="2"><li>内存泄漏</li></ol><p>和之前说的Handler造成内存泄露的原因是一样的。如果AsyncTask被声明为Activity的非静态的内部类，如本文使用代码案例一样，那么AsyncTask会保留一个所在Activity的引用。如果Activiy被销毁，此时因此AsyncTask保留了它的引用，导致Activity无法被回收，引起内存泄露。</p><p>3.) 结果丢失</p><p>如果屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity重新创建，如果之前运行的AsyncTask是非静态的内部类，此时就会持有之前旧的Activity的引用，而旧的Activity已经销毁了，这时调用onPostExecute()再去更新界面将不再生效，无法更新到新的Activity到界面。</p><h1 id="3、-源码分析（进阶）"><a href="#3、-源码分析（进阶）" class="headerlink" title="3、 源码分析（进阶）"></a>3、 源码分析（进阶）</h1><p>如果看完前面2节，去面试已经没问题了，对AsyncTask的源码分析属于进阶，如果有时间，建议看看源码，因为整个第3节的源码代码关联性很强，为了方便说明，所有代码块的关键代码行的注释码都是连贯的。</p><p>回顾下AsyncTak的使用方法：我们只要执行new FileTestTask().execute()，就会自动执行onPreExecute()，doInBackground(Params… params)，onProgressUpdate(Progress… values)，onPostExecute(Result result)这几个方法。这是怎么做到的呢？</p><p>带着这个思路，按顺序，我们先看看在初始化一个AsyncTask时，调用函数都做了什么。</p><pre><code class="java">public AsyncTask() &#123;        mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;//1            public Result call() throws Exception &#123;                mTaskInvoked.set(true);                Result result = null;                try &#123;                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);                    //noinspection unchecked                    result = doInBackground(mParams); //2                    Binder.flushPendingCommands();                &#125; catch (Throwable tr) &#123;                    mCancelled.set(true);                    throw tr;                &#125; finally &#123;                    postResult(result); //3                &#125;                return result;            &#125;        &#125;;        mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; //4            @Override            protected void done() &#123;                try &#123;                    postResultIfNotInvoked(get());                &#125; catch (InterruptedException e) &#123;                    android.util.Log.w(LOG_TAG, e);                &#125; catch (ExecutionException e) &#123;                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,                            e.getCause());                &#125; catch (CancellationException e) &#123;                    postResultIfNotInvoked(null);                &#125;            &#125;        &#125;;    &#125;</code></pre><p>我们可以看到这仅仅是初始化了两个变量，mWorker和mFuture，并在初始化mFuture的时候将mWorker作为参数传入，如注释1和注释4。此时仅仅完成初始化，什么都没做。不过记住这个注释1的call()函数，里面有注释2和注释3两个关键函数，后面是如何调用到的呢？接着执行execute()就开始执行任务了，来看看execute()的源码：</p><pre><code class="java">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;    return executeOnExecutor(sDefaultExecutor, params); //5&#125;  public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,            Params... params) &#123;    if (mStatus != Status.PENDING) &#123;        switch (mStatus) &#123;            case RUNNING:                throw new IllegalStateException(&quot;Cannot execute task:&quot;                        + &quot; the task is already running.&quot;);            case FINISHED:                throw new IllegalStateException(&quot;Cannot execute task:&quot;                        + &quot; the task has already been executed &quot;                        + &quot;(a task can be executed only once)&quot;);        &#125;    &#125;    mStatus = Status.RUNNING;    onPreExecute(); //6    mWorker.mParams = params;    exec.execute(mFuture); //7    return this;&#125;</code></pre><p>注释5，execute()调用executeOnExecutor(sDefaultExecutor, params)，终于在注释6，看到了熟悉的函数onPreExecute()！执行完onPreExecute()，即完成了一些初始化工作后，调用注释7:exec.execute(mFuture)开始执行耗时任务，并把上面注释4初始化的mFuture实例传入。</p><p>进一步看看注释7这个exec是什么？看下代码调用，就知道exec是注释5的sDefaultExecutor，因此注释7的exec.execute(mFuture)实际上是执行sDefaultExecutor.execute(mFuture)。再追述源码可以看到sDefaultExecutor是SerialExecutor类，具体源码如下：</p><pre><code class="java">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static class SerialExecutor implements Executor &#123;    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); //8    Runnable mActive; //9    public synchronized void execute(final Runnable r) &#123; //10        mTasks.offer(new Runnable() &#123; //11            public void run() &#123;                try &#123;                    r.run(); //12                &#125; finally &#123;                    scheduleNext(); //13                &#125;            &#125;        &#125;);        if (mActive == null) &#123;            scheduleNext();        &#125;    &#125;    protected synchronized void scheduleNext() &#123;        if ((mActive = mTasks.poll()) != null) &#123; //14            THREAD_POOL_EXECUTOR.execute(mActive); //15        &#125;    &#125;&#125;</code></pre><p>可以看出这个SerialExecutor是静态内部类，因此每个AsyncTask都共有。SerialExecutor维护了一个队列，也就是注释8的mTasks。在注释10通过加锁保证AsyncTask的任务是串行的。好好看注释10这个execute()函数，主要做了两件事：</p><ol><li>在注释11向队列mTask加入一个新的任务，也就是注释7传入的mFuture对象；</li><li>调用注释 13的scheduleNext()方法，进而调用注释14的THREAD_POOL_EXECUTOR.execute(mActive)来执行队列头部任务。</li></ol><p>所以，SerialExecutor只是保证任务是串行的，真正执行任务还是交给THREAD_POOL_EXECUTOR。继续追代码，看看THREAD_POOL_EXECUTOR是什么？</p><pre><code class="java"> ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,                sPoolWorkQueue, sThreadFactory);        threadPoolExecutor.allowCoreThreadTimeOut(true);        THREAD_POOL_EXECUTOR = threadPoolExecutor; //16</code></pre><p>注释16可以看到THREAD_POOL_EXECUTOR就是一个线程池，注释15调用了线程池的execute()方法，执行具体的耗时任务，而注释15的mActive是从注释14的mTasks队列获取的Runnable，这个Runnable又是注释11加入队列的，注释11这个Runnable就是注释7传入的mFuture，接着这个mFuture又是注释4传入的mWorker构造的。通过倒推，就知道注释15执行的具体的耗时任务其实就是注释1中的call()函数。终于，调用到了注释1，先执行完doInBackground()方法处理后台耗时任务，又执行postResult()方法返回处理结果，一切都和我们想的一样！</p><p>最后看看怎么结束任务吧。</p><pre><code class="java"> private Result postResult(Result result) &#123;        @SuppressWarnings(&quot;unchecked&quot;)        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,                new AsyncTaskResult&lt;Result&gt;(this, result)); //17         message.sendToTarget();        return result;    &#125;</code></pre><p>没错，就是Handler机制。AsyncTask内部又一个Handler对象，这也是为什么2.1小节说AsyncTask需要在主线程创建，因为Handler需要在主线程创建：</p><pre><code class="java">private static class InternalHandler extends Handler &#123;        public InternalHandler() &#123;            super(Looper.getMainLooper());        &#125;        @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)        @Override        public void handleMessage(Message msg) &#123;            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;            switch (msg.what) &#123;                case MESSAGE_POST_RESULT:                    // There is only one result                    result.mTask.finish(result.mData[0]);  //18                    break;                case MESSAGE_POST_PROGRESS:                    result.mTask.onProgressUpdate(result.mData); //19                    break;            &#125;        &#125;    &#125;</code></pre><p>代码非常清晰，如果收到MESSAGE_POST_PROGRESS消息，在1.1小节注释2的地方发送，就执行注释19，又是我们熟悉的onProgressUpdate()，如果收到MESSAGE_POST_RESULT消息，就执行注释18的finish()。</p><pre><code class="java">private void finish(Result result) &#123;        if (isCancelled()) &#123;            onCancelled(result); //20        &#125; else &#123;            onPostExecute(result); //21        &#125;        mStatus = Status.FINISHED;    &#125;</code></pre><p>如果按2.2小节说的调用cancel(boolean)，则会回调注释20，否则执行注释21:onPostExecute(result)。</p><p>到此结束源码分析。相信文章开头4个问题大家都理解了。</p><h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（InternalHandler），其中线程池SerialExecutor用于任务的排队，而线程池THREAD_POOL_EXECUTOR用于真正地执行任务，InternalHandler用于将执行环境从线程池切换到主线程。</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AsyncTask全解析&quot;&gt;&lt;a href=&quot;#AsyncTask全解析&quot; class=&quot;headerlink&quot; title=&quot;AsyncTask全解析&quot;&gt;&lt;/a&gt;AsyncTask全解析&lt;/h1&gt;&lt;h1 id=&quot;1、AsyncTask介绍&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Context</title>
    <link href="http://example.com/2022/12/04/Android/Context/"/>
    <id>http://example.com/2022/12/04/Android/Context/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:06:31.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h1 id="1、-什么是Context，能干什么？"><a href="#1、-什么是Context，能干什么？" class="headerlink" title="1、 什么是Context，能干什么？"></a>1、 什么是Context，能干什么？</h1><p>Context直译过来是“语境”，“上下文”，“环境”的意思。以前在学习嵌入式Linux的时候，也经常说到进程上下文，中断上下文。而在“安卓上下文”中，我们需要先明白安卓的应用模型是基于组件的应用设计模式，比如Activity和Service这些组件在运行的时候，都需要一个完整的Android工程环境。那么在代码里，这个“环境”由谁提供？那自然就是Context类。 作为Android代码里出镜率最高的Context，除了负责四大组件的交互场景外，还有很多的场景都需要用到Context，如：</p><ul><li>获取系统属性，系统资源（color、string、drawable等）场景；</li><li>数据存储场景，如使用文件，SharedPreference，数据库的场景；</li></ul><p>我们来看看源码里Context类系列： <img src="https://uploadfiles.nowcoder.com/images/20221017/545613072_1665993762793/559BCCCDD472EBC68FA57DEA584F596D" alt="图片说明" title="图片标题">​</p><p>Context如下代码，本身是一个纯abstract类，那么自然有对应的实现子类：ContextImpl和ContextWrapper，其中ContextImpl是Context真正的实现类，ContextWrapper类则和其名字一样，只是一个封装类，并沒有真正的实现，真正的实现是其包含了一个mBase变量，是通过attachBaseContext() 方法来设置的，本质上是 ContextImpl对象。</p><pre><code class="java">public abstract class Context &#123;    /**     * File creation mode: the default mode, where the created file can only     * be accessed by the calling application (or all applications sharing the     * same user ID).     * @see #MODE_WORLD_READABLE     * @see #MODE_WORLD_WRITEABLE     */    public static final int MODE_PRIVATE = 0x0000;    ...    &#125;</code></pre><p>接着，ContextThemeWrapper又是继承于ContextWrapper，正如其名，ContextThemeWrapper相对于ContextWrapper多包含了与主题（Theme）相关的接口，这个主题就是AndroidManitest.xml里面application元素或者Activity元素通过android:theme指定的主题。如下面的theme，虽然在application元素里指定，但只在Activity界面才会使用到。</p><pre><code>&lt;application    android:name=&quot;.MyApplication&quot;    ...    android:theme=&quot;@style/Theme.XrTest&quot;&gt;</code></pre><p>正因为只有Activity需要指定主题，而Service和Application是不需要使用主题的。因此才有Actvity继承ContextThemeWrapper，而Service和Application直接继承ContextWrapper。Application、Activity、Service通过attach()调用父类ContextWrapper的attachBaseContext(), 从而设置父类成员变量 mBase 为 ContextImpl 对象。</p><h1 id="2、一个应用程序有几个Context？"><a href="#2、一个应用程序有几个Context？" class="headerlink" title="2、一个应用程序有几个Context？"></a>2、一个应用程序有几个Context？</h1><p>这个问题现在就很好回答了，一个Application的基础还是有安卓四大组件构成的，既：</p><blockquote><p>Application &#x3D; Activity + Service + Broadcast Receiver + Content Provider</p></blockquote><p>从第1节的图，我们知道Application和Activity和Service都继承与Context，而Broadcast Receiver和Content Provider虽然也需要context，但不是继承于Context，而是由外部传进入。因此一个应用的context个数就由其包含了多少个Activity和Service决定，并且最后再加上自己本身持有的context，即</p><blockquote><p>应用Context数量 &#x3D; Activity数 + Service数 + 1；</p></blockquote><h1 id="3、如何获取Context"><a href="#3、如何获取Context" class="headerlink" title="3、如何获取Context"></a>3、如何获取Context</h1><p>既然绝大多数场景都需要在安卓完整的工程环境实现，那么我们如何能获取到context呢？主要有以下方法：</p><ul><li>Activity.this：很多情况下要求传入context，此时发现我们可以直接传入activity本身，这是因为activity只是继承与context的；</li><li>getApplication()和getApplicationContext()：这个方法也很常见，因为应用本省就是一个context，所以获取应用实例即可。不过说明一下这两个方法返回的结果确实是同样的结果，但getApplication()是获取应用实例，只有在Activity和Service中可以调用，而getApplicationContext()含义是为了获取的是整个应用程序的工程环境，可以在Broadcast Receiver和Content Provider中调用；</li><li>view.getContext：每个view都需要在安卓的完整工程环境下才能正常显示，操作，因此每个view本身都持有context对象，这个context对象一般是该view所在的Activity实例；</li></ul><h1 id="4、Context的错误用法和正确使用方法"><a href="#4、Context的错误用法和正确使用方法" class="headerlink" title="4、Context的错误用法和正确使用方法"></a>4、Context的错误用法和正确使用方法</h1><h2 id="4-1-错误使用静态方法"><a href="#4-1-错误使用静态方法" class="headerlink" title="4.1 错误使用静态方法"></a>4.1 错误使用静态方法</h2><p>下面是一个非线程安全的单例模式，instance作为静态对象，生命周期会高于普通对象。因此如果传入某个应用的实例，会导致XuruiEnvelopeImpl一直持有XrActivity对象，当XrActivity被销毁时，因为它还有一个引用被别人持有，因此无法被垃圾回收机制回收，造成了内存泄露。</p><pre><code class="java">public class XuruiEnvelopeImpl &#123;    private static XuruiEnvelopeImpl instance;    private Context mContext;    private XuruiEnvelopeImpl(Context context) &#123;        this.mContext = context;    &#125;    public static XuruiEnvelopeImpl getInstance(Context context)&#123;        if(mEnvelopeImpl == null)&#123;            mEnvelopeImpl = new XuruiEnvelopeImpl(context);        &#125;        return mEnvelopeImpl;    &#125;&#125;//使用XuruiEnvelopeImpl.getInstance(XrActivity.this)；</code></pre><h2 id="4-2-错误使用静态View对象"><a href="#4-2-错误使用静态View对象" class="headerlink" title="4.2 错误使用静态View对象"></a>4.2 错误使用静态View对象</h2><pre><code class="java">public class MainActivity extends Activity &#123;    private static Drawable mDrawable; //1    @Override    protected void onCreate(Bundle saveInstanceState) &#123;        super.onCreate(saveInstanceState);        setContentView(R.layout.activity_main);        ImageView iv = new ImageView(this);        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);        iv.setImageDrawable(mDrawable); //2    &#125;&#125;</code></pre><p>注释1定义了一个静态的mDrawable，在注释2传入非静态ImageView对象里，第3节有说过，一个view对象都会持有所在的activity的引用，因此静态的mDrawable会一直持有非静态ImageView对象所在的activity引用，该引用跟着静态的mDrawable会一直保存在内存，因此导致activity销毁时，垃圾回收机制发现该activity还有一个引用被别人持有，将无法进行垃圾回收，造成内存泄露。</p><h2 id="4-3-如何正确使用Context"><a href="#4-3-如何正确使用Context" class="headerlink" title="4.3 如何正确使用Context"></a>4.3 如何正确使用Context</h2><ul><li>因为Application和activity都有context对象，如果可以使用Application的context则优先使用；</li><li>注意别让生命周期可能长于actvity的对象持有activity的引用；</li><li>尽量避免在activity里使用非静态内部类，这一点在Handler那一节就着重说明了，因为非静态内部类会持有外部类的引用。推荐使用静态内部类，并将外部类的引用改为弱引用。</li></ul><p>PS：什么情况必须用Activity的Context呢？</p><p>答：启动新的Activity或者弹出一个Dialog，只能用Activity的Context，不能用Application的Context，因为启动Activity需要任务栈，而非Activity的Context是没有的。同时，Dialog必须基于Activity上弹出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Context&quot;&gt;&lt;a href=&quot;#Context&quot; class=&quot;headerlink&quot; title=&quot;Context&quot;&gt;&lt;/a&gt;Context&lt;/h1&gt;&lt;h1 id=&quot;1、-什么是Context，能干什么？&quot;&gt;&lt;a href=&quot;#1、-什么是Context，</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Fragment全解析</title>
    <link href="http://example.com/2022/12/04/Android/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2022/12/04/Android/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:06:43.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fragment全解析"><a href="#Fragment全解析" class="headerlink" title="Fragment全解析"></a>Fragment全解析</h1><p>‍</p><h1 id="1、什么是Fragment"><a href="#1、什么是Fragment" class="headerlink" title="1、什么是Fragment"></a>1、什么是Fragment</h1><p>刚开始学习Activity的时候，一个界面就是一个Activity。那么，如果想在一个Activity界面上镶嵌另一个界面如何做呢？Fragment翻译为“片段，破片”，可以理解为“显示在Activity中的Activity”，为解决Android碎片化而生。Fragment可以作为一个Activity界面中独立的子界面，拥有自己的生命周期，也可以接受用户的触摸事件。我们可以在一个Activity界面上添加多个Fragment子界面，并且每个Fragment都可以动态的添加、删除、替换，从而使得安卓界面开发具有更强大的灵活性。</p><p>比如微信首页有“微信”、“通讯录”、“发现”、“我”，这4个子界面就是4个Fragment。我们在设计Fragment的时候，需要考虑模块化和可复用化。最后，总结一下使用Fragment的优势：</p><ul><li>可以把一个Activity分为多个可复用的组件，使得UI开发更加有灵活性，之前一个Activity如果需要多个布局的话，就需要设置多个布局文件，又麻烦，性能也不高；</li><li>每个Fragment都是独立的个体，可以动态的添加、删除、替换等，同时也可以同一个Fragment供多个Activity使用；</li><li>与Activity切换相比，Fragment属于轻量切换，Fragment的出现，解决了Activity之间切换不流畅的问题；</li><li>与View相比，View也可以实现在一个Activity上部署几个子界面，但View不能通过startActivityForResult()方法（现在建议使用：registerForActivityResult()方法）接收到返回结果，而且View通常更关注视图的实现；</li></ul><h1 id="2、Fragment的生命周期"><a href="#2、Fragment的生命周期" class="headerlink" title="2、Fragment的生命周期"></a>2、Fragment的生命周期</h1><p>Fragment的生命周期是Fragment面试题里最常问的，就是和Activity生命周期的比较，同时学习Fragment的生命周期最好也是结合Activity的生命周期来学习，因为Fragment是依附于Activity存在的，所以它的生命周期也受到Activity的生命周期影响。下图是网上找到的一张非常全面的图。</p><p>​<img src="https://uploadfiles.nowcoder.com/images/20231120/545613072_1700451268450/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><p>结合我们熟悉的Activity生命周期来学习：</p><ul><li><p>Activity::onCreate()</p><ul><li><strong>Fragment::onAttach()</strong></li><li>*Fragment::onCreate()</li><li>*<strong>Fragment::onCreateView()</strong></li><li>*<strong>Fragment::onActivityCreated()</strong></li></ul></li><li><p>Activity::onStart()</p><ul><li>*Fragment::onStart()</li></ul></li><li><p>Activity::onResume()</p><ul><li>*Fragment::onResume()</li></ul></li><li><p>Activity::onPause()</p><ul><li>*Fragment::onPause()</li></ul></li><li><p>Activity::onStop()</p><ul><li>*Fragment::onStop()</li></ul></li><li><p>Activity::onDestroy()</p><ul><li>*<strong>Fragment::onDestroyView()</strong></li><li>*Fragment::onDestroy()</li><li>*<strong>Fragment::onDetach()</strong></li></ul></li></ul><p>Activity一般有创建-开始-继续-暂停-停止-销毁共六大阶段，Fragment同样也经历了这六大阶段。从上面可以看到最大的差别在于创建-销毁这两个阶段，多出了以下5个方法(上面加粗的5个方法)：</p><ol><li>onAttach(Activity)：当Fragment与Activity发生关联时调用，即将Fragment绑定到Activity时，并且在这个方法可以通过getArguments()方法获取传入该Fragment的参数；</li><li>onCreateView(LayoutInflater, ViewGroup, Bundle)：创建该Fragment的视图时调用；</li><li>onActivityCreated(Bundle)：当Activity的onCreated()方法返回时调用；</li><li>onDestroyView()：对应onCreateView()方法，当该Fragment的视图被移除时调用；</li><li>onDetach()：对应onAttach()方法，当Fragment与Activity取消关联时调用；</li></ol><p><strong>注</strong>：</p><ul><li>除了onCreateView()，如果重写了其他的方法，则必须调用父类对于该方法的实现；</li><li>Activity每一个生命周期都会引发Fragment调用同样的回调，如Activity收到onStop()后，里面的每个Fragment都会收到onStop()，同理，Fragment的onResume()也是在Activity的onResume()之后调用。但是onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在Activity的onStart()中调用的;</li></ul><h1 id="3、Fragment的使用方式"><a href="#3、Fragment的使用方式" class="headerlink" title="3、Fragment的使用方式"></a>3、Fragment的使用方式</h1><p>Fragment的使用方式包括静态使用和动态使用。其中，静态是直接在xml布局文件中声明Fragment，动态则是使用代码来动态实现。</p><h2 id="3-1-静态使用"><a href="#3-1-静态使用" class="headerlink" title="3.1 静态使用"></a>3.1 静态使用</h2><p>步骤：</p><ul><li>创建一个继承Fragment的自定义XrFragment类，重新onCreateView()方法，在该方法中设置对应的xml布局文件；</li></ul><pre><code class="java">public class XrFragment extends Fragment &#123;    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        /*        * 参数1：布局xml文件的ID        * 参数2：容器，被inflate的布局的父ViewGroup        * 参数3：是否将这个生成的View添加到这个容器中去        * 作用是将布局文件封装在一个View对象中，并填充到此Fragment中        * */        View v = inflater.inflate(R.layout.xr_fragment, container, false);        return v;    &#125;&#125;</code></pre><ul><li>在Activity的布局文件直接声明该自定义XrFragment类即可。</li></ul><pre><code class="java">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;      &lt;fragment        android:id=&quot;@+id/xr_fragment&quot;  // 在这里声明        android:name=&quot;com.example.XrFragment&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="3-2-动态使用"><a href="#3-2-动态使用" class="headerlink" title="3.2 动态使用"></a>3.2 动态使用</h2><p>一个Activity可以有多个Fragment，如果我们需要设置两个按键，按下按键可以打开对应的Fragment可以这么做：</p><pre><code class="java">// 先创建两个自定义Fragment类public class XrFragment1 extends Fragment &#123;    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        View v = inflater.inflate(R.layout.xr_fragment_1, container, false);        return v;    &#125;&#125;public class XrFragment2 extends Fragment &#123;    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        View v = inflater.inflate(R.layout.xr_fragment_2, container, false);        return v;    &#125;&#125;</code></pre><p>接着在Activity中将上述两个自定义Fragment绑定两个按键即可：</p><pre><code class="java">public class XuruiActivity extends AppCompatActivity &#123;    private Button bt_1;    private Button bt_2;    private FragmentManager manager;    private XrFragment1 fragment1;    private XrFragment2 fragment2;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        bt_1 = (Button) findViewById(R.id.bt_1);        bt_2 = (Button) findViewById(R.id.bt_2);        fragment1 = new XrFragment1();        fragment2 = new XrFragment2();        //1：初始化FragmentManager对象        manager = getSupportFragmentManager();        //2：使用FragmentManager对象用来开启一个Fragment事务        FragmentTransaction transaction = manager.beginTransaction();        //3：默认显示fragment1        transaction.add(R.id.myframelayout, fragment1).commit();        //对bt_1设置监听        bt_1.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                FragmentTransaction transaction = manager.beginTransaction();                transaction.replace(R.id.myframelayout, fragment1).commit(); // 4            &#125;        &#125;);        //对bt_2设置监听        bt_2.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                FragmentTransaction transaction = manager.beginTransaction();                transaction.replace(R.id.myframelayout, fragment2).commit();            &#125;        &#125;);    &#125;&#125;</code></pre><p>R.id.myframelayout就是一个FrameLayout，作为Fragment的容器，上述自定义的Fragment可通过该myframelayout在Activity中显示。为了更好的管理多个Fragment，可以通过[注释1]获取Fragment管理对象，在[注释2]使用FragmentManager对象用来开启一个FragmentTransaction（事务），FragmentTransaction常用的方法有：</p><ul><li>add()：向Activity中添加一个Fragment</li><li>remove()： 从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈（回退栈见下文），这个Fragment实例将会被销毁</li><li>replace()：使用新的Fragment替换当前的的Fragment，其实就是remove()和add()的结合</li><li>hide()： 隐藏当前的Fragment，但不会销毁</li><li>show()：显示之前隐藏的Fragment</li><li>detach()：会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护</li><li>attach()：重建view视图，附加到UI上并显示</li><li>ransatcion.commit()：提交事务，上述add&#x2F;replace&#x2F;hide&#x2F;show方法都需要执行commit()后才生效</li></ul><blockquote><p>通常情况下，建议使用show()和hide()，避免Fragment重复加载。</p></blockquote><h2 id="3-3-getFragmentManager-getSupportFragmentManager-getChildFragmentManager之间的区别？"><a href="#3-3-getFragmentManager-getSupportFragmentManager-getChildFragmentManager之间的区别？" class="headerlink" title="3.3 getFragmentManager,getSupportFragmentManager,getChildFragmentManager之间的区别？"></a>3.3 getFragmentManager,getSupportFragmentManager,getChildFragmentManager之间的区别？</h2><p>为了管理Fragment，需要获取Fragment管理对象：FragmentManager，其中：</p><ul><li>getFragmentManager()：Activity可以通过该方法获取Activity类里面的Fragment管理器，Fragment里不能用；</li><li>getSupportFragmentManager()：Activity可以通过该方法获取FragmentActivity类里面的Fragment管理器，用于管理这个Activity里面的所有一级Fragment。和getFragmentManager()作用确实是一样的作用，因为，Android3.0版本之前是没有Fragment这个概念，因此3.0版本以前的不可以直接调用 getFragmentManager()，因此3.0版本以前的可以调用getSupportFragmentManager()间接获取FragmentManager。而3.0以后的版本则两个方法任选一个即可，所以建议都调用getSupportFragmentManager()。同时，getSupportFragmentManager()还可以在Fragment中使用，但在Fragment中使用时，是获取的父类Fragment的FragmentManager，如果没有父类，则获取该Fragment所属Activity的FragmentManager；</li><li>getChildFragmentManager()：如果在Fragment里面还需要继续嵌套Fragment，则需要通过该方法在Fragment里面获取FragmentManager</li></ul><pre><code class="java">Fragment1 fragment1 = new Fragment1();FragmentManager fragmentManager = fragment1.getChildFragmentManager(); val Fragment2 fragment2 = new Fragment2();                        fragmentManager.beginTransaction().add(R.id.my_framelayout, fragment2, &quot;newFragment2&quot;).commit()</code></pre><h1 id="4、通讯"><a href="#4、通讯" class="headerlink" title="4、通讯"></a>4、通讯</h1><h2 id="4-1-Fragment和Actvity的通讯"><a href="#4-1-Fragment和Actvity的通讯" class="headerlink" title="4.1 Fragment和Actvity的通讯"></a>4.1 Fragment和Actvity的通讯</h2><p>Fragment依附于Activity，两者的通讯可以有以下方式：</p><ul><li>在Activity有对应的Fragment的引用，则直接通过该引用就可以访问Fragment里面的public方法，如果没有Fragment引用，则可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例对其进行操作，因为每个Fragment都有唯一的ID（比如用android:id属性或者android:tag属性提供唯一标识）；</li><li>在Fragment里可以通过getActivity()来获取当前绑定的Activity的实例，并对其进行操作；</li><li>接口方式：Activity里继承一个接口，并在Fragment里实现；</li><li>广播&#x2F;文件：这是通用的Android跨进程通讯方式，用于Fragment和Activity通讯自然可以；</li><li>Bundle：在Activity中建一个Bundle，将需要传的值存入Bundle，并通过Fragment的setArguments（bundle）传到Fragment，最后在Fragment中，用getArguments()接收。</li><li>registerForActivityResult():可以在Fragment里调用registerForActivityResult()来启动另一个Activity，并返回一些数据回来Fragment。比如在myFragment启动编辑名字的Actvity，编辑完成后把编辑完的名字返回给myFragment：</li></ul><pre><code class="kotlin">//EditNameActivityval intent = Intent()intent.putExtra(myData.EDIT_NAME, name.text.toString()) //传入修改后的名字setResult(Activity.RESULT_OK, intent)finish()//myFragmentprivate val startEditNameActivityLauncher: ActivityResultLauncher&lt;Intent&gt; =    registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123;        if (it.resultCode == Activity.RESULT_OK) &#123;            val editName = it.data?.getStringExtra(myData.EDIT_NAME) //获取EditNameActivity返回的姓名            if (!editName.isNullOrEmpty()) &#123;                myViewModel.setUserName(editName)            &#125;        &#125;        &#125;  startEditNameActivityLauncher.launch(Intent(requireContext(),EditNameActivity::class.java))</code></pre><h2 id="4-2-Fragment和Fragment的通讯"><a href="#4-2-Fragment和Fragment的通讯" class="headerlink" title="4.2 Fragment和Fragment的通讯"></a>4.2 Fragment和Fragment的通讯</h2><p>首先，不建议Fragment之间直接通讯，最好是借助Activity为中介。那么，如果一定要在Fragment1打开Fragment2后，从Fragment2返回一些数据回去Fragment1要怎么做呢？ 只要在Fragment1打开Fragment2的时候，多执行一句：</p><blockquote><p>fragment2.setTargetFragment(Fragment1.this, REQUEST_CODE);</p></blockquote><p>然后在Fragment1类里面实现：</p><pre><code class="java">@Override     public void onActivityResult(int requestCode, int resultCode, Intent data) &#123;         super.onActivityResult(requestCode, resultCode, data);         if(resultCode != Activity.RESULT_OK)&#123;             return;         &#125;else&#123;             int rlt = data.getIntExtra(&quot;xr&quot;,0);   //获取数据           //处理数据...       &#125;     &#125;</code></pre><p>接着，进入Fragment2的代码，直接调用以下代码即可：</p><pre><code>Intent intent = new Intent();  intent.putExtra(&quot;xr&quot;, 100);  getTargetFragment().onActivityResult(Fragment1.REQUEST_CODE,resultOk,intent);     </code></pre><h1 id="5、Fragment的回退栈"><a href="#5、Fragment的回退栈" class="headerlink" title="5、Fragment的回退栈"></a>5、Fragment的回退栈</h1><p>Activity有任务栈，Fragment也有回退栈（Back Stack）。比如现在ActivityA先后启动了FragmentA、FragmentB，此时在FragmentB按后退键，会直接退回桌面。如果我们希望能退到FragmentA的话，需要执行</p><blockquote><p>addToBackStack(String tag)：标记本次的回滚操作</p></blockquote><pre><code class="java"> Fragment newFragment = new FragmentA(); FragmentTransaction transaction = getFragmentManager().beginTransaction();  transaction.replace(R.id.Fragment_container, newFragment); transaction.addToBackStack(null); transaction.commit();</code></pre><p>此时，在FragmentB按下后退键，就会跳回FragmentA，再按后退键才最后退回桌面。更进一步，如果回退栈里有4个Fragment：Fragment1到Fragment4，如果想在Fragment4的界面按后退键直接回到Fragment1，可以执行：</p><ul><li>popBackStack(int id, int flags)：其中id表示提交变更时commit()的返回值。</li><li>popBackStack(String name, int flags)：其中name是addToBackStack(String tag)中的tag值</li></ul><p>通过上面两个方法就可以指定回到某个特定的Fragment，并且根据第二个参数flags的不同，有两种情况：</p><ul><li>0：表示除了指定的Fragment所在的这一层之上的所有层都退出栈；</li><li>FragmentManager.POP_BACK_STACK_INCLUSIVE（inclusive）：表示连同指定Fragment所在层以及之上的所有层都一起退出。</li></ul><p>同样的，如果现在ActivityA先后启动了FragmentA、FragmentB，FragmentC，此时在FragmentC需要直接返回到Activity界面可以执行：</p><blockquote><p>getActivity().getSupportFragmentManager().popBackStack(null, FragmentManager.POP_BACK_STACK_INCLUSIVE);</p></blockquote><p>使用POP_BACK_STACK_INCLUSIVE参数是为了确保返回栈中的所有Fragment都被弹出，而不仅仅是单一地把FragmentC弹出。如果不使用该参数，则只会弹出FragmentC，而保留其他Fragment在返回栈中。</p><h1 id="6、Fragment状态保存"><a href="#6、Fragment状态保存" class="headerlink" title="6、Fragment状态保存"></a>6、Fragment状态保存</h1><p>Fragment状态保存入口:</p><p>1、Activity的状态保存, 在Activity的onSaveInstanceState()里, 调用了FragmentManger的saveAllState()方法, 其中会对mActive中各个Fragment的实例状态和View状态分别进行保存.</p><p>2、FragmentManager还提供了public方法: saveFragmentInstanceState(), 可以对单个Fragment进行状态保存, 这是提供给我们用的。</p><p>3、FragmentManager的moveToState()方法中, 当状态回退到ACTIVITY_CREATED, 会调用saveFragmentViewState()方法, 保存View的状态.</p><h1 id="7、你有遇到过哪些关于Fragment的问题，如何处理的？"><a href="#7、你有遇到过哪些关于Fragment的问题，如何处理的？" class="headerlink" title="7、你有遇到过哪些关于Fragment的问题，如何处理的？"></a>7、你有遇到过哪些关于Fragment的问题，如何处理的？</h1><h2 id="7-1-getActivity-空指针："><a href="#7-1-getActivity-空指针：" class="headerlink" title="7.1 getActivity()空指针："></a>7.1 getActivity()空指针：</h2><p>这种情况一般发生在在异步任务里调用getActivity()，此时宿主Activity可能已经销毁了，因此引发空指针问题。最简单的方法就是在引用getActivity()时做个判空判断，同时可以根据情况考虑用获取Context来代替Activity，建议在onAttach()方法中将Context强制转为Activity这种方式来代替直接调用getActivity()。反正不要把Fragment事务放在异步线程的回调中或者AsyncTask的onPostExecute()。</p><h2 id="7-2-Fragment视图重叠"><a href="#7-2-Fragment视图重叠" class="headerlink" title="7.2 Fragment视图重叠"></a>7.2 Fragment视图重叠</h2><p>如果我们在onCreate()方法加载Fragment时，特别是当Activity重建的时候，没有判断saveInstanceState&#x3D;&#x3D;null或if(findFragmentByTag(mFragmentTag) &#x3D;&#x3D; null)，就直接加载布局，可能会导致重复加载了同一个Fragment布局，因此建议加上判断。</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Fragment全解析&quot;&gt;&lt;a href=&quot;#Fragment全解析&quot; class=&quot;headerlink&quot; title=&quot;Fragment全解析&quot;&gt;&lt;/a&gt;Fragment全解析&lt;/h1&gt;&lt;p&gt;‍&lt;/p&gt;
&lt;h1 id=&quot;1、什么是Fragment&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>HandlerThread</title>
    <link href="http://example.com/2022/12/04/Android/HandlerThread/"/>
    <id>http://example.com/2022/12/04/Android/HandlerThread/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:06:59.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h1><h1 id="1、HandlerThread是什么？"><a href="#1、HandlerThread是什么？" class="headerlink" title="1、HandlerThread是什么？"></a>1、HandlerThread是什么？</h1><p>在安卓开发中，如果需要执行耗时操作，则可以开启子线程来完成，然而手动创建销毁线程又麻烦又消耗系统性能，因此可以使用<strong>线程池</strong>来完成。如果还需要在线程中使用Handler异步消息机制，或者需要实现子线程和子线程之间的通讯（Handler是主线程和子线程之间的通讯），那么就可以用<strong>HandlerThreaad</strong>。</p><p>HandlerThread是Google封装好的一个类，它的内部有自己的Looper对象，可以进行Loop轮询，用于执行多个耗时操作，而不需要多次开启线程，本质是使用Handler和Looper实现的。</p><h1 id="2、HandlerThread怎么使用"><a href="#2、HandlerThread怎么使用" class="headerlink" title="2、HandlerThread怎么使用"></a>2、HandlerThread怎么使用</h1><p>如果我们需要使用HandlerThread来读取一个大文件的内容，可以这么写：</p><pre><code class="java">public class Xuruictivity extends AppCompatActivity &#123;    private static final int MSG_READ_INFO = 100;    Handler mMainHandler = new Handler();    private Handler mThreadHandler;    private HandlerThread mHandlerThread;    private boolean isFinish = false;     @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_xurui);        initHandlerThread(); //1        startHandlerThread();     &#125;    private void initHandlerThread() &#123;        mHandlerThread = new HandlerThread(&quot;Xurui&quot;); //2        mHandlerThread.start(); //3         mThreadHandler = new Handler(mHandlerThread.getLooper()) &#123; //4            @Override            public void handleMessage(Message msg) &#123;                switch (msg.what) &#123;                    case MSG_READ_INFO: &#123;                        readFileInfo();                        // 如果没有读完，则继续                        if (!isFinish) &#123;                            mThreadHandler.sendEmptyMessage(MSG_READ_INFO);                        &#125;                    &#125;                    break;                    default:                        break;                &#125;                        &#125;        &#125;;    &#125;    /**     * 模拟读取文件     */    private void readFileInfo() &#123;        try &#123;            //模拟耗时            Thread.sleep(1200);            mMainHandler.post(new Runnable() &#123;                @Override                public void run() &#123;                    // 读取大文件内容                &#125;            &#125;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;      private void startHandlerThread() &#123;       mThreadHandler.sendEmptyMessage(MSG_READ_INFO);    &#125;    @Override    protected void onPause() &#123;        super.onPause();        mThreadHandler.removeMessages(MSG_READ_INFO); //5    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        mHandlerThread.quit();//6        mMainHandler.removeCallbacksAndMessages(null); //7    &#125;&#125;</code></pre><p>使用mHandlerThread的looper创建的mThreadHandler，对应注释4，里面的handleMessage是可以进行耗时操作的，因为它是执行在mHandlerThread所在的子线程。因此其优点是不会阻塞主线程，但是多任务时也需要有序执行，导致执行效率低。因此HandlerThread比较适合耗时不且不会产生较大的阻塞，比如读取文件，操作数据库等，至于网络IO操作这种可能有较大阻塞等，HandlerThread并不适合。</p><p>上面代码最关键的步骤都在注释1的函数里。我们来看看HandlerThread的使用方法：</p><ol><li>创建HandlerThread实例：对应注释2，其中“xurui”是子线程的名字，可以随意取；</li><li>执行start函数来启动HandlerThread线程：对应注释3；</li><li>将HandlerThread和Handler绑定：对应注释4；</li><li>然后执行startHandlerThread()就行了，最后记得退出HandlerThread，对应注释6。</li></ol><p>为何是这样的步骤，那就进入激动人心的源码分析吧！</p><h1 id="3、源码分析"><a href="#3、源码分析" class="headerlink" title="3、源码分析"></a>3、源码分析</h1><p>HandlerThread的源码仅仅100+行，因此直接copy完整的源码，不做任何删减（下面源码是android9.0.0的源码）。</p><pre><code class="java">public class HandlerThread extends Thread &#123;     int mPriority;     int mTid = -1;     Looper mLooper;     private @Nullable Handler mHandler;       public HandlerThread(String name) &#123; //1         super(name);         mPriority = Process.THREAD_PRIORITY_DEFAULT;     &#125;       /**      * Constructs a HandlerThread.      * @param name      * @param priority The priority to run the thread at. The value supplied must be from      * &#123;@link android.os.Process&#125; and not from java.lang.Thread.      */     public HandlerThread(String name, int priority) &#123; //2         super(name);         mPriority = priority;     &#125;       /**      * Call back method that can be explicitly overridden if needed to execute some      * setup before Looper loops.      */     protected void onLooperPrepared() &#123;     &#125;       @Override     public void run() &#123;         mTid = Process.myTid();         Looper.prepare(); //3         synchronized (this) &#123;             mLooper = Looper.myLooper();             notifyAll(); //4          &#125;         Process.setThreadPriority(mPriority);         onLooperPrepared();         Looper.loop(); //5         mTid = -1;     &#125;       /**      * This method returns the Looper associated with this thread. If this thread not been started      * or for any reason isAlive() returns false, this method will return null. If this thread      * has been started, this method will block until the looper has been initialized.      * @return The looper.      */     public Looper getLooper() &#123; //6         if (!isAlive()) &#123;             return null;         &#125;           // If the thread has been started, wait until the looper has been created.         synchronized (this) &#123;             while (isAlive() &amp;&amp; mLooper == null) &#123;                 try &#123;                     wait(); //7                 &#125; catch (InterruptedException e) &#123;                 &#125;             &#125;         &#125;         return mLooper;     &#125;       /**      * @return a shared &#123;@link Handler&#125; associated with this thread      * @hide      */     @NonNull     public Handler getThreadHandler() &#123;         if (mHandler == null) &#123;             mHandler = new Handler(getLooper());          &#125;          return mHandler;      &#125;        /**       * Quits the handler thread&#39;s looper.       * &lt;p&gt;       * Causes the handler thread&#39;s looper to terminate without processing any       * more messages in the message queue.       * &lt;/p&gt;&lt;p&gt;       * Any attempt to post messages to the queue after the looper is asked to quit will fail.       * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false.       * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt;       * Using this method may be unsafe because some messages may not be delivered       * before the looper terminates.  Consider using &#123;@link #quitSafely&#125; instead to ensure       * that all pending work is completed in an orderly manner.       * &lt;/p&gt;       *       * @return True if the looper looper has been asked to quit or false if the       * thread had not yet started running.       *       * @see #quitSafely       */      public boolean quit() &#123;          Looper looper = getLooper();          if (looper != null) &#123;              looper.quit();              return true;          &#125;          return false;      &#125;        /**       * Quits the handler thread&#39;s looper safely.       * &lt;p&gt;       * Causes the handler thread&#39;s looper to terminate as soon as all remaining messages       * in the message queue that are already due to be delivered have been handled.       * Pending delayed messages with due times in the future will not be delivered.       * &lt;/p&gt;&lt;p&gt;       * Any attempt to post messages to the queue after the looper is asked to quit will fail.       * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false.       * &lt;/p&gt;&lt;p&gt;       * If the thread has not been started or has finished (that is if       * &#123;@link #getLooper&#125; returns null), then false is returned.       * Otherwise the looper is asked to quit and true is returned.       * &lt;/p&gt;       *       * @return True if the looper looper has been asked to quit or false if the       * thread had not yet started running.       */      public boolean quitSafely() &#123;          Looper looper = getLooper();          if (looper != null) &#123;              looper.quitSafely();              return true;          &#125;          return false;      &#125;        /**       * Returns the identifier of this thread. See Process.myTid().       */      public int getThreadId() &#123;          return mTid;      &#125;&#125;  </code></pre><ol><li>构造方法</li></ol><p>关键看看注释2的构造函数，其中name是该线程的名字，priority是线程的优先级，在此默认是THREAD_PRIORITY_DEFAULT，这些宏是在 Process 中定义的，值越小，进程优先级越高，主线程的优先级也是THREAD_PRIORITY_DEFAULT。</p><ol start="2"><li>run方法</li></ol><p>在该方法里，执行了很经典的函数，也就是注释3的 Looper.prepare()，详情见本系列Handler小节，该方法主要是创建Looper实例，只有创建了Looper实例，才能将HandlerThread和handler绑定在一起。因此需要先执行start（）函数，执行后，线程会交给虚拟机进行调度并自动调用run（）方法。</p><p>注释5相信看过Handler小节的同学也很清楚了，看看注释4，为何这里会有notifyAll()方法呢？而且还使用了synchronized。</p><ol start="3"><li>HandlerThread和handler绑定</li></ol><p>这里关键是看看getLooper()函数，对应注释6，这里也有synchronized，同时还有wait()方法，众所周知，wait()和notifyAll()是搭配使用来实现线程同步的。这里为了获取到mLooper对象，需要进行线程同步。因为我们希望getLooper()函数只有在线程创建成功且Looper实例也创建成功时才返回，因此在注释7开始阻塞，直到注释4已经创建完Looper实例时才唤醒。</p><ol start="4"><li>quit和quitSafe方法</li></ol><p>最后看看如何退出线程。当调用quit和quitSafe方法就可以退出Looper消息循环并退出线程，从名字上就可以知道后者是“安全退出“。</p><p>跟踪这两个方法，会跑到MessageQueue.java里的：</p><pre><code class="java">void quit(boolean safe) &#123;     if (!mQuitAllowed) &#123;         throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);     &#125;     synchronized (this) &#123;         if (mQuitting) &#123;             return;         &#125;         mQuitting = true;         if (safe) &#123;             removeAllFutureMessagesLocked(); //8         &#125; else &#123;             removeAllMessagesLocked(); //9         &#125;         // We can assume mPtr != 0 because mQuitting was previously false.         nativeWake(mPtr);     &#125; &#125;</code></pre><p>如果安全则调用注释8，不安全调用注释9.继续看源码。removeAllMessagesLocked()只是遍历链表并把所有消息移除掉，最后将mMessages设置为null。而removeAllFutureMessagesLocked()会根据when变量，对应下面注释10，如果当前没有处理消息则同样移除所有消息，否则等待消息处理完毕后再退出循环。</p><p>因此这里所谓的安全或者不安全是因为quit()方法无论当前是否有处理消息，都强制移除所有回调，所以不安全。</p><pre><code class="java">private void removeAllMessagesLocked() &#123;    Message p = mMessages;    while (p != null) &#123;        Message n = p.next;        p.recycleUnchecked();        p = n;    &#125;    mMessages = null;&#125;private void removeAllFutureMessagesLocked() &#123;    final long now = SystemClock.uptimeMillis();    Message p = mMessages;    if (p != null) &#123;        if (p.when &gt; now) &#123; //10            removeAllMessagesLocked();        &#125; else &#123;            Message n;            for (;;) &#123;                n = p.next;                if (n == null) &#123;                    return;                &#125;                if (n.when &gt; now) &#123;                    break;                &#125;                p = n;            &#125;            p.next = null;            do &#123;                p = n;                n = p.next;                p.recycleUnchecked();            &#125; while (n != null);        &#125;    &#125;&#125;</code></pre><h1 id="4、-总结"><a href="#4、-总结" class="headerlink" title="4、 总结"></a>4、 总结</h1><p>最后做个总结：</p><ol><li>HandlerThread 是内部会创建Looper的线程，因此只能作为子线程使用；</li><li>HandlerThread 需要配合 Handler 使用，HandlerThread 的耗时操作在handleMessage()中执行，因为此时执行的是在HandlerThread所在的子线程执行的，但不能像普通线程一样在run()方法中进行，因为HanderThread的run()方法已经被写死。</li><li>HandlerThread和Handler绑定之前，必须先调用 mHandlerThread.start() 让 run() 方法跑起来.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HandlerThread&quot;&gt;&lt;a href=&quot;#HandlerThread&quot; class=&quot;headerlink&quot; title=&quot;HandlerThread&quot;&gt;&lt;/a&gt;HandlerThread&lt;/h1&gt;&lt;h1 id=&quot;1、HandlerThread是什么？&quot;&gt;</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Intent</title>
    <link href="http://example.com/2022/12/04/Android/Intent/"/>
    <id>http://example.com/2022/12/04/Android/Intent/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:07:11.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h1><h1 id="1、什么是Intent"><a href="#1、什么是Intent" class="headerlink" title="1、什么是Intent"></a>1、什么是Intent</h1><p>Intent，中文可翻译为“意图”，可用于Android同个应用程序中各个组件之间的交互，或者不同应用程序之间的交互。可以用来表明当前组件的思想和意图，比如想执行某个动作，想发送某些数据等等。每个组件都有不同的启动方法：</p><ul><li>Activity：可以调用startActivity() 或 startActivityForResult() 传递 Intent来打开新的Activity；</li><li>Service：可以调用startService()传递 Intent 来启动服务，也可通过 bindService() 传递 Intent 来绑定到该服务；</li><li>Broadcast，可以调用sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast() 等方法传递 Intent 来发起广播；</li></ul><p>Intent分为显式Intent和隐式Intent，我们以打开新的Activity为例进行讲解。</p><h2 id="1-1-显示Intent"><a href="#1-1-显示Intent" class="headerlink" title="1.1 显示Intent"></a>1.1 显示Intent</h2><p>显式指定意图，系统就会根据我们指定的意图，打开我们想打开的Activity。Intent有如下构造函数：Intent(Context packageContext, Class&lt;?&gt; cls)。其中第二个参数就是指定想启动的Activity。</p><pre><code class="java">Intent intent = new Intent(this, SecondActivity.class);  startActivity(intent); </code></pre><p>通过上面两行代码，我们可以显式指定打开SecondActivity.class。</p><h2 id="1-2-隐式Intent"><a href="#1-2-隐式Intent" class="headerlink" title="1.2 隐式Intent"></a>1.2 隐式Intent</h2><p>不指定特定的意图，而是通过清单文件里，每个Activity节点下事先配置好的（也就是“Intent过滤器”），由系统根据我们设定的Intent，从系统所有Activity中选出最符合的我们要求的Activity。先看看例子：</p><pre><code class="java">// 清单文件中 XuruiActivity 提前声明好如下：    &lt;activity android:name=&quot;.XuruiActivity&quot;&gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;com.example.android.xuruitest&quot;/&gt;            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;            &lt;category android:name=&quot;com.example.android.xuruicategory&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;</code></pre><pre><code class="java">// 代码调用    Intent intent = new Intent();    intent.setAction(com.example.android.xuruitest);    intent.addCategory(com.example.android.xuruicategory);    startActivity(intent); //1</code></pre><p>执行 [注释1]的代码后，系统会发现XuruiActivity的所设定的内容，和当前Intent所设定的内容最匹配，系统就会打开XuruiActivity，但这个过程中，我们并没有显式的指出打开XuruiActivity，而是通过设置了一些特定条件进行匹配，如“action”，“category”等，从而隐式地打开了XuruiActivity。</p><h2 id="1-3-Intent的组成部分"><a href="#1-3-Intent的组成部分" class="headerlink" title="1.3 Intent的组成部分"></a>1.3 Intent的组成部分</h2><p>“action”，“category”都是Intent的组成部分。为了更好的理解隐式Intent，需要了解一个Intent由几部分组成：</p><ul><li>componentName：目的组件</li><li>action（动作）：用来表现意图的行动</li><li>category（类别）：用来表现动作的类别</li><li>data（数据）：表示与动作要操纵的数据</li><li>type（数据类型）：对于data范例的描写</li><li>extras（扩展信息）：扩展信息</li><li>Flags（标志位）：期望这个意图的运行模式</li></ul><h3 id="1-3-1-componentName"><a href="#1-3-1-componentName" class="headerlink" title="1.3.1 componentName"></a>1.3.1 componentName</h3><p>指定Intent目标组件的类名。可以这么记得，如果直接指定了componentName，那就是显式Intent。我们可以通过setComponent()、setClass()、setClassName()等方法指定：</p><pre><code class="java">// 1、Intent构造Intent intent = new Intent(this, SecondActivity.class);  startActivity(intent); // 2、setComponent()方法ComponentName componentName = new ComponentName(this, SecondActivity.class);  //2ComponentName componentName = new ComponentName(this, &quot;com.example.android.SecondActivity&quot;);  //3 ComponentName componentName = new ComponentName(this.getPackageName(), &quot;com.example.android.SecondActivity&quot;);  //4   Intent intent = new Intent();  intent.setComponent(componentName);  startActivity(intent); // 3、setClass/setClassName方法Intent intent = new Intent();    intent.setClass(this, SecondActivity.class);  intent.setClassName(this, &quot;com.example.android.SecondActivity&quot;);  intent.setClassName(this.getPackageName(), &quot;com.example.android.SecondActivity&quot;);        startActivity(intent);  </code></pre><p>我们看看[注释2-4]这三种方式：</p><ul><li>[注释2]：this是当前Activity，直接写类名，则该Activity必须在同个包名内；</li><li>[注释3]：this是当前Activity，类名包括包名，则可以在当前包跳转到其他包的Activity；</li><li>[注释4]：this是当前Activity所在的应用程序，类名包括包名，则可以在当前包跳转到其他包的Activity；</li></ul><p>在可以使用应用的Context代替Activity的Context时，都推荐使用应用的Context，且Activity名称前面加上包名可以打破同个包内的限制，所以推荐使用[注释4]的方式。</p><h3 id="1-3-2-action"><a href="#1-3-2-action" class="headerlink" title="1.3.2 action"></a>1.3.2 action</h3><p>用来表示意图的行动，一个Intent只能有一个Action。以下是一些比较常见的Action。所有的Action可以在<a href="https://www.apiref.com/android-zh/android/content/Intent.html">Android开发手册-Intent</a> 查看。</p><table><thead><tr><th>Action</th><th>含义</th></tr></thead><tbody><tr><td>ACTION_MAIN</td><td>Android 的程序入口</td></tr><tr><td>ACTION_VIEW</td><td>显示指定数据</td></tr><tr><td>ACTION_EDIT</td><td>编辑指定数据</td></tr><tr><td>ACTION_DIAL</td><td>显示拨号面板</td></tr><tr><td>ACTION_CALL</td><td>直接呼叫 Data 中所带的号码</td></tr><tr><td>ACTION_ANSWER</td><td>接听来电</td></tr><tr><td>ACTION_SEND</td><td>向其他人发送数据（例如：彩信&#x2F;email）</td></tr></tbody></table><p>打开手机的拨号界面的代码可以这么写：</p><pre><code class="java">    Intent intent=new Intent();    intent.setAction(Intent.ACTION_DIAL);    intent.setData(Uri.parse(&quot;tel:1234567&quot;));    startActivity(intent);</code></pre><h3 id="1-3-3-category"><a href="#1-3-3-category" class="headerlink" title="1.3.3 category"></a>1.3.3 category</h3><p>用来表示动作的类别，一个Intent可以有多个category，类别越多，代表动作越具体，意图越明确。</p><h3 id="1-3-4-data"><a href="#1-3-4-data" class="headerlink" title="1.3.4 data"></a>1.3.4 data</h3><p>清单文件里标签具体如下：</p><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>scheme</td><td>协议</td></tr><tr><td>host</td><td>主机</td></tr><tr><td>port</td><td>端口</td></tr><tr><td>path</td><td>用来匹配完整的路径</td></tr><tr><td>pathPrefix</td><td>用来匹配路径的开头部分</td></tr><tr><td>pathPattern</td><td>用表达式来匹配整个路径</td></tr><tr><td>mimeType</td><td>用来匹配数据类型或MIME类型</td></tr></tbody></table><p>举个例子：</p><pre><code class="java">&lt;data android:scheme=&quot;http&quot;  android:host=&quot;www.baidu.com&quot;/&gt;</code></pre><p>系统内置的几个 Data 属性常量：</p><table><thead><tr><th>协议</th><th>含义</th></tr></thead><tbody><tr><td>tel:</td><td>号码数据格式，后跟电话号码</td></tr><tr><td>mailto:</td><td>邮件数据格式，后跟邮件收件人地址</td></tr><tr><td>smsto:</td><td>短信数据格式，后跟短信接收号码</td></tr><tr><td>file:&#x2F;&#x2F;&#x2F;</td><td>文件数据格式，后跟文件路径。注意必须是三根斜杠 &#x2F;&#x2F;&#x2F;</td></tr><tr><td>content:&#x2F;&#x2F;</td><td>内容数据格式，后跟需要读取的内容。ContentProvider 特有的格式</td></tr></tbody></table><h3 id="1-3-5-type"><a href="#1-3-5-type" class="headerlink" title="1.3.5 type"></a>1.3.5 type</h3><p>type 属性用于指定 data 所制定的 Uri 对应的 MIME 类型，通常应用于调用系统 App，比如实现查看文件（文本、图片、音频或者视频等），通过指定文件的 MIME 类型，可以让系统知道用什么程序打开该文件。</p><p><strong>常用的 MIME 类型</strong>：</p><table><thead><tr><th>文件格式</th><th>对应的MIME类型</th></tr></thead><tbody><tr><td>.bmp</td><td>image&#x2F;bmp</td></tr><tr><td>.gif</td><td>image&#x2F;gif</td></tr><tr><td>.png</td><td>image&#x2F;png</td></tr><tr><td>.tif .tiff</td><td>image&#x2F;tiff</td></tr><tr><td>.jpe .jpeg .jpg</td><td>image&#x2F;jpeg</td></tr><tr><td>.txt</td><td>text&#x2F;plain</td></tr><tr><td>.xml</td><td>text&#x2F;xml</td></tr><tr><td>.html</td><td>text&#x2F;html</td></tr><tr><td>.css</td><td>text&#x2F;css</td></tr><tr><td>.js</td><td>text&#x2F;javascript</td></tr><tr><td>.mht .mhtml</td><td>message&#x2F;rfc822</td></tr><tr><td>.doc</td><td>application&#x2F;msword</td></tr><tr><td>.docx</td><td>application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.document</td></tr><tr><td>.rtf</td><td>application&#x2F;rtf</td></tr><tr><td>.xls</td><td>application&#x2F;vnd.ms-excel application&#x2F;x-excel</td></tr><tr><td>.xlsx</td><td>application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet</td></tr><tr><td>.ppt</td><td>application&#x2F;vnd.ms-powerpoint</td></tr><tr><td>.pptx</td><td>application&#x2F;vnd.openxmlformats-officedocument.presentationml.presentation</td></tr><tr><td>.pps</td><td>application&#x2F;vnd.ms-powerpoint</td></tr><tr><td>.ppsx</td><td>application&#x2F;vnd.openxmlformats-officedocument.presentationml.slideshow</td></tr><tr><td>.pdf</td><td>application&#x2F;pdf</td></tr><tr><td>.swf</td><td>application&#x2F;x-shockwave-flash</td></tr><tr><td>.dll</td><td>application&#x2F;x-msdownload</td></tr><tr><td>.exe</td><td>application&#x2F;octet-stream</td></tr><tr><td>.msi</td><td>application&#x2F;octet-stream</td></tr><tr><td>.chm</td><td>application&#x2F;octet-stream</td></tr><tr><td>.cab</td><td>application&#x2F;octet-stream</td></tr><tr><td>.ocx</td><td>application&#x2F;octet-stream</td></tr><tr><td>.rar</td><td>application&#x2F;octet-stream</td></tr><tr><td>.tar</td><td>application&#x2F;x-tar</td></tr><tr><td>.tgz</td><td>application&#x2F;x-compressed</td></tr><tr><td>.zip</td><td>application&#x2F;x-zip-compressed</td></tr><tr><td>.z</td><td>application&#x2F;x-compress</td></tr><tr><td>.wav</td><td>audio&#x2F;wav</td></tr><tr><td>.wma</td><td>audio&#x2F;x-ms-wma</td></tr><tr><td>.wmv</td><td>video&#x2F;x-ms-wmv</td></tr><tr><td>.mp3 .mp2 .mpe .mpeg .mpg</td><td>audio&#x2F;mpeg</td></tr><tr><td>.rm</td><td>application&#x2F;vnd.rn-realmedia</td></tr><tr><td>.mid .midi .rmi</td><td>audio&#x2F;mid</td></tr></tbody></table><p>在清单文件中的里，只有<data>没有<type>。但在代码里就可以调用：</p><ul><li>setType(): 调用后设置 mimeType，然后将 data 置为 null；</li><li>setData(): 调用后设置 data，然后将 mimeType 置为 null；</li><li>setDataAndType(): 调用后才会同时设置 data 与 mimeType。</li></ul><p>举个打开百度的例子：</p><pre><code class="java">&lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;    &lt;data android:scheme=&quot;http&quot;  android:host=&quot;www.baidu.com&quot;/&gt;&lt;/intent-filter&gt;</code></pre><pre><code class="java">    intent = new Intent();    intent.setAction(Intent.ACTION_VIEW);    Uri data=Uri.parse(&quot;http://www.baidu.com&quot;);    intent.setData(data);    startActivity(intent);</code></pre><h3 id="1-3-6-extras"><a href="#1-3-6-extras" class="headerlink" title="1.3.6 extras"></a>1.3.6 extras</h3><p>extras：拓展信息，通常用于多个Activity之间的数据交换，extras属性是一个Bundle对象，通过键值对，对数据进行存储。extras在日常开发中非常常见：</p><pre><code class="java">Intent intent = new Intent(this, SecondActivity.class);intent.putExtra(&quot;name&quot;, &quot;Tony&quot;);intent.putExtra(&quot;age&quot;, 28);startActivity(intent);</code></pre><h3 id="1-3-7-flags"><a href="#1-3-7-flags" class="headerlink" title="1.3.7 flags"></a>1.3.7 flags</h3><p>flags：标志位，指明当前的Intent所期望的运行模式，具体有：</p><ul><li>FLAG_ACTIVITY_CLEAR_TOP：新跳转的Activity如果已经在栈中，则将其上面的所有Activity都清出栈，相当于Activity四大启动模式中的singleTask；</li><li>FLAG_ACTIVITY_SINGLE_TOP：返回栈没有当前需要跳转的Activity，则新建该Activity并放入栈顶。但如果该Activity已经在栈顶了，则不会再重新创建新的Activity。相当于Activity四大启动模式中的singleTop；</li><li>FLAG_ACTIVITY_NEW_TASK：假设当前返回栈有A B C这3个Activity。此时C通过intent跳转到D，并且这个intent添加了FLAG_ACTIVITY_NEW_TASK标记，如果D这个Activity在AndroidManifest.xml中的声明中添加了Task affinity，系统首先会查找有没有和D的Task affinity相同的task栈存在，如果有存在，将D压入那个栈，如果不存在则会新建一个D的affinity的栈将其压入。但如果D的Task affinity默认没有设置，则会把其压入原来的返回栈，变成：A B C D，这样就和不加FLAG_ACTIVITY_NEW_TASK标记效果是一样的了。注意如果试图从非activity的非正常途径启动一个activity，比如从一个service中启动一个activity，则intent比如要添加FLAG_ACTIVITY_NEW_TASK标记。</li></ul><h2 id="1-4-隐式Intent匹配规则总结"><a href="#1-4-隐式Intent匹配规则总结" class="headerlink" title="1.4 隐式Intent匹配规则总结"></a>1.4 隐式Intent匹配规则总结</h2><p>隐式Intent的匹配规则，就是根据当前Intent所设置的action、category、data和清单文件中使用 <intent-filter> 元素为组件声明一个或多个 Intent 过滤器的、、几个属性做匹配，找到最合适的。总结如下：</p><ul><li>清单文件中：category如要使用默认值，则设为android.intent.category.DEFAULT，否者组件不会接收隐式 Intent；</li><li>如果不希望自己的组件，如自定义的XXXActivity被其他应用程序调用，则清单文件中，XXXActivity下面不要声明 <intent-filter> ，并且将该组件的 exported 属性设置为 false；</li><li>代码中：如果没有指定category，系统会默认设置为android.intent.category.DEFAULT；</li><li>一个Intent只有一个action，但可以有多个category，只有当action和所有category和某个<intent-filter>都同时匹配，才算匹配成功。</li><li>一个<intent-filter>可以设置一个或多个<action>，当Intent能和<intent-filter>的任意一个action匹配就算匹配成功；</li><li>一个<intent-filter>可以设置一个或多个<category>，只有当Intent能和<intent-filter>的所有category匹配才算匹配成功；</li><li>如果有多个组件被匹配成功，就会以对话框列表的方式让用户进行选择。</li></ul><h2 id="1-5-显示Intent与隐式Intent的区别"><a href="#1-5-显示Intent与隐式Intent的区别" class="headerlink" title="1.5 显示Intent与隐式Intent的区别"></a>1.5 显示Intent与隐式Intent的区别</h2><p>对明确指出了目标组件名称的Intent，我们称之为“显式Intent”。 对于没有明确指出目标组件名称的Intent，则称之为“隐式 Intent”。</p><h1 id="2、拓展"><a href="#2、拓展" class="headerlink" title="2、拓展"></a>2、拓展</h1><h2 id="2-1-Intent携带数据的大小"><a href="#2-1-Intent携带数据的大小" class="headerlink" title="2.1 Intent携带数据的大小"></a>2.1 Intent携带数据的大小</h2><p>Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。所以，如果是同个应用程序之间的数据传输，可以使用文件缓存或者磁盘缓存，如果是应用程序之间，则推荐使用ContentProvider进行数据传输。</p><h2 id="2-2-PendingIntent"><a href="#2-2-PendingIntent" class="headerlink" title="2.2 PendingIntent"></a>2.2 PendingIntent</h2><p>PendingIntent就是延迟或者挂起的Intent，平时也会使用到，在此做个拓展。如接收到消息需要在桌面做通知时，可以这么写：</p><pre><code class="java">pendingIntent = PendingIntent.getActivities(            applicationContext, 0, intents,            PendingIntent.FLAG_UPDATE_CURRENT        ) val builder = NotificationCompat.Builder(applicationContext, FORCE_UPDATE_NOTIFY_CHANNEL_ID)            builder.setWhen(System.currentTimeMillis())            .setContentTitle(showTitle)            .setContentText(showContent)            .setContentIntent(pendingIntent) //5            .setPriority(NotificationCompat.PRIORITY_MAX)            .setCategory(NotificationCompat.CATEGORY_MESSAGE)            .setVisibility(VISIBILITY_PUBLIC)            .setAutoCancel(true)            .setSmallIcon(R.drawable.ic_launcher)</code></pre><p>其中，[注释5]的pendingIntent就是PendingIntent。PendingIntent的具体用法和实现原理，推荐看看这篇文章：<a href="https://juejin.cn/post/7122767360976486413">Android 面试题：说一下 PendingIntent 和 Intent 的区别</a></p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intent&quot;&gt;&lt;a href=&quot;#Intent&quot; class=&quot;headerlink&quot; title=&quot;Intent&quot;&gt;&lt;/a&gt;Intent&lt;/h1&gt;&lt;h1 id=&quot;1、什么是Intent&quot;&gt;&lt;a href=&quot;#1、什么是Intent&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>IntentService</title>
    <link href="http://example.com/2022/12/04/Android/IntentService/"/>
    <id>http://example.com/2022/12/04/Android/IntentService/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:07:24.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h1><h1 id="1、IntentService是什么？"><a href="#1、IntentService是什么？" class="headerlink" title="1、IntentService是什么？"></a>1、IntentService是什么？</h1><p>回顾Android实现线程异步的方法，有AsyncTask、HandlerThread、线程池、IntentService。其中IntentService其实是继承与Service的类，内部是由HandlerThread实现（HandlerThread本系列由专门的小节做介绍，不清楚的童鞋可以去看看）。常用于处理异步请求，处理完子线程的耗时操作后，会自动执行stopService()。</p><h1 id="2、IntentService的使用"><a href="#2、IntentService的使用" class="headerlink" title="2、IntentService的使用"></a>2、IntentService的使用</h1><p>我们用IntentService来实现在后台读取文件已经下载文件，直接上demo：</p><pre><code class="java">// XuruiIntentService.javapublic class XuruiIntentService extends IntentService &#123;    private static final String TAG = &quot;XuruiIntentService&quot;;    public XuruiIntentService() &#123;        //IntentService 工作线程的名字        super(&quot;XuruiIntentService&quot;);    &#125;    @Override    public void onCreate() &#123;        super.onCreate();    &#125;    @Override    public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;        return super.onStartCommand(intent, flags, startId);    &#125;    @Override    public void onDestroy() &#123;        super.onDestroy();    &#125;    @Override    protected void onHandleIntent(@Nullable Intent intent) &#123;        if (intent != null) &#123;            String taskName = intent.getStringExtra(&quot;taskName&quot;);            switch (taskName) &#123;                case &quot;readFile&quot;: //1                    //任务一：执行读取大文件内容的耗时操作                    try &#123;                        readFile();                        Thread.sleep(3000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    break;                case &quot;DownLoad&quot;: //2                    //任务二：执行从网络下载文件的耗时操作                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;// Activity中使用XuruiIntentService类    public void onClick(View v) &#123;        Intent intent = new Intent(this, XuruiIntentService.class);        switch (v.getId()) &#123;            case R.id.readFileBtn: //3                intent.putExtra(&quot;taskName&quot;, &quot;readFile&quot;);                startService(intent);                break;            case R.id.downLoadBtn: //4                intent.putExtra(&quot;taskName&quot;, &quot;DownLoad&quot;);                startService(intent);                break;            default:                break;        &#125;    &#125;</code></pre><p>上面的demo还是比较好理解的，在注释3按下读取文件的按钮后，就会通过startService()启动服务，跑到注释1去执行耗时的文件读取操作。没错，IntentService的启动和Service的启动是一样的。</p><p>还有一点需要注意，如果按下readFileBtn后马上按downLoadBtn，那么代码执行的顺序是： onCreate、onStartCommand、onHandleIntent: readFile、onStartCommand、onHandleIntent: DownLoad、onDestroy</p><p>但如果按下readFileBtn后稍等一会再按downLoadBtn，那么代码执行的顺序是： onCreate、onStartCommand、onHandleIntent: task1、readFile、 onCreate、onStartCommand、onHandleIntent: task2、DownLoad</p><p>以上两种情况证明了，IntentService在处理完操作后，会自动退出，因此按下readFileBtn后稍等一会再按downLoadBtn，会重新拉起一个新的服务，从onCreate()开始执行。</p><p><strong>注</strong>：不能用bindService()来绑定IntentService，因为onBind()默认返回null。</p><h1 id="3、源码分析"><a href="#3、源码分析" class="headerlink" title="3、源码分析"></a>3、源码分析</h1><p>因为内部使用HandlerThread实现，源码也才100+行，因此直接copy完整的源码，不做任何删减（下面源码是android9.0.0的源码）。</p><pre><code class="java">public abstract class IntentService extends Service &#123;     private volatile Looper mServiceLooper;     private volatile ServiceHandler mServiceHandler;     private String mName;     private boolean mRedelivery;        private final class ServiceHandler extends Handler &#123;         public ServiceHandler(Looper looper) &#123;             super(looper);         &#125;            @Override         public void handleMessage(Message msg) &#123;             onHandleIntent((Intent)msg.obj); //1             stopSelf(msg.arg1); //2         &#125;     &#125;        /**      * Creates an IntentService.  Invoked by your subclass&#39;s constructor.      *      * @param name Used to name the worker thread, important only for debugging.      */     public IntentService(String name) &#123;         super();         mName = name;     &#125;        /**      * Sets intent redelivery preferences.  Usually called from the constructor      * with your preferred semantics.      *      * &lt;p&gt;If enabled is true,      * &#123;@link #onStartCommand(Intent, int, int)&#125; will return      * &#123;@link Service#START_REDELIVER_INTENT&#125;, so if this process dies before      * &#123;@link #onHandleIntent(Intent)&#125; returns, the process will be restarted      * and the intent redelivered.  If multiple Intents have been sent, only        * the most recent one is guaranteed to be redelivered.        *        * &lt;p&gt;If enabled is false (the default),        * &#123;@link #onStartCommand(Intent, int, int)&#125; will return        * &#123;@link Service#START_NOT_STICKY&#125;, and if the process dies, the Intent        * dies along with it.        */       public void setIntentRedelivery(boolean enabled) &#123;           mRedelivery = enabled;       &#125;         @Override       public void onCreate() &#123;           // TODO: It would be nice to have an option to hold a partial wakelock           // during processing, and to have a static startService(Context, Intent)           // method that would launch the service &amp; hand off a wakelock.              super.onCreate();           HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); //3           thread.start(); //4              mServiceLooper = thread.getLooper(); //5.1           mServiceHandler = new ServiceHandler(mServiceLooper); //5.2       &#125;          @Override       public void onStart(@Nullable Intent intent, int startId) &#123;           Message msg = mServiceHandler.obtainMessage();           msg.arg1 = startId;           msg.obj = intent;           mServiceHandler.sendMessage(msg); //6       &#125;          /**        * You should not override this method for your IntentService. Instead,        * override &#123;@link #onHandleIntent&#125;, which the system calls when the IntentService        * receives a start request.        * @see android.app.Service#onStartCommand        */       @Override       public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;           onStart(intent, startId);           return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;       &#125;          @Override       public void onDestroy() &#123;           mServiceLooper.quit(); //7       &#125;          /**        * Unless you provide binding for your service, you don&#39;t need to implement this        * method, because the default implementation returns null.        * @see android.app.Service#onBind        */       @Override       @Nullable       public IBinder onBind(Intent intent) &#123;           return null;       &#125;          /**        * This method is invoked on the worker thread with a request to process.        * Only one Intent is processed at a time, but the processing happens on a        * worker thread that runs independently from other application logic.        * So, if this code takes a long time, it will hold up other requests to        * the same IntentService, but it will not hold up anything else.        * When all requests have been handled, the IntentService stops itself,        * so you should not call &#123;@link #stopSelf&#125;.        *        * @param intent The value passed to &#123;@link        *               android.content.Context#startService(Intent)&#125;.        *               This may be null if the service is being restarted after        *               its process has gone away; see        *               &#123;@link android.app.Service#onStartCommand&#125;        *               for details.        */       @WorkerThread       protected abstract void onHandleIntent(@Nullable Intent intent);   &#125;&#125;</code></pre><p>如果已经学习过本系列Service和HandlerThread两小节的同学，看上面的代码就非常容易了。我们以上一小节，按下readFileBtn来读取文件内容为例，看看IntentService源码都做了什么？</p><pre><code class="java">    // 按下readFileBtn后执行：    intent.putExtra(&quot;taskName&quot;, &quot;readFile&quot;);    startService(intent);</code></pre><p>启动服务后，流程如下：</p><ol><li>首先执行onCreate()，里面的注释3-5正是HandlerThread三大经典的使用步骤，对应[注释3-5]；</li><li>接着执行onStartCommand() -&gt; onStart()，通过子线程的mServiceHandler发送消息，对应[注释6]；</li><li>发送信息就有接收信息，执行子线程handleMessage()中调用我们重写的 onHandlerIntent 执行异步任务，对应[注释1]；</li><li>等待所有任务执行完后，调用[注释2] stopSelf(msg.arg1)来销毁服务，可以发现该方法带了参数，意为尝试停止服务之前会判断最近启动服务的次数是否是startId，如果相等才停止服务。</li></ol><p>因为onCreate()只会执行一次，但onStartCommand()可以执行多次，所以多次调用startService(Intent) 时，上面2-3步骤可能发送和接收多个消息，通过复写onHandlerIntent()，再根据发送不同的Intent，进行不同的线程操作。且发送多个消息时，对应的多个任务需要按顺序逐个执行。</p><h1 id="4、Service-与-IntentService-的区别"><a href="#4、Service-与-IntentService-的区别" class="headerlink" title="4、Service 与 IntentService 的区别"></a>4、Service 与 IntentService 的区别</h1><ul><li>Service不是单独的线程，如果在onStartCommand()中执行耗时操作可能发生ANR，IntentService会创建一个工作线程来处理多线程任务；</li><li>Service长期存在后台，结束需要主动调用stopSelft()来结束服务，而IntentService会在任务完成后默认调用stopSelft()直接退出；</li><li>两者都可以是使用startService()启动，但IntentService不能onBind();</li></ul><h1 id="5、使用场景"><a href="#5、使用场景" class="headerlink" title="5、使用场景"></a>5、使用场景</h1><p>IntentService适合多个任务需要按顺序，适用更高优先级的的后台任务，不容易被系统杀死的使用场景，比如离线下载场景，后台下载场景。</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IntentService&quot;&gt;&lt;a href=&quot;#IntentService&quot; class=&quot;headerlink&quot; title=&quot;IntentService&quot;&gt;&lt;/a&gt;IntentService&lt;/h1&gt;&lt;h1 id=&quot;1、IntentService是什么？&quot;&gt;</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>事件分发机制</title>
    <link href="http://example.com/2022/12/04/Android/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/12/04/Android/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:07:59.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h1><p>‍</p><h1 id="1、触摸事件分发流程"><a href="#1、触摸事件分发流程" class="headerlink" title="1、触摸事件分发流程"></a>1、触摸事件分发流程</h1><p>在《Activity、Window、DecorView以及ViewRoot层级关系全解析》一节有下图： <img src="https://uploadfiles.nowcoder.com/images/20221227/545613072_1672132965590/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><p>我们知道View的结构是树形结构，View可以放在ViewGroup中，ViewGroup也可以放在另一个ViewGroup中，如此就形成了层层嵌套的关系。当我们触摸到屏幕后，就会生成一个Touch事件，常见的Touch事件有：</p><ul><li>MotionEvent.ACTION_DOWN：按下</li><li>MotionEvent.ACTION_MOVE：滑动</li><li>MotionEvent.ACTION_CANCEL：非人为原因结束本次事件</li><li>MotionEvent.ACTION_UP：抬起 一般来说，一个事件会经过：按下 –》 滑动 –》抬起，这三个阶段，并在这个过程中会有非人为原因结束本次触摸流程。这些事件会在代码里会封装成一个MotionEvent。那么，当MotionEvent产生后，系统就会将其传递给View树，MotionEvent在View的层级传递，并最终得到处理的过程，就是触摸事件分发流程。一个流程的传递顺序是：</li></ul><blockquote><p>Activity&#x2F;Window –&gt; ViewGroup –&gt; View</p></blockquote><p>其中，View就是各种控件，如Button、TextView等，而ViewGroup是View的子类，因此本质上也是一个View，只不过ViewGroup可以包含多个子View和定义布局参数。</p><h1 id="2、触摸事件分发的3个重要方法"><a href="#2、触摸事件分发的3个重要方法" class="headerlink" title="2、触摸事件分发的3个重要方法"></a>2、触摸事件分发的3个重要方法</h1><p>有以下3个重要方法是必须掌握的：</p><ul><li>dispatchTouchEvent(MotionEvent ev)：进行事件的分发，在View和ViewGroup类都有该方法，下文会对该方法的源码进行分析，需要区分清楚；</li><li>onInterceptTouchEvent(MotionEvent ev)：进行事件拦截，在dispatchTouchEvent()中调用，在分发的过程中判断是否需要进行拦截，需要注意的是只有ViewGroup有该方法，View是没有提供该方法的。如果返回true代表拦截，返回false代表不拦截；</li><li>onTouchEvent(MotionEvent ev)：触摸事件处理，同样在dispatchTouchEvent()方法中进行调用，如果返回true代表已处理事件，返回false代表不处理事件，事件继续传递。</li></ul><p>为了更好的了解三者的关系，我们从源码出发，首先看看ViewGroup的dispatchTouchEvent()，源码是Android9.0.0&#x3D;》&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewGroup.java：</p><pre><code class="java">public boolean dispatchTouchEvent(MotionEvent ev) &#123;    ...    if (!disallowIntercept) &#123;        intercepted = onInterceptTouchEvent(ev);  //1        ev.setAction(action); // restore action in case it was changed    &#125; else &#123;        intercepted = false;    &#125;    ...    if (actionMasked == MotionEvent.ACTION_DOWN            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;        ...        if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;            ...            for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; //2:遍历ViewGroup的子View                final int childIndex = getAndVerifyPreorderedIndex(                        childrenCount, i, customOrder);                final View child = getAndVerifyPreorderedView(                        preorderedList, children, childIndex);                ...                resetCancelNextUpFlag(child);                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; //3                    ...                    break;                &#125;                ...            &#125;        &#125;    &#125;&#125;</code></pre><p>在[注释1]调用了onInterceptTouchEvent()方法来判断是否要拦截当前的事件。</p><pre><code class="java">  public boolean onInterceptTouchEvent(MotionEvent ev) &#123;        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;            return true;        &#125;        return false;    &#125;</code></pre><p>可以看出onInterceptTouchEvent()默认返回false，代表不拦截。接着在[注释2]遍历ViewGroup的子View，如果子View可以接收到触摸事件，则会执行[注释3]dispatchTransformedTouchEvent()：</p><pre><code class="java">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,                                              View child, int desiredPointerIdBits) &#123;    ...    if (child == null) &#123;        handled = super.dispatchTouchEvent(transformedEvent); //4    &#125; else &#123;        final float offsetX = mScrollX - child.mLeft;        final float offsetY = mScrollY - child.mTop;        transformedEvent.offsetLocation(offsetX, offsetY);        if (! child.hasIdentityMatrix()) &#123;            transformedEvent.transform(child.getInverseMatrix());        &#125;        handled = child.dispatchTouchEvent(transformedEvent); //5    &#125;    ...    return handled;&#125;</code></pre><p>在[注释4]，如果当前的ViewGroup没有View则调用父类的dispatchTouchEvent()，在[注释5]如果有子View，则调用子View的dispatchTouchEvent()。因为ViewGroup类也是继承View类的，因此[注释4]super.dispatchTouchEvent(transformedEvent)对应的源码在：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;View.java</p><pre><code class="java">public boolean dispatchTouchEvent(MotionEvent event) &#123;    ...    if (onFilterTouchEventForSecurity(event)) &#123;        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;            result = true;        &#125;        //noinspection SimplifiableIfStatement        ListenerInfo li = mListenerInfo;        if (li != null &amp;&amp; li.mOnTouchListener != null ///6                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; //7            result = true;        &#125;        if (!result &amp;&amp; onTouchEvent(event)) &#123; //8            result = true;        &#125;    &#125;    ...    return result;&#125;</code></pre><p>这个函数要稍微捋一捋，如果[注释6]mOnTouchListener不为空且[注释7]mOnTouchListener.onTouch()返回true，则result设置为true，因此[注释8]的onTouchEvent(event)就不执行，反之则执行。</p><p>最后，看看三大重要方法最后一个的onTouchEvent()，同样在View.java里：</p><pre><code class="java">  public boolean onTouchEvent(MotionEvent event) &#123;        ...        final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE //9                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) //10                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;        ...        if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;        switch (action) &#123;            case MotionEvent.ACTION_UP: // 11                ...                if (mPerformClick == null) &#123;                    mPerformClick = new PerformClick(); //12                &#125;                if (!post(mPerformClick)) &#123;                    performClickInternal();                &#125;            ...            break;            case MotionEvent.ACTION_DOWN:            ...            break;            case MotionEvent.ACTION_CANCEL:            ...            break;            case MotionEvent.ACTION_MOVE:            ...            break;        &#125;        return false;    &#125;</code></pre><p>从上面代码知道，[注释9]的CLICKABLE（点击）和[注释10]的LONG_CLICKABLE（长按点击）有一个为true，则会进入switch循环处理这个事件。最后在ACTION_UP[注释11]事件会调用performClick()[注释12]方法：</p><pre><code class="java">public boolean performClick() &#123;    final boolean result;    final ListenerInfo li = mListenerInfo;    if (li != null &amp;&amp; li.mOnClickListener != null) &#123;        playSoundEffect(SoundEffectConstants.CLICK);        li.mOnClickListener.onClick(this);        result = true;    &#125; else &#123;        result = false;    &#125;    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);    return result;&#125;</code></pre><p>如果View设置了点击事件OnClickListener，那么它的onClick()方法就会被执行。</p><h1 id="3、onTouch-、onTouchEvent-、onClick-傻傻分不清？"><a href="#3、onTouch-、onTouchEvent-、onClick-傻傻分不清？" class="headerlink" title="3、onTouch()、onTouchEvent()、onClick()傻傻分不清？"></a>3、onTouch()、onTouchEvent()、onClick()傻傻分不清？</h1><p>这三个方法，相信很多读者都经常见过，到底谁的优先级更高呢？结合[注释7][注释8][注释12]，可以看出，如果执行了onTouch()并返回false才会执行onTouchEvent()，在执行onTouchEvent()时如果调用了setOnClickListener()注册了点击事件回调，则还会执行OnClick()，因此三者的优先级为：</p><blockquote><p>onTouch() &gt; onTouchEvent() &gt; OnClick()</p></blockquote><h1 id="4、事件分发总结"><a href="#4、事件分发总结" class="headerlink" title="4、事件分发总结"></a>4、事件分发总结</h1><h2 id="4-1-表格总结"><a href="#4-1-表格总结" class="headerlink" title="4.1 表格总结"></a>4.1 表格总结</h2><p>上述源码分析如果觉得还有点懵，我们做个总结：</p><p>​<img src="https://uploadfiles.nowcoder.com/images/20221227/545613072_1672132951045/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><p>上面表格里的“事件列”是指一个事件序列有：ACTION_DOWN、ACTION_MOVE、ACTION_UP等。大部分情况由上面的表格就可以概括了。</p><h2 id="4-2-伪代码表示"><a href="#4-2-伪代码表示" class="headerlink" title="4.2 伪代码表示"></a>4.2 伪代码表示</h2><p>如果用伪代码可以如下表示：</p><pre><code class="java">// 父View调用dispatchTouchEvent()开始分发事件public boolean dispatchTouchEvent(MotionEvent event)&#123;    boolean consume = false;    // 父View决定是否拦截事件    if(onInterceptTouchEvent(event))&#123;        // 父View调用onTouchEvent(event)消费事件，如果该方法返回true，表示        // 该View消费了该事件，后续该事件序列的事件（Down、Move、Up）将不会在传递        // 该其他View。        consume = onTouchEvent(event);    &#125;else&#123;        // 调用子View的dispatchTouchEvent(event)方法继续分发事件        consume = child.dispatchTouchEvent(event);    &#125;    return consume;&#125;</code></pre><p>以下总结的非常好，因此直接抄录至刘偶像的博客，最后升华下本文的理解：<a href="http://liuwangshu.cn/application/view/5-dispatchingevents.html">参考文献</a></p><h2 id="4-3-事件由上到下的传递规则"><a href="#4-3-事件由上到下的传递规则" class="headerlink" title="4.3 事件由上到下的传递规则"></a>4.3 事件由上到下的传递规则</h2><p>当点击事件产生后会由Activity来处理再传递给Window再传递给顶层的ViewGroup，一般在事件传递中只考虑ViewGroup的onInterceptTouchEvent()方法，因为一般情况我们不会去重写dispatchTouchEvent()方法。</p><p>对于根ViewGroup，点击事件首先传递给它的dispatchTouchEvent()方法，如果该ViewGroup的onInterceptTouchEvent()方法返回true，则表示它要拦截这个事件，这个事件就会交给它的onTouchEvent()方法处理，如果onInterceptTouchEvent()方法返回false，则表示它不拦截这个事件，则交给它的子元素的dispatchTouchEvent()来处理，如此的反复下去。如果传递给最底层的View，View是没有子View的，就会调用View的dispatchTouchEvent()方法，一般情况下最终会调用View的onTouchEvent()方法。</p><p>举个现实的例子，就是我们的应用产生了重大的bug，这个bug首先会汇报给技术总监那：</p><p>技术总监（顶层ViewGroup)→技术经理（中层ViewGroup)→工程师（底层View)<br>技术总监不拦截，把bug分给了技术经理，技术经理不拦截把bug分给了工程师，工程师没有下属只有自己处理了。<br>事件由上而下传递返回值规则为：true，拦截，不继续向下传递；false，不拦截，继续向下传递。</p><h2 id="4-4-事件由下而上的传递规则"><a href="#4-4-事件由下而上的传递规则" class="headerlink" title="4.4 事件由下而上的传递规则"></a>4.4 事件由下而上的传递规则</h2><p>点击事件传给最底层的View，如果他的onTouchEvent()方法返回true，则事件由最底层的View消耗并处理了，如果返回false则表示该View不做处理，则传递给父View的onTouchEvent()处理，如果父View的onTouchEvent()仍旧返回返回false，则继续传递给改父View的父View处理，如此的反复下去。</p><p>再返回我们现实的例子，工程师发现这个bug太难搞不定（onTouchEvent()返回false)，他只能交给上级技术经理处理，如果技术经理也搞不定（onTouchEvent()返回false)，那就把bug传给技术总监，技术总监一看bug很简单就解决了（onTouchEvent()返回true)。</p><p>事件由下而上传递返回值规则为：true，处理了，不继续向上传递；false，不处理，继续向上传递。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件分发机制&quot;&gt;&lt;a href=&quot;#事件分发机制&quot; class=&quot;headerlink&quot; title=&quot;事件分发机制&quot;&gt;&lt;/a&gt;事件分发机制&lt;/h1&gt;&lt;p&gt;‍&lt;/p&gt;
&lt;h1 id=&quot;1、触摸事件分发流程&quot;&gt;&lt;a href=&quot;#1、触摸事件分发流程&quot; class=</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Service</title>
    <link href="http://example.com/2022/12/04/Android/Service/"/>
    <id>http://example.com/2022/12/04/Android/Service/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:07:35.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h3 id="1、启动模式"><a href="#1、启动模式" class="headerlink" title="1、启动模式"></a>1、启动模式</h3><p>​<img src="/images/Android/image-20231128154733-w4l8pu9.png" alt="image">​</p><h4 id="1-1-StartService-模式"><a href="#1-1-StartService-模式" class="headerlink" title="1.1 StartService() 模式"></a>1.1 StartService() 模式</h4><p>生命周期：onCreate()-&gt;onStartComment()-&gt;onDestroy()</p><p>生命周期见上图左时序图。当另一个组件可以通过调用 startService()方法来启动特定的服务，此时Service生命周期中的onStartCommand()方法被调用。当调用startService()方法时，其他组件需要在方法中传递一个intent参数，服务会在onStartCommand()中接收到intent并获取一些数据。比如ActivityA需要上报一些用户数据到服务器上面，就可以通过startService()来启动ServiceA，并将需要上报的数据传递给ServiceA，在ServiceA里面调用一些网络接口，把数据直接上报到服务器上面。</p><p>当一个服务以这种方式启动时，它的生命周期不再受启动它的组件的影响，它可以在后台无限期地运行，如上一段的例子里，就算ActvityA挂了，ServiceA仍在后台运行，直到ServiceA自己调用stopSelf()或者其他的组件手动调用stopService(ServiceA)时ServiceA才会停止。</p><p>‍</p><h4 id="1-2-BindService-模式"><a href="#1-2-BindService-模式" class="headerlink" title="1.2 BindService()模式"></a>1.2 BindService()模式</h4><p>生命周期：onCreate()-&gt;onBind()-&gt;onUnBind()-&gt;onDestroy()</p><p>生命周期见上图右侧时序图。从名字上可以看出这个“绑定”一个服务，要创建一个支持绑定的Service，我们必须要重写它的onBind()方法，这个方***返回一个IBinder对象，它是客户端用来和服务器进行交互的接口。如ActivityA绑定ServiceA，此时ActivityA称为客户端，ServiceA称为服务端，ActivityA有从ServiceA返回的一个IBinder对象，通过该对象，ActivityA就可以调用ServiceA里面的方法。</p><p>生命周期受Activity影响，Activity结束，Service也就结束了</p><p>‍</p><h4 id="1-3-startService-x2F-bindService同时使用"><a href="#1-3-startService-x2F-bindService同时使用" class="headerlink" title="1.3 startService&#x2F;bindService同时使用"></a>1.3 startService&#x2F;bindService同时使用</h4><p>我们完成可能startService启动一个服务的的同时又bindService绑定一个服务：</p><ul><li>因为通过startService启动，所以该Service将会一直再后台运行，onCreate方法只有在第一次startService时调用，onStartCommond的调用次数和startService调用次数一致</li><li>这种情况需要同时stopService和unbindService方法， onDestroy方法才会被执行，缺一不可。</li></ul><p>‍</p><h4 id="1-4-为什么bindService可以跟Activity生命周期联动？（附加题）"><a href="#1-4-为什么bindService可以跟Activity生命周期联动？（附加题）" class="headerlink" title="1.4 为什么bindService可以跟Activity生命周期联动？（附加题）"></a>1.4 为什么bindService可以跟Activity生命周期联动？（附加题）</h4><ol><li>bindService方法执行时，LoadedApk会记录ServiceConnection信息；</li><li>Activity执行finish方法时，会通过LoadedApk检查Activity是否存在未注销&#x2F;解绑的 ServiceConnection，如果有，那么会通知AMS注销&#x2F;解绑对应的Service，并打印异常信息，告诉用户应该主动执行注销&#x2F;解绑的操作。</li></ol><p>‍</p><h4 id="1-5-在什么情况下使用-startService-或-bindService-或-同时使用startService-和-bindService？"><a href="#1-5-在什么情况下使用-startService-或-bindService-或-同时使用startService-和-bindService？" class="headerlink" title="1.5 在什么情况下使用 startService 或 bindService 或 同时使用startService 和 bindService？"></a>1.5 在什么情况下使用 startService 或 bindService 或 同时使用startService 和 bindService？</h4><ol><li>如果你要启动的服务是需要后台长期运行，并且你经常需要使用到这个服务的，那么使用 startService 便可以了，比如我要经常上报数据到远程服务器，那么就用startService来启动负责数据上报的服务；</li><li>如果你只是要用到服务里的某个接口，使用频率也不高，因此不需要服务一直运行，而是等到需要使用接口的时候，通过bindService去绑定服务，创建该服务实例，调用完就解绑服务。这种方式可以节省很多系统资源，当然也要注意每次都要创建服务是需要花费一定时间的，只是相对于让服务一直运行后台，我们更愿意每次重新创建；</li><li>如果你想要与正在运行的 Service 取得联系，那么就可以通过 bindService来绑定服务，获取服务在本地的代理，也就是上面说的IBinder，通过IBinder来和Service取得联系。此时就同时使用 startService 和 bindService 了。</li></ol><p>‍</p><h3 id="2-Service的种类和优先级"><a href="#2-Service的种类和优先级" class="headerlink" title="2 Service的种类和优先级"></a>2 Service的种类和优先级</h3><h4 id="2-1-Service的种类"><a href="#2-1-Service的种类" class="headerlink" title="2.1 Service的种类"></a>2.1 Service的种类</h4><ol><li>后台service</li><li>前台service</li><li>本地service</li><li>远程service</li></ol><ul><li><p>按地点分：</p><ul><li>本地服务：该服务依赖于主进程，而非独立的进程，因此在一定程度节约了资源，且和主进程的通讯更简单，不过如果主进程挂了，该服务就终止。如一个主进程启动一个本地网络服务，将一些数据上报到远程服务器后，就可以停止该本地网络服务。</li><li>远程服务：该服务独立于主进程，是一个独立的进程。不受其他进程的影响，多个进程都可以通过AIDL（这个后续会讲到，TODO）单独与该服务进行IPC通讯，因此较为复杂，且这种服务一般长期运行在后台。典型的例子就是系统服务。</li></ul></li><li><p>按运行类型分：</p><ul><li>后台服务：默认的服务都是后台服务，也就是startService()启动的服务，服务终止时用户是无法感知的，如天气更新等服务；</li><li>前台服务：后台服务优先级较低，可能会被系统杀死，可以将后台服务提高为前台服务，是会在状态栏显示图标的服务，如常见的音乐播放服务，服务终止，状态栏的图标也消失；</li><li>可交互的后台服务：服务本来是无法和用户交互的，但可以先用Activity和用户交互，同时Activity通过bindSerive()绑定服务，进而实现“可交互的后台服务”。</li></ul></li></ul><h4 id="2-2-service的优先级"><a href="#2-2-service的优先级" class="headerlink" title="2.2 service的优先级"></a>2.2 service的优先级</h4><p>前台进程</p><p>可见进程</p><p>服务进程</p><p>后台进程</p><p>空进程</p><p>Service和Activity，一起看下Android中进程的优先级。以下优先级由高到低。</p><ol><li>前台进程：</li></ol><p>即与用户交互的Activity，以及Activity所使用的Service等，如果系统不足，最晚会杀死前台进程；</p><ol start="2"><li>可见进程：</li></ol><p>对用户可见，但不能与用户交互的Activity或者绑定在其上面的Service。</p><ol start="3"><li>服务进程：</li></ol><p>正使用StartService方法运行的服务，对用户是不可见的，但却是用户关心。例如正在看小说时，后台播放音乐的服务进程，如果此时系统需要空间运行，会先停止音乐服务，再停止看小说的进程。</p><ol start="4"><li>后台进程：</li></ol><p>运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这时的进程系统一旦没了有内存就首先被杀死</p><ol start="5"><li>空进程：</li></ol><p>不包含任何应用程序的进程，这样的进程系统是一般不会让他存在的。</p><p>‍</p><h4 id="3-3-如何保证service不被杀死"><a href="#3-3-如何保证service不被杀死" class="headerlink" title="3.3 如何保证service不被杀死"></a>3.3 如何保证service不被杀死</h4><p>1、使用自定义的服务</p><p>2、使用两个service，当其中的一个service挂了，用另一个service启动</p><p><strong>答案：</strong></p><ol><li>使用自定义系统服务：自定义系统服务原则上是不会被系统杀死的，因此，一些重要的服务可以考虑用自定义系统服务来实现；</li><li>使用系统服务来监控：先弄一个白名单，记录需要监控的应用的包名，再自定义一个系统服务，监控系统里某个应用被杀死，如果该应用在白名单上，则重新拉起应用；</li><li>设置为前台服务，前台服务的优先级更高，不会轻易被杀死；</li><li>使用第三方库来保活，如HelloDaemon；</li><li>使用双进程Service，在ServiceA和ServiceB相互保护，检测到有一个Service被杀死则重新拉起；</li><li>特殊操作拉起服务：在亮屏、开机等特殊操作手动的拉起服务；</li><li>使用闹钟循环拉起服务;</li><li>应用程序添加SystemUID，使应用程序成为系统应用，比如手机桌面的下拉框就是一个系统应用，叫做SystemUI；</li><li>Service设置成START_STICKY（onStartCommand方法中），kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样；</li></ol><h3 id="3、说说Activity、Intent、Service-是什么关系？"><a href="#3、说说Activity、Intent、Service-是什么关系？" class="headerlink" title="3、说说Activity、Intent、Service 是什么关系？"></a>3、说说Activity、Intent、Service 是什么关系？</h3><p>Activity是属于页面的交互和展示，Intent可以在Activity中进行数据的传输，Service属于一种后台进程</p><h3 id="4、直接在Activity中创建一个thread跟在service中创建一个thread之间的区别？"><a href="#4、直接在Activity中创建一个thread跟在service中创建一个thread之间的区别？" class="headerlink" title="4、直接在Activity中创建一个thread跟在service中创建一个thread之间的区别？"></a>4、直接在Activity中创建一个thread跟在service中创建一个thread之间的区别？</h3><ol><li>Activity中创建：该线程负责完成该Activity的某个特殊的任务，特别是耗时的任务，等Activity销毁后，线程就没有意义了，也就销毁了</li><li>Service中创建：因为Service是后台线程，只要服务没有挂掉，线程就可以一直运行</li></ol><p>‍</p><h3 id="5-Service和Activity如何进行通信"><a href="#5-Service和Activity如何进行通信" class="headerlink" title="5 Service和Activity如何进行通信"></a>5 Service和Activity如何进行通信</h3><ol><li>在service中添加一个继承Binder的内部类，并添加相应的方法</li><li>service中重写service的onbind方法，返回我们刚刚定义的那个内部类的实例</li><li>Activity中绑定服务，重写serviceConnection，onserviceConnection时返回的IBinder调用逻辑方法</li></ol><h3 id="6-IntentService是什么-IntentService原理，应用场景及其与Service的区-别"><a href="#6-IntentService是什么-IntentService原理，应用场景及其与Service的区-别" class="headerlink" title="6 .IntentService是什么,IntentService原理，应用场景及其与Service的区 别"></a>6 .IntentService是什么,IntentService原理，应用场景及其与Service的区 别</h3><p>IntentService 是 Service 的子类，默认开启了一个工作线程HandlerThread，使用这个工作线程逐一处理所有启动 请求，在任务执行完毕后会自动停止服务。只要实现一个方法 onHandleIntent，该方法会接收每个启动请求的 Intent，能够执行后台工作和耗时操作。</p><p>可以启动 IntentService 多次，而每一个耗时操作会以队列的方式在 IntentService 的 onHandlerIntent 回调方法中 执行，并且，每一次只会执行一个工作线程，执行完第一个再执行第二个。并且等待所有消息都执行完后才终止服 务。</p><p>如何使用：</p><ol><li>创建一个名叫 ServiceHandler 的内部 Handler</li><li>把内部Handler与HandlerThread所对应的子线程进行绑定</li><li>HandlerThread开启线程 创建自己的looper</li><li>通过 onStartCommand() intent，依次插入到工作队列中，并发送给 onHandleIntent()逐个处理</li></ol><p>应用场景：</p><p>后台下载任务，静默上传</p><p>‍</p><h3 id="7-bindService和startService混合使用的生命周期以及怎么关闭"><a href="#7-bindService和startService混合使用的生命周期以及怎么关闭" class="headerlink" title="7 bindService和startService混合使用的生命周期以及怎么关闭"></a>7 bindService和startService混合使用的生命周期以及怎么关闭</h3><ol><li><p>如果先启动Bind service 后启动start Service</p><p> 生命周期：onCreate()-&gt;onStartCommand()-&gt;onBind()</p></li><li><p>如果先启动start Service后启动BindService</p><p> 生命周期：onCreate()-&gt;onBind()-&gt;onStartCommand()</p></li><li><p>如果只是stop Service</p><p> service的onDestroy方法不会立即执行，在Activity退出的时候才会执行onDestroy()</p></li><li><p>如果只是unbindService </p><p> 只有onUnbind()方法会执行，ondestroy()不会执行</p></li></ol><p>如果要完全退出Service，那么就得执行unbindService()以及stopService。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Service&quot;&gt;&lt;a href=&quot;#Service&quot; class=&quot;headerlink&quot; title=&quot;Service&quot;&gt;&lt;/a&gt;Service&lt;/h1&gt;&lt;h3 id=&quot;1、启动模式&quot;&gt;&lt;a href=&quot;#1、启动模式&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>事件分发机制（下）</title>
    <link href="http://example.com/2022/12/04/Android/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2022/12/04/Android/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:08:14.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息机制全解析（下）"><a href="#消息机制全解析（下）" class="headerlink" title="消息机制全解析（下）"></a>消息机制全解析（下）</h1><h1 id="3、一问一答：常见问题汇总"><a href="#3、一问一答：常见问题汇总" class="headerlink" title="3、一问一答：常见问题汇总"></a>3、一问一答：常见问题汇总</h1><p>经过上面的学习，到了最激动人心的时刻了，揭秘下Handler常见的问题都如何回答。一开始觉得不知道如何回答的问题，你现在一定能轻松理解</p><h2 id="3-1-Handler-引起的内存泄露原因以及最佳解决方案"><a href="#3-1-Handler-引起的内存泄露原因以及最佳解决方案" class="headerlink" title="3.1 Handler 引起的内存泄露原因以及最佳解决方案"></a>3.1 Handler 引起的内存泄露原因以及最佳解决方案</h2><p>因为Handler一般是作为Activity的内部类，可以发送延迟执行的消息，如果在延迟阶段，我们把Activity关掉，此时因为该Activity还被Handler这个内部类所持有，导致Activity无法被回收，没有真正退出并释放相关资源，因此就造成内存泄漏。</p><p>工程上常用的方法是将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并在Acitivity的onDestroy()中调用handler.removeCallbacksAndMessages(null)及时移除所有消息。如果和面试官说了这两个方法，那你就100分过关了，但更进一步是建议将Handler抽离出来作为BaseHandler，然后每个Activity需要用到Handler的时候，就去继承BaseHandler。最佳解决方案具体代码：</p><pre><code>// 这个是BaseHandlerpublic abstract class BaseHandler&lt;T&gt; extends Handler &#123;    private final WeakReference&lt;T&gt; mWeakReference; //弱引用    protected BaseHandler(T t) &#123;        mWeakReference = new WeakReference&lt;T&gt;(t);    &#125;    protected abstract void handleMessage(T t, Message msg);    @Override    public void handleMessage(Message msg) &#123;        super.handleMessage(msg);        if (mWeakReference == null) &#123;            return;        &#125;        T t = mWeakReference.get();        if (t != null) &#123;            handleMessage(t, msg);        &#125;    &#125;&#125;//然后在某个Activity中使用 private static class H extends BaseHandler&lt;XuruiActivity&gt; &#123; //静态的内部类哦           public H(XuruiActivity activity) &#123;            super(activity);        &#125;        @Override        protected void handleMessage(XuruiActivity activity, Message msg) &#123;            //do something        &#125;    &#125;//同时Activity的onDestroy函数取消掉所有消息@Overrideprotected void onDestroy() &#123;    mMyHandler.removeCallbacksAndMessages(null);    super.onDestroy();&#125;</code></pre><h2 id="3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？"><a href="#3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？" class="headerlink" title="3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？"></a>3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？</h2><p>详情对应2.1小节，ActivityThread是主线程操作的管理者，在 ActivityThread.main() 方法中调用了 Looper.prepareMainLooper() ，该方法调用prepare()创建Looper。因此主线程不是不需要创建Looper，而是系统帮我们做了。</p><h2 id="3-3-Handler、Thread和HandlerThread的差别"><a href="#3-3-Handler、Thread和HandlerThread的差别" class="headerlink" title="3.3 Handler、Thread和HandlerThread的差别"></a>3.3 Handler、Thread和HandlerThread的差别</h2><p>又是这种考区别的题目，不过还算是比较常见的三个知识点：</p><ol><li>Handler：本文所学的知识，是Android的一种异步消息机制，负责发送和处理消息，可实现子线程和主线程的消息通讯；</li><li>Thread：Java的一个多线程类，是Java进程中最小执行运算单位，用于给子类继承，创建线程&#x2F;</li><li>HandlerThread：从名字看就知道是由前面两者结合起来的。可以理解为“一个继承自Thread的Handler类”，因此本质上和父类一样是Thread，但其内部直接实现了Looper，我们可以直接在HandlerThread里面直接使用Handler消息机制。减少了手动调用Looper.prepare()和Looper.loop()这些方法。</li></ol><h2 id="3-4-子线程中怎么使用-Handler？"><a href="#3-4-子线程中怎么使用-Handler？" class="headerlink" title="3.4 子线程中怎么使用 Handler？"></a>3.4 子线程中怎么使用 Handler？</h2><p>这个题目就可以结合上面两个题目来拓展理解了。子线程中使用 Handler 需要先执行两个操作：Looper.prepare() 和 Looper.loop()，看到这里你应该要记得这两个函数执行顺序是不能变的哦。同时可以直接使用HandlerThread类即可。</p><h2 id="3-5-为什么在子线程中创建-Handler-会抛异常？"><a href="#3-5-为什么在子线程中创建-Handler-会抛异常？" class="headerlink" title="3.5 为什么在子线程中创建 Handler 会抛异常？"></a>3.5 为什么在子线程中创建 Handler 会抛异常？</h2><p>不能在还没有调用 Looper.prepare() 方法的线程中创建 Handler。 因为抛出异常的地方，在Handler的构建函数，判断 mLooper 对象为null的时候， 会抛出异常</p><h2 id="3-6-Handler-里藏着的-Callback-能干什么？"><a href="#3-6-Handler-里藏着的-Callback-能干什么？" class="headerlink" title="3.6 Handler 里藏着的 Callback 能干什么？"></a>3.6 Handler 里藏着的 Callback 能干什么？</h2><p>详情对应2.4小节，当从消息队列获取到信息后，需要分配给对应的Handler去处理，总共有3种优先级。</p><ol><li>handleCallback(msg)：Message里自带的callback优先级最高；对应Handler的post方法；</li><li>mCallback.handleMessage(msg)：也就是Handler.Callback 写法；</li><li>handleMessage(msg)：重写handlerMessage()方法，优先级最低；</li></ol><p>而Handler.Callback处于第二优先级，当一条消息被 Callback 处理并返回true，那么 Handler 的 handleMessage(msg) 方法就不会被调用了；但如果 Callback 处理后返回false，那么这个消息就先后被Handler.Callback和handleMessage(msg)都处理过。</p><h2 id="3-7-Handler-的-send-和-post-的区别？"><a href="#3-7-Handler-的-send-和-post-的区别？" class="headerlink" title="3.7 Handler 的 send 和 post 的区别？"></a>3.7 Handler 的 send 和 post 的区别？</h2><p>基于上道题继续展开，post方法，它会把传入的 Runnable 参数赋值给 Message 的 callback 成员变量。当 Handler 进行分发消息时，msg.callback 会最优先执行。</p><ul><li>post是属于sendMessage的一种赋值callback的特例</li><li>post和sendMessage本质上没有区别，两种都会涉及到内存泄露的问题</li><li>post方式配合lambda表达式写法更精简</li></ul><h2 id="3-8-创建-Message-实例的最佳方式"><a href="#3-8-创建-Message-实例的最佳方式" class="headerlink" title="3.8 创建 Message 实例的最佳方式"></a>3.8 创建 Message 实例的最佳方式</h2><p>详情对应2.3小节，为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗：</p><p>通过 Message 的静态方法 Message.obtain()； 通过 Handler 的公有方法 handler.obtainMessage()。</p><h2 id="3-9-Message-的插入以及回收是如何进行的，如何实例化一个-Message-呢？"><a href="#3-9-Message-的插入以及回收是如何进行的，如何实例化一个-Message-呢？" class="headerlink" title="3.9 Message 的插入以及回收是如何进行的，如何实例化一个 Message 呢？"></a>3.9 Message 的插入以及回收是如何进行的，如何实例化一个 Message 呢？</h2><p>插入对应2.5.1小节注释2，Message 往 MessageQueue 插入消息时，会根据 when 字段（相对时间）来判断插入的顺序.</p><p>消息回收对应2.4小节loop()函数注释5，在消息执行完成之后，会进行回收消息，回收消息可见2.3小节recycleUnchecked()函数，只是 Message 的成员变量设置为0或者null；</p><p>实例化 Message 的时候，也是件2.3小节，本文建议多次了，尽量使用 Message.obtain 方法，这是从缓存消息池链表里直接获取的实例，可以避免 Message 的重复创建。</p><h2 id="3-10-妙用Looper机制，或者你知道Handler机制的其他用途吗？"><a href="#3-10-妙用Looper机制，或者你知道Handler机制的其他用途吗？" class="headerlink" title="3.10 妙用Looper机制，或者你知道Handler机制的其他用途吗？"></a>3.10 妙用Looper机制，或者你知道Handler机制的其他用途吗？</h2><ul><li>将 Runnable post 到主线程执行；</li><li>利用 Looper 判断当前线程是否是主线程；</li></ul><pre><code class="java">public boolean isMainThread() &#123;    return Looper.getMainLooper() == Looper.myLooper();&#125;</code></pre><h2 id="3-11-Looper-loop-死循环一直运行是不是特别消耗CPU资源呢？不会造成应用卡死吗？"><a href="#3-11-Looper-loop-死循环一直运行是不是特别消耗CPU资源呢？不会造成应用卡死吗？" class="headerlink" title="3.11 Looper.loop()死循环一直运行是不是特别消耗CPU资源呢？不会造成应用卡死吗？"></a>3.11 Looper.loop()死循环一直运行是不是特别消耗CPU资源呢？不会造成应用卡死吗？</h2><p>详情对应2.4和2.5小节。这还涉及linux多进程通讯方式：Pipe管道通讯。Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道。首先在loop()方法中，调用queue的next()方法获取下一个消息。具体看2.5.2小节，next()源码分析说过，MessageQueue没有消息时，便阻塞在nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，因此并不特别消耗CPU资源。</p><p>直到等待时长到了或者有新的消息时，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制是一种IO多路复用机制，可以同时监视多个描述符。当一个描述符号准备好(读或写)时，立即通知相应的程序进行读或写操作，其实质是同步 I&#x2F;O，即读写是阻塞的。其实主线程大多数时候都是处于这种休眠状态，并不会消耗大量CPU资源，更不会造成应用卡死。</p><h2 id="3-12-MessageQueue-中如何等待消息？为何不使用-Java-中的-wait-x2F-notify-来实现阻塞等待呢？"><a href="#3-12-MessageQueue-中如何等待消息？为何不使用-Java-中的-wait-x2F-notify-来实现阻塞等待呢？" class="headerlink" title="3.12 MessageQueue 中如何等待消息？为何不使用 Java 中的 wait&#x2F;notify 来实现阻塞等待呢？"></a>3.12 MessageQueue 中如何等待消息？为何不使用 Java 中的 wait&#x2F;notify 来实现阻塞等待呢？</h2><p>直接回答在 MessageQueue 的 nativePollOnce 函数阻塞，直到等待时长到了或者有新的消息时才重新唤醒MessageQueue。其实在 Android 2.2 及其以前，确实是使用wait&#x2F;notify来实现阻塞和唤醒，但是现在MessageQueue源码涉及很多native的方法，因此Java层的wait&#x2F;notify自然不过用了，而Pipe管道通讯是很底层的linux跨进程通讯机制，满足native层开发需求。</p><p>？</p><h2 id="3-13-你知道延时消息的原理吗？"><a href="#3-13-你知道延时消息的原理吗？" class="headerlink" title="3.13 你知道延时消息的原理吗？"></a>3.13 你知道延时消息的原理吗？</h2><p>首先是信息插入：会根据when属性（需要处理消息的相对时间）进行排序，越早的时间的Message插在链表的越前面；</p><p>在取消息处理时，如果时间还没到，就休眠到指定时间；如果当前时间已经到了，就返回这个消息交给 Handler 去分发，这样就实现处理延时消息了。</p><h2 id="3-14-handler-postDelay这个延迟是怎么实现的？"><a href="#3-14-handler-postDelay这个延迟是怎么实现的？" class="headerlink" title="3.14 handler postDelay这个延迟是怎么实现的？"></a>3.14 handler postDelay这个延迟是怎么实现的？</h2><h2 id="3-15-如何保证在msg-postDelay情况下保证消息次序？"><a href="#3-15-如何保证在msg-postDelay情况下保证消息次序？" class="headerlink" title="3.15 如何保证在msg.postDelay情况下保证消息次序？"></a>3.15 如何保证在msg.postDelay情况下保证消息次序？</h2><p>详情对应2.5.1小节，和上一题有所联系。handler.postDelay不是延迟一段时间再把Message放到MessageQueue中，而是直接进入MessageQueue，根据when变量（相对时间）的大小排序在消息池的链表里找到合适的插入位置，如此也保证了消息的次序的准确性。也就是本质上以MessageQueue的时间顺序排列和唤醒的方式结合实现的。</p><h2 id="3-16-更新UI的方式有哪些"><a href="#3-16-更新UI的方式有哪些" class="headerlink" title="3.16 更新UI的方式有哪些"></a>3.16 更新UI的方式有哪些</h2><p>这个题目放到这一节确实比较靠前，但因为本节介绍了其中的两个。所以也提一下。</p><ul><li>Activity.runOnUiThread(Runnable)</li><li>View.post(Runnable)，View.postDelay(Runnable, long)</li><li>Handler</li><li>AsyncTask</li><li>Rxjava</li><li>LiveData</li></ul><h2 id="3-17-线程、Handler、Looper、MessageQueue-的关系？"><a href="#3-17-线程、Handler、Looper、MessageQueue-的关系？" class="headerlink" title="3.17 线程、Handler、Looper、MessageQueue 的关系？"></a>3.17 线程、Handler、Looper、MessageQueue 的关系？</h2><p>这里还是有必要说明一下，一个线程对应一个 Looper （可见2.1小节prepare()函数注释1的判断），同时对应一个 MessageQueue，对应多个 Handler。</p><h2 id="3-18-多个线程给-MessageQueue-发消息，如何保证线程安全？"><a href="#3-18-多个线程给-MessageQueue-发消息，如何保证线程安全？" class="headerlink" title="3.18 多个线程给 MessageQueue 发消息，如何保证线程安全？"></a>3.18 多个线程给 MessageQueue 发消息，如何保证线程安全？</h2><p>见2.5.1 enqueueMessage()在插入Message的时候使用synchronized机制加锁。</p><h2 id="3-19-View-post-和-Handler-post-的区别？"><a href="#3-19-View-post-和-Handler-post-的区别？" class="headerlink" title="3.19 View.post 和 Handler.post 的区别？"></a>3.19 View.post 和 Handler.post 的区别？</h2><p>&#x2F;&#x2F;TODO：</p><h2 id="3-20-你知道IdleHandler吗？"><a href="#3-20-你知道IdleHandler吗？" class="headerlink" title="3.20 你知道IdleHandler吗？"></a>3.20 你知道IdleHandler吗？</h2><p>看看next()源码：</p><pre><code class="java">Message next() &#123;    ···    for (;;) &#123;        //1:阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回         nativePollOnce(ptr, nextPollTimeoutMillis);        ···        synchronized (this) &#123;           //获取消息            ···        &#125;        // 此时没有信息需要处理就跑到这里        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;            final IdleHandler idler = mPendingIdleHandlers[i];            mPendingIdleHandlers[i] = null; // release the reference to the handler            boolean keep = false;            try &#123;                keep = idler.queueIdle(); //1            &#125; catch (Throwable t) &#123;                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);            &#125;            if (!keep) &#123;                synchronized (this) &#123;                    mIdleHandlers.remove(idler);                &#125;            &#125;        &#125;        ...    &#125;&#125;</code></pre><p>IdleHandler 是通过 MessageQueue.addIdleHandler 来添加到 MessageQueue 的，前面提到当 MessageQueue.next 当前没有需要处理的消息时就会进入休眠，而在进入休眠之前呢，会执行注释1，此时如果返回true，则调用该方法后继续保留，下次队列又空闲的时候继续调用。如果返回false，就会在注释2将当前的idler删除。</p><p>‍</p><h3 id="3-21-子线程中能不能直接new一个Handler，为什么主线程可以？"><a href="#3-21-子线程中能不能直接new一个Handler，为什么主线程可以？" class="headerlink" title="3.21 子线程中能不能直接new一个Handler，为什么主线程可以？"></a>3.21 子线程中能不能直接new一个Handler，为什么主线程可以？</h3><p>子线程不可以直接new一个Handler，因为Handler的构造方法中，会通过Looper.myLooper()获取looper对象，如果为空，就会抛出异常</p><p>主线程在入口处ActivityThread的main方法中通过Looper.prepareMainLooper()获取到对象，并通过looper.loop()开启循环，在子线程中若要使用handler，可以先通过Looper.prepare获取到looper对象，并使用looper.loop()开启循环</p><p>‍</p><h3 id="3-22-Handler怎么做到的一个线程对应一个Looper，如何保证只有一个-MessageQueue-ThreadLocal在Handler机制中的作用"><a href="#3-22-Handler怎么做到的一个线程对应一个Looper，如何保证只有一个-MessageQueue-ThreadLocal在Handler机制中的作用" class="headerlink" title="3.22 .Handler怎么做到的一个线程对应一个Looper，如何保证只有一个 MessageQueue ThreadLocal在Handler机制中的作用"></a>3.22 .Handler怎么做到的一个线程对应一个Looper，如何保证只有一个 MessageQueue ThreadLocal在Handler机制中的作用</h3><pre><code>synchronized采取的是“以时间换空间”的策略，本质上是对关键资源上锁，让大家排队操作。 而ThreadLocal采取的是“以空间换时间”的思路， 它一个线程内部的数据存储类，通过它可以在制定的线程中存储数 据，数据存储以后，只有在指定线程中可以获取到存储的数据， 对于其他线程就获取不到数据，可以保证本线程任 何时间操纵的都是同一个对象。比如对于Handler，它要获取当前线程的Looper,很显然Looper的作用域就是线程， 并且不同线程具有不同的Looper。 ThreadLocal本质是操作线程中ThreadLocalMap来实现本地线程变量的存储的 ThreadLocalMap是采用数组的方式来存储数据，其中key(弱引用)指向当前ThreadLocal对象，value为设的值 通过 ThreadLocal计算出Hash key，通过这个哈 ThreadLocal对象，value为设的值</code></pre><p>‍</p><h3 id="3-23-Handler消息机制中，一个looper是如何区分多个Handler的当-Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理处-理message的时候怎么知道是去哪个callback处理的"><a href="#3-23-Handler消息机制中，一个looper是如何区分多个Handler的当-Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理处-理message的时候怎么知道是去哪个callback处理的" class="headerlink" title="3.23 Handler消息机制中，一个looper是如何区分多个Handler的当 Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理处 理message的时候怎么知道是去哪个callback处理的"></a>3.23 Handler消息机制中，一个looper是如何区分多个Handler的当 Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理处 理message的时候怎么知道是去哪个callback处理的</h3><p>每个Handler会被添加到 Message 的target字段上面，Looper 通过调用 Message.target.handleMessage() 来让 Handler 处理消息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息机制全解析（下）&quot;&gt;&lt;a href=&quot;#消息机制全解析（下）&quot; class=&quot;headerlink&quot; title=&quot;消息机制全解析（下）&quot;&gt;&lt;/a&gt;消息机制全解析（下）&lt;/h1&gt;&lt;h1 id=&quot;3、一问一答：常见问题汇总&quot;&gt;&lt;a href=&quot;#3、一问一答：常</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>View</title>
    <link href="http://example.com/2022/12/04/Android/View/"/>
    <id>http://example.com/2022/12/04/Android/View/</id>
    <published>2022-12-04T10:48:34.000Z</published>
    <updated>2023-12-07T09:07:48.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View"><a href="#View" class="headerlink" title="View"></a>View</h1><p>绘制View有三个组件：</p><ol><li><p>Measure：测量视图的高低</p></li><li><p>Layout：先通过measure测量出ViewGroup宽高，ViewGroup再通过layout方法根据自身宽高来确定自身位置</p></li><li><p>Draw：绘制视图</p></li></ol><h1 id="1、View绘制前的流程"><a href="#1、View绘制前的流程" class="headerlink" title="1、View绘制前的流程"></a>1、View绘制前的流程</h1><p>入门一段时间的同学都会知道，View绘制流程就是Measure() -&gt; Laytou() -&gt; Draw()，这三大方法。没错，不过在进行这三个方法之前，系统又做了什么准备工作呢？这就是本小节解决的问题。以下的图，是贯穿全文的总结图，放在文章开头，我们一步一步分析。</p><p>​<img src="https://uploadfiles.nowcoder.com/images/20231120/545613072_1700451449454/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><p>以下内容与本系列《Activity、Window、DecorView以及ViewRoot层级关系》（以下简称为《参考文档1》）一文内容重复较多，特别是源码分析，故具体源码请看参考文档1。从Activity创建到View的绘制，经过以下步骤：</p><ul><li>Step1：初始化PhoneWindow和WindowManager</li></ul><p>之前一节说过，Activity 是在 ActivityThread 的 performLaunchActivity 中进行创建的，并在attach()方法中创建了PhoneWindow，并初始化WindowManager。attach()方法详情见<code>参考文档1</code>​的第2小节。</p><ul><li>Step2：初始化DecorView</li></ul><p>系统执行完attach()方法后，会执行onCreate()方法，在onCreate()方法中执行setContentView()方法将布局xml文件解析为View并设置到DecorView里面的ContentViews控件。这里的源码也对应<code>参考文档1</code>​的第2小节。</p><ul><li>Step3：ViewRootImpl创建和关联DecorView</li></ul><p>接着在handleResumeActivity()方法中，通过WindowManager的addView()方法将DecorView添加到WindoManager里面。通过源码分析，WindowManager的addView()方法最终通过WindowManagerGlobal的实例去addView()，在 WindowManagerGlobal()方法中，会创建一个ViewRootImpl，也就是最后会把DecorView传给了ViewRootImpl中的setView()方法。ViewRootImpl是DecorView的管理者，是WindowManager与DecorView之间的连接器。源码详情见<code>参考文档1</code>​的第4小节。</p><ul><li>Step4：建立 PhoneWindow 和 WindowManagerService 之间的连接</li></ul><p>WindowManagerService是所有Window窗口的管理者，负责Window的添加删除、事件派发等。每一个Activity都有一个PhoneWindow对象，操作PhoneWindow对象进行显示等操作，都需要和WindowManagerService进行交互。在上面第三步中的ViewRootImpl的setView()方法中，会执行setView()方法，会调用 requestLayout()方法，并且通过 WindowSession 的 addToDisplay()方法 与 WindowManagerService 进行交互。WindowManagerService 会为每一个 Window 关联一个 WindowStatus。到此，我们已经把DecorView加载到Window中了。</p><ul><li>Step5：建立与SurfaceFlinger的链接</li></ul><p>SurfaceFlinger主要对图层数据进行合成，然后发送到屏幕渲染。在第4步中，WindowStatus会创建一个SurfaceSession，SurfaceSession 会在 Native 层构造一个 SurfaceComposerClient 对象，它是应用程序与 SurfaceFlinger 沟通的桥梁。</p><ul><li>Step6：申请Surface</li></ul><p>View绘制会从ViewRoot的performTraversals()，按照Measure() -&gt; Layout() -&gt; Draw()经典流程完成View绘制。不过在此之前还会执行一个重要的函数relayoutWindow()。代码如下：</p><pre><code class="java">//frameworks/base/core/java/android/view/ViewRootImpl.javaprivate void performTraversals() &#123;    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); //1    ...    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);    ...    //执行测量流程    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); //2    ...    //执行布局流程    performLayout(lp, desiredWindowWidth, desiredWindowHeight); //3    ...    //执行绘制流程    performDraw(); //4&#125;</code></pre><p>调用<code>[注释1]</code>​的relayoutWindow()方法，通过 WindowSession与WindowManagerService交互，即把Java层的Surface和Native层的Surface关联在一起。</p><ul><li>Step7：正式进入View绘制</li></ul><p>接下来就是正式绘制View的整体流程，即<code>[注释2-4]</code>​三步走。绘制会根视图ViewRoot的performTraversals()方法开始，从上到下遍历整个视图树，每个ViewGroup会负责通知自己的子View进行绘制，而每个子View控件则负责绘制自己。大致的工作流程图如下：</p><p>​<img src="https://uploadfiles.nowcoder.com/images/20231120/545613072_1700451460462/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><p>从上面的图，可以看到有onMeasure(),onLayout(),onDraw()这三个函数，是我们在实现自定义View最常接触的三个函数，接下来以这三个函数为思路进行讲解。</p><h1 id="2、View绘制-Measure（测量）"><a href="#2、View绘制-Measure（测量）" class="headerlink" title="2、View绘制 - Measure（测量）"></a>2、View绘制 - Measure（测量）</h1><h2 id="2-1-Measure源码流程"><a href="#2-1-Measure源码流程" class="headerlink" title="2.1 Measure源码流程"></a>2.1 Measure源码流程</h2><p>Measure翻译过来即是“测量”的意思，在此测量的是每个控件的宽和高。在代码层面，则是给每个View的mMeasuredWidth和mMeasuredHeight变量进行赋值。在测量时遵循：</p><ul><li>如果是ViewGroup，则遍历测量子View的宽高，再根据子View宽高算出自身的宽高；</li><li>如果是子View，则直接测量出自身宽高；</li></ul><p>现在从<code>[注释2]</code>​的performMeasure()方法开始：</p><pre><code class="java">//frameworks/base/core/java/android/view/ViewRootImpl.javaprivate void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;    if (mView == null) &#123;        return;    &#125;    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);    try &#123;        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); //5    &#125; finally &#123;        Trace.traceEnd(Trace.TRACE_TAG_VIEW);    &#125;&#125;</code></pre><p>逻辑很清晰，可发现实际起作用的是<code>[注释5]</code>​mView.measure()方法，</p><pre><code class="java">//frameworks/base/core/java/android/view/View.javapublic final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;    ...    if (forceLayout || needsLayout) &#123;       if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;            onMeasure(widthMeasureSpec, heightMeasureSpec); //6        &#125; else &#123;            setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);        &#125;    &#125;    ...&#125;</code></pre><p>measure()方法使用final修饰，代表不可重写。在measure()方法中会进行一系列逻辑处理后，调用<code>[注释6]</code>​的onMeasure()方法，真正的测量都在onMeasure()方法中实现。</p><pre><code class="java">//frameworks/base/core/java/android/view/View.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;     setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),             getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); //7 &#125;</code></pre><p>可以看到onMeasure()方法使用protected修饰，代表我们可以重写该方法。因此如果需要实现自己的测量逻辑，只能通过子View重写onMeasure()方法，而不能重写measure()方法。onMeasure()最后调用<code>[注释7]</code>​setMeasuredDimension()设置View的宽高信息，完成View的测量操作。</p><p>看看getDefaultSize()的源码：</p><pre><code class="java">public static int getDefaultSize(int size, int measureSpec) &#123;    int result = size;    //通过MeasureSpec解析获取mode与size    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) &#123;    case MeasureSpec.UNSPECIFIED:        result = size;        break;    case MeasureSpec.AT_MOST: //8    case MeasureSpec.EXACTLY: //8        result = specSize;        break;    &#125;    return result;&#125;</code></pre><p>这是系统设置默认的尺寸，在<code>[注释8]</code>​可以看到如果specMode是AT_MOST或者EXACTLY，则返回的就是specSize。至于 UNSPECIFIED 的情况，则会返回一个建议的最小值，这个值和子元素设置的最小值它的背景大小有关（这一段话可先看看2.2小节再回来继续看）。</p><p>从一开始执行的performMeasure()到最后设置宽高的setMeasuredDimension()方法，流程都比较清晰。并且可以发现有两个贯穿整个流程的变量，widthMeasureSpec和heightMeasureSpec，理解这两个变量才是关键。</p><h2 id="2-2-什么是MeasureSpec"><a href="#2-2-什么是MeasureSpec" class="headerlink" title="2.2 什么是MeasureSpec"></a>2.2 什么是MeasureSpec</h2><p>MeasureSpec是一个32位的int型数据，由两部分组成，SpecMode（测量模式，高2位） + SpecSize（测量尺寸，低30位）。将这两者打包为一个int数据可以起到节省内存的作用。有打包当然也有解包的方法：</p><pre><code class="java">//获取测量模式public static int getMode(int measureSpec) &#123;    return (measureSpec &amp; MODE_MASK);&#125;//获取测量尺寸public static int getSize(int measureSpec) &#123;    return (measureSpec &amp; ~MODE_MASK);&#125;</code></pre><blockquote><p>名词解析：控件的<code>布局参数LayoutParams</code>​是指控件设定为match_parent或者wrap_content或具体数值之中的一种。</p></blockquote><h3 id="2-2-1-测量模式"><a href="#2-2-1-测量模式" class="headerlink" title="2.2.1 测量模式"></a>2.2.1 测量模式</h3><ul><li>EXACTLY：确定大小，父View希望子View的大小是确定的。对应LayoutParams中的match_parent和具体数值这两种模式。检测到View所需要的精确大小，这时候View的最终大小就是SpecSize所指定的值；</li><li>AT_MOST ：最大大小，父View希望子View的大小最多是specSize指定的值。对应LayoutParams中的wrap_content。View的大小不能大于父容器的大小。</li><li>UNSPECIFIED ：不确定大小，父View完全依据子View的设计值来决定。系统不对View进行任何限制，要多大给多大，一般用于系统内部。</li></ul><p>具体详见2.2.2小节的图。</p><h3 id="2-2-2-MeasureSpec如何确定"><a href="#2-2-2-MeasureSpec如何确定" class="headerlink" title="2.2.2 MeasureSpec如何确定"></a>2.2.2 MeasureSpec如何确定</h3><ul><li>DecorView：通过屏幕大小和自身布局参数LayoutParams，只要将自身大小和屏幕大小相比，设置一个不超过屏幕大小的宽高和对应测量模式即可；</li><li>ViewGroup和View：需要通过父布局的MeasureSpec和自身的布局参数LayoutParams确定，具体如下：</li></ul><p>​<img src="https://uploadfiles.nowcoder.com/images/20231120/545613072_1700451472038/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><h2 id="2-3-ViewGroup的测量"><a href="#2-3-ViewGroup的测量" class="headerlink" title="2.3 ViewGroup的测量"></a>2.3 ViewGroup的测量</h2><p>上面说过ViewGroup需要测量其包含的子View的宽高后，根据子View宽高算出自身的宽高。所以在ViewGroup中定义了measureChildren(), measureChild(), measureChildWithMargins()方法来对子视图进行测量，measureChildren（）内部实质只是循环调用measureChild()。</p><pre><code class="java">//frameworks/base/core/java/android/view/ViewGroup.javaprotected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;    final int size = mChildrenCount;    final View[] children = mChildren;    for (int i = 0; i &lt; size; ++i) &#123;        final View child = children[i];        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;            measureChild(child, widthMeasureSpec, heightMeasureSpec); //调用measureChild()对子View进行测量        &#125;    &#125;&#125;protected void measureChild(View child, int parentWidthMeasureSpec,        int parentHeightMeasureSpec) &#123;    //获取子视图的LayoutParams    final LayoutParams lp = child.getLayoutParams();      //通过这两个参数以及子视图本身的LayoutParams来共同决定子视图的测量规格    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,            mPaddingLeft + mPaddingRight, lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,            mPaddingTop + mPaddingBottom, lp.height);    //继续调用子View的measure()方法，子View的measure()中会回调子View的onMeasure()方法，并最终调用到setMeasuredDimension()来设置宽高    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125;</code></pre><p>以上代码注释已经写的比较清楚了，关键看看getChildMeasureSpec()方法：</p><pre><code class="java">//frameworks/base/core/java/android/view/ViewGroup.javapublic static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;    int specMode = MeasureSpec.getMode(spec);    int specSize = MeasureSpec.getSize(spec);    int size = Math.max(0, specSize - padding);    int resultSize = 0;    int resultMode = 0;    switch (specMode) &#123;    // Parent has imposed an exact size on us    case MeasureSpec.EXACTLY:        if (childDimension &gt;= 0) &#123;            resultSize = childDimension;            resultMode = MeasureSpec.EXACTLY;        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;            // Child wants to be our size. So be it.            resultSize = size;            resultMode = MeasureSpec.EXACTLY;        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;            // Child wants to determine its own size. It can&#39;t be            // bigger than us.            resultSize = size;            resultMode = MeasureSpec.AT_MOST;        &#125;        break;    // Parent has imposed a maximum size on us    case MeasureSpec.AT_MOST: //a        if (childDimension &gt;= 0) &#123;            // Child wants a specific size... so be it            resultSize = childDimension;            resultMode = MeasureSpec.EXACTLY;        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;            // Child wants to be our size, but our size is not fixed.            // Constrain child to not be bigger than us.            resultSize = size;            resultMode = MeasureSpec.AT_MOST; //b        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;            // Child wants to determine its own size. It can&#39;t be            // bigger than us.            resultSize = size;            resultMode = MeasureSpec.AT_MOST; //c        &#125;        break;    // Parent asked to see how big we want to be    case MeasureSpec.UNSPECIFIED:        if (childDimension &gt;= 0) &#123;            // Child wants a specific size... let him have it            resultSize = childDimension;            resultMode = MeasureSpec.EXACTLY;        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;            // Child wants to be our size... find out how big it should            // be            resultSize = 0;            resultMode = MeasureSpec.UNSPECIFIED;        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;            // Child wants to determine its own size.... find out how            // big it should be            resultSize = 0;            resultMode = MeasureSpec.UNSPECIFIED;        &#125;        break;    &#125;    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125;</code></pre><p>代码逻辑也非常清楚，首先根据父控件的specMode模式，结合子控件的布局参数LayoutParams，最后得到子控件的MeasureSpec属性。有一点需要注意，如果父控件的MeasureSpec是AT_MOST，对应<code>[注释a]</code>​，无论子控件的布局参数是WRAP_CONTENT还是MATCH_PARENT，最终获得的子控件的specMode模式都是AT_MOST，即<code>[注释b-c]</code>​。因此，一般的解决方法是当布局参数是WRAP_CONTENT时，在onMeasure()方法里手动指定一下默认的宽和高：</p><pre><code class="java">@Override  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;      super.onMeasure(widthMeasureSpec, heightMeasureSpec);      int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);      int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);      int widthSpecSize=MeasureSpec.getSize(widthMeasureSpec);      int heightSpecSize=MeasureSpec.getSize(heightMeasureSpec);      if(widthSpecMode==MeasureSpec.AT_MOST&amp;&amp;heightSpecMode==MeasureSpec.AT_MOST)&#123;          setMeasuredDimension(400,400);      &#125;else if(widthSpecMode==MeasureSpec.AT_MOST)&#123;          setMeasuredDimension(400,heightSpecSize);      &#125;else if(heightSpecMode==MeasureSpec.AT_MOST)&#123;          setMeasuredDimension(widthSpecSize,400);      &#125;  &#125;</code></pre><h2 id="2-4-Measure总结"><a href="#2-4-Measure总结" class="headerlink" title="2.4 Measure总结"></a>2.4 Measure总结</h2><ul><li>measure过程主要就是从顶层父View向子View递归调用view.measure方法进行测量（measure()中又回调onMeasure()方法）的过程;</li><li>如果是ViewGroup则需执行要measure()并重写onMeasure()方法，在该方法中定义自己的测量方式，接着调用maesureChildren()方法遍历测量子View的宽高，最终根据子View宽高确定自己的宽高；</li><li>ViewGroup类提供了measureChild()，measureChildren()和measureChildWithMargins()方法，简化了父子View的尺寸计算；</li><li>如果是子View则调用measure() -》 onMeasure()方法完成自身的测量即可；</li><li>View的measure()方法是final修饰的，不能重写，只能重写onMeasure()方法完成自己的测量，且重写时不建议把宽高设置为死值；</li><li>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值。</li></ul><p>流程图（摘抄于参考文档2）如下： <img src="https://uploadfiles.nowcoder.com/images/20230128/545613072_1674904689454/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><h1 id="3、View绘制-Layout（布局）"><a href="#3、View绘制-Layout（布局）" class="headerlink" title="3、View绘制 - Layout（布局）"></a>3、View绘制 - Layout（布局）</h1><h2 id="3-1-Layout源码流程"><a href="#3-1-Layout源码流程" class="headerlink" title="3.1 Layout源码流程"></a>3.1 Layout源码流程</h2><p>将所有的View的宽高都计算好之后，就开始将所有的View进行布局了，即在Window摆放好所有View的位置，View的布局主要是通过确定上下左右四个关键点来确定其位置。值得一说的是，测量时，先测量子View的宽高，再测量父View的宽高。但是在布局时顺序则相反，是父View先确定自身的布局，再确认子View的布局。还是从<code>[注释3]</code>​的performLayout()方法开始看：</p><pre><code class="java">//frameworks/base/core/java/android/view/ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,         int desiredWindowHeight) &#123;     mLayoutRequested = false;     mScrollMayChange = true;     mInLayout = true;     final View host = mView;     if (host == null) &#123;         return;     &#125;         Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;);     try &#123;         ...         host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); //9         ...     &#125; finally &#123;         Trace.traceEnd(Trace.TRACE_TAG_VIEW);     &#125;     mInLayout = false; &#125;</code></pre><p>​<code>[注释9]</code>​的host其实是View类，因此会调用View.java里面的layout()方法。</p><pre><code class="java">//frameworks/base/core/java/android/view/View.javapublic void layout(int l, int t, int r, int b) &#123;      // 当前视图的四个顶点    int oldL = mLeft;      int oldT = mTop;      int oldB = mBottom;      int oldR = mRight;      // setFrame（） / setOpticalFrame（）：确定View自身的位置    // 即初始化四个顶点的值，然后判断当前View大小和位置是否发生了变化并返回   boolean changed = isLayoutModeOptical(mParent) ?            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); //10    //如果视图的大小和位置发生变化，会调用onLayout（）    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;          // onLayout（）：确定该View所有的子View在父容器的位置           onLayout(changed, l, t, r, b);      //11        ...    &#125;    ...&#125;</code></pre><p>上面代码有几个函数需要了解：</p><ul><li>setFrame()：确定View自身位置；</li><li>setOpticalFrame()：也是确定View自身位置，其内部也是通过调用setFrame()来实现；</li><li>onLayout()：确认该View里面的子View在父容器的位置，用protected修饰，在View.java文件里的onLayout()只是个空函数，需要子类进行重写。</li></ul><h2 id="3-2-LinearLayout的onLayout"><a href="#3-2-LinearLayout的onLayout" class="headerlink" title="3.2 LinearLayout的onLayout()"></a>3.2 LinearLayout的onLayout()</h2><p>如果当前的View是一个子View，则不需要重写onLayout()。但如果是一个ViewGroup，则先执行layout()方法 –〉setFrame()方法确定自己的位置，再通过重写onLayout()，其中的关键是循环调用child.layout()方法来确定子View在当前父容器的位置。我们看看LinearLayout的onLayout()：</p><pre><code class="java">//frameworks/base/core/java/android/widget/LinearLayout.java @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;     if (mOrientation == VERTICAL) &#123;         layoutVertical(l, t, r, b);  //如果是垂直布局，则调用layoutVertical()     &#125; else &#123;         layoutHorizontal(l, t, r, b);     &#125; &#125; void layoutVertical(int left, int top, int right, int bottom) &#123;     final int paddingLeft = mPaddingLeft;     int childTop;     int childLeft;     //计算子View个数     final int count = getVirtualChildCount();     ...     for (int i = 0; i &lt; count; i++) &#123;        final View child = getVirtualChildAt(i);        if (child == null) &#123;            childTop += measureNullChild(i);        &#125; else if (child.getVisibility() != GONE) &#123;            final int childWidth = child.getMeasureWidth();            final int childHeight = child.getMeasuredHeight();            final LinearLayout.LayoutParams lp =                     (LinearLayout.LayoutParams) child.getLayoutParams();            ...            if (hasDividerBeforeChildAt(i)) &#123;                childTop += mDividerHeight;            &#125;            childTop += lp.topMargin;            // 为子元素确定对应的位置            setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); //12            // childTop会逐渐增大，意味着后面的子元素会被放置在靠下的位置            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);            i += getChildrenSkipCount(child,i)        &#125;    &#125; &#125; private void setChildFrame(View child, int left, int top, int width, int height) &#123;     child.layout(left, top, left + width, top + height); //13 &#125;</code></pre><p>如果LinearLayout是垂直布局，则调用layoutVertical()。接着计算子View的个数，循环调用<code>[注释12]</code>​的setChildFrame()方法来确定子View在父容器的位置。从<code>[注释13]</code>​可以知道setChildFrame()方法其实就是调用子View的layout()方法。而子View会继续调用setFrame()方法确定自己的位置，在执行onLayout()方法，上面说过在View.java文件里的onLayout()只是个空函数，所以此时不会有具体实现。</p><h2 id="3-3-Layout流程图"><a href="#3-3-Layout流程图" class="headerlink" title="3.3 Layout流程图"></a>3.3 Layout流程图</h2><p>看看Layout的流程图加深理解(抄录于参考文档2): <img src="https://uploadfiles.nowcoder.com/images/20230128/545613072_1674904678253/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><h1 id="4、View绘制-Draw（绘制）"><a href="#4、View绘制-Draw（绘制）" class="headerlink" title="4、View绘制 - Draw（绘制）"></a>4、View绘制 - Draw（绘制）</h1><h2 id="4-1-Draw源码流程"><a href="#4-1-Draw源码流程" class="headerlink" title="4.1 Draw源码流程"></a>4.1 Draw源码流程</h2><p>每个View的宽高和位置都确定好后，就开始最后的绘制了，从<code>[注释4]</code>​performDraw()开始看：</p><pre><code class="java">//frameworks/base/core/java/android/view/ViewRootImpl.javaprivate void performDraw() &#123;    try &#123;        //执行draw()        boolean canUseAsync = draw(fullRedrawNeeded);    &#125; finally &#123;        mIsDrawing = false;        Trace.traceEnd(Trace.TRACE_TAG_VIEW);    &#125;&#125;private void draw(boolean fullRedrawNeeded) &#123;    ...    //执行drawSoftware()    if (!drawSoftware(surface, mAttachInfo, xOffest, yOffset,     scalingRequired, dirty)) &#123;        return;    &#125;    ...&#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scallingRequired, Rect dirty) &#123;    try &#123;        //最终执行了子View的draw()方法        mView.draw(canvas);    &#125; finally &#123;        if (!attachInfo.mSetIgnoreDirtyState) &#123;            // Only clear the flag if it was not set during the mView.draw() call            attachInfo.mIgnoreDirtyState = false;        &#125;    &#125;&#125;</code></pre><h2 id="4-2-Draw的步骤"><a href="#4-2-Draw的步骤" class="headerlink" title="4.2 Draw的步骤"></a>4.2 Draw的步骤</h2><p>通过源码可以追溯到，最终执行到了View.java里面的draw()方法。</p><pre><code class="java">    //frameworks/base/core/java/android/view/View.java    public void draw(Canvas canvas)    &#123;        /*         * Draw traversal performs several drawing steps which must be executed         * in the appropriate order:         *         *      1. Draw the background         *      2. If necessary, save the canvas&#39; layers to prepare for fading         *      3. Draw view&#39;s content         *      4. Draw children         *      5. If necessary, draw the fading edges and restore layers         *      6. Draw decorations (scrollbars for instance)         */        // Step 1, draw the background, if needed        int saveCount;        if (!dirtyOpaque) &#123;            drawBackground(canvas);        &#125;        // skip step 2 &amp; 5 if possible (common case)        final int viewFlags = mViewFlags;        boolean horizontalEdges =(viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;        boolean verticalEdges =(viewFlags &amp; FADING_EDGE_VERTICAL) != 0;        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;            // Step 3, draw the content            if (!dirtyOpaque) onDraw(canvas);            // Step 4, draw the children            dispatchDraw(canvas);            drawAutofilledHighlight(canvas);            // Overlay is part of the content and draws beneath Foreground            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;                mOverlay.getOverlayView().dispatchDraw(canvas);            &#125;            // Step 6, draw decorations (foreground, scrollbars)            onDrawForeground(canvas);            // Step 7, draw the default focus highlight            drawDefaultFocusHighlight(canvas);            if (debugDraw()) &#123;                debugDrawFocus(canvas);            &#125;            // we&#39;re done...            return;        &#125;    &#125;</code></pre><p>以上的源码里的官方注释，draw()方法有以下步骤：</p><ol><li>绘制View的背景；</li><li>如果有必要的话，保存画布的图层以准备fading；</li><li>绘制View的内容，即执行关键函数<code>onDraw()</code>​;</li><li>绘制子View；</li><li>如果有必要的话，绘制View的fading边缘并恢复图层；</li><li>绘制View的装饰（比如滚动条等等）</li><li>绘制默认焦点高亮</li></ol><p>无论是View还是ViewGroup，绘制的流程都是如此，还有两点需要了解：</p><ul><li>在ViewGroup中，实现了dispatchDraw()方法，而子View是不需要实现该方法的；</li><li>自定义View时，一般需要重写onDraw()方法，以绘制自己想要的样式，自定义View可见本系列《自定义View》一文。</li></ul><h2 id="4-3-Draw的流程图"><a href="#4-3-Draw的流程图" class="headerlink" title="4.3 Draw的流程图"></a>4.3 Draw的流程图</h2><p>看看Draw()的流程图加深理解(抄录于参考文档2): <img src="https://uploadfiles.nowcoder.com/images/20230128/545613072_1674904661835/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt">​</p><h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><ul><li>View的绘制有三大经典步骤：测量-布局-绘制，如果需要自定义View，可能需要重写onMeasure()方法，onLayout()方法，onDraw()方法；</li><li>测量时，先测量子View再根据子View大小，计算出父View的大小；</li><li>布局时，先布局好父View的位置，再布局子View的位置；</li><li>绘制时，先绘制背景，再绘制父View，最后绘制子View；</li></ul><p>‍</p><h3 id="6-为什么onCreate获取不到View的宽高"><a href="#6-为什么onCreate获取不到View的宽高" class="headerlink" title="6 为什么onCreate获取不到View的宽高"></a>6 为什么onCreate获取不到View的宽高</h3><p>Activity在执行完oncreate，onResume之后才创建ViewRootImpl,ViewRootImpl进行View的绘制工作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;View&quot;&gt;&lt;a href=&quot;#View&quot; class=&quot;headerlink&quot; title=&quot;View&quot;&gt;&lt;/a&gt;View&lt;/h1&gt;&lt;p&gt;绘制View有三个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Measure：测量视图的高低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>ArrayList扩容机制</title>
    <link href="http://example.com/2022/12/04/Java/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/12/04/Java/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-04T08:22:33.000Z</published>
    <updated>2023-12-10T08:57:47.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h1><h1 id="ArrayList-有三种方式来初始化，构造方法源码如下（JDK8）："><a href="#ArrayList-有三种方式来初始化，构造方法源码如下（JDK8）：" class="headerlink" title="ArrayList 有三种方式来初始化，构造方法源码如下（JDK8）："></a>ArrayList 有三种方式来初始化，构造方法源码如下（JDK8）：</h1><pre><code class="java">/** * 默认初始容量大小 */private static final int DEFAULT_CAPACITY = 10;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * 默认构造函数，使用初始容量10构造一个空列表(无参数构造) */public ArrayList() &#123;    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * 带初始容量参数的构造函数。（用户自己指定容量） */public ArrayList(int initialCapacity) &#123;    if (initialCapacity &gt; 0) &#123;//初始容量大于0        //创建initialCapacity大小的数组        this.elementData = new Object[initialCapacity];    &#125; else if (initialCapacity == 0) &#123;//初始容量等于0        //创建空数组        this.elementData = EMPTY_ELEMENTDATA;    &#125; else &#123;//初始容量小于0，抛出异常        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity);    &#125;&#125;/** *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 *如果指定的集合为null，throws NullPointerException。 */public ArrayList(Collection&lt;? extends E&gt; c) &#123;    elementData = c.toArray();    if ((size = elementData.length) != 0) &#123;        // c.toArray might (incorrectly) not return Object[] (see 6260652)        if (elementData.getClass() != Object[].class)            elementData = Arrays.copyOf(elementData, size, Object[].class);    &#125; else &#123;        // replace with empty array.        this.elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><p><strong>以无参数构造方法创建 ** <strong><code>ArrayList</code></strong> ** 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h4><pre><code class="java">/*** 将指定的元素追加到此列表的末尾。*/public boolean add(E e) &#123;    // 加元素之前，先调用ensureCapacityInternal方法    ensureCapacityInternal(size + 1);  // Increments modCount!!    // 这里看到ArrayList添加元素的实质就相当于为数组赋值    elementData[size++] = e;    return true;&#125;</code></pre><h2 id="ensureCapacityInternal​-方法的源码如下："><a href="#ensureCapacityInternal​-方法的源码如下：" class="headerlink" title="ensureCapacityInternal​ 方法的源码如下："></a><code>ensureCapacityInternal</code>​ 方法的源码如下：</h2><pre><code class="java">// 根据给定的最小容量和当前数组元素来计算所需容量。private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;    // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        return Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    // 否则直接返回最小容量    return minCapacity;&#125;// 确保内部容量达到指定的最小容量。private void ensureCapacityInternal(int minCapacity) &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;</code></pre><p>​<code>ensureCapacityInternal</code>​ 方法非常简单，内部直接调用了 <code>ensureExplicitCapacity</code>​ 方法：</p><pre><code class="java">//判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123;    modCount++;    //判断当前数组容量是否足以存储minCapacity个元素    if (minCapacity - elementData.length &gt; 0)        //调用grow方法进行扩容        grow(minCapacity);&#125;</code></pre><ul><li>当我们要 <code>add</code>​ 进第 1 个元素到 <code>ArrayList</code>​ 时，<code>elementData.length</code>​ 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code>​ 方法 ，所以 <code>minCapacity</code>​ 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>​成立，所以会进入 <code>grow(minCapacity)</code>​ 方法。</li><li>当 <code>add</code>​ 第 2 个元素时，<code>minCapacity</code>​ 为 2，此时 <code>elementData.length</code>​(容量)在添加第一个元素后扩容成 <code>10</code>​ 了。此时，<code>minCapacity - elementData.length &gt; 0</code>​ 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code>​ 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li><li>直到添加第 11 个元素，<code>minCapacity</code>​(为 11)比 <code>elementData.length</code>​（为 10）要大。进入 <code>grow</code>​ 方法进行扩容。</li></ul><hr><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a>grow 方法</h4><pre><code class="java">/** * 要分配的最大数组大小 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) &#123;    // oldCapacity为旧容量，newCapacity为新容量    int oldCapacity = elementData.length;    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，    // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p>​**<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>** ​ <strong>,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong>  奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.—</p><p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a href="https://javaguide.cn/java/collection/arraylist-source-code.html">https://javaguide.cn/java/collection/arraylist-source-code.html</a></p><ul><li>当 <code>add</code>​ 第 1 个元素时，<code>oldCapacity</code>​ 为 0，经比较后第一个 if 判断成立，<code>newCapacity = minCapacity</code>​(为 10)。但是第二个 if 判断不会成立，即 <code>newCapacity</code>​ 不比 <code>MAX_ARRAY_SIZE</code>​ 大，则不会进入 <code>hugeCapacity</code>​ 方法。数组容量为 10，<code>add</code>​ 方法中 return true,size 增为 1。</li><li>当 <code>add</code>​ 第 11 个元素进入 <code>grow</code>​ 方法时，<code>newCapacity</code>​ 为 15，比 <code>minCapacity</code>​（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 huge<code>C</code>​apacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>以此类推······</li></ul><hr><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ArrayList扩容机制&quot;&gt;&lt;a href=&quot;#ArrayList扩容机制&quot; class=&quot;headerlink&quot; title=&quot;ArrayList扩容机制&quot;&gt;&lt;/a&gt;ArrayList扩容机制&lt;/h1&gt;&lt;h1 id=&quot;ArrayList-有三种方式来初始化，构</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="http://example.com/2022/10/04/%E9%83%A8%E7%BD%B2/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2022/10/04/%E9%83%A8%E7%BD%B2/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2022-10-04T07:46:33.000Z</published>
    <updated>2023-12-07T09:01:50.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><h3 id="三种常见方式"><a href="#三种常见方式" class="headerlink" title="三种常见方式"></a>三种常见方式</h3><ol><li>使用session广播机制实现      session复制 会导致空间浪费（不在用）</li><li>使用cookie + redis实现</li><li>使用token实现</li></ol><h2 id="cookie-redis"><a href="#cookie-redis" class="headerlink" title="cookie + redis"></a>cookie + redis</h2><ol><li><p>在项目中任何一个模块进行登录，登录之后，把数据放到两个地方</p><p> 1.1 redis：在key：生成唯一随机值，在value： 用户数据</p><p> 1.2 cookie：把redis里面生成的key值放到cookie中</p></li><li><p>访问项目中其他模块时，发送请求带着cookie发送，获取cookie值，拿着cookie做事情</p><p> 2.1 把cookie获取值，到redis进行查询，根据key进行查询，如果查询到数据就是登录</p></li></ol><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token:按照一定规制生成字符串，字符串可以包含用户信息</p><ol><li><p>在项目的某个模块中进行登录，登录之后，按照规则生成字符串，把登录之后的用户包含到字符串里面，把字符串返回</p><p> 1.1 可以把字符串通过cookie返回</p><p> 1.2 把字符串通过地址栏返回</p></li><li><p>再去访问项目其他模块，每次访问都在地址栏带着生成字符串，在访问模块里面获取地址栏字符串，根据字符串获取用户信息，如果可以获取到就是登录</p></li></ol><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单点登录&quot;&gt;&lt;a href=&quot;#单点登录&quot; class=&quot;headerlink&quot; title=&quot;单点登录&quot;&gt;&lt;/a&gt;单点登录&lt;/h1&gt;&lt;h3 id=&quot;三种常见方式&quot;&gt;&lt;a href=&quot;#三种常见方式&quot; class=&quot;headerlink&quot; title=&quot;三种常见方</summary>
      
    
    
    
    <category term="部署" scheme="http://example.com/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Clash for windows 配置</title>
    <link href="http://example.com/2022/10/04/%E9%85%8D%E7%BD%AE/Clash%20for%20windows%20%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/10/04/%E9%85%8D%E7%BD%AE/Clash%20for%20windows%20%E9%85%8D%E7%BD%AE/</id>
    <published>2022-10-04T07:46:33.000Z</published>
    <updated>2023-12-07T09:38:17.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clash-for-windows-配置"><a href="#Clash-for-windows-配置" class="headerlink" title="Clash for windows 配置"></a>Clash for windows 配置</h1><h3 id="1、-去下载冲突软件最新版本，下载地址-https-github-com-Fndroid-clash-for-windows-pkg-x2F-releases"><a href="#1、-去下载冲突软件最新版本，下载地址-https-github-com-Fndroid-clash-for-windows-pkg-x2F-releases" class="headerlink" title="1、 去下载冲突软件最新版本，下载地址: https://github.com/Fndroid/clash_for_windows_pkg&#x2F;releases"></a>1、 去下载冲突软件最新版本，下载地址: <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg&#x2F;releases</a></h3><p>​<img src="/images/clash/image-20231207112317-nz9p7hj.png" alt="image">​</p><h3 id="2、-下载下来直接安装"><a href="#2、-下载下来直接安装" class="headerlink" title="2、 下载下来直接安装"></a>2、 下载下来直接安装</h3><p>​<img src="/images/clash/image-20231207112351-c97xwwi.png" alt="image">​</p><h3 id="3、打开页面，默认是英文的"><a href="#3、打开页面，默认是英文的" class="headerlink" title="3、打开页面，默认是英文的"></a>3、打开页面，默认是英文的</h3><p>​<img src="/images/clash/image-20231207112418-v4gqzub.png" alt="image">​</p><h3 id="下载汉化包"><a href="#下载汉化包" class="headerlink" title="下载汉化包"></a>下载汉化包</h3><h4 id="1、-下载汉化包下载汉化包-https-github-com-ender-zhao-Clash-for-Windows-Chinese-x2F-releases"><a href="#1、-下载汉化包下载汉化包-https-github-com-ender-zhao-Clash-for-Windows-Chinese-x2F-releases" class="headerlink" title="1、 下载汉化包下载汉化包: https://github.com/ender-zhao/Clash-for-Windows_Chinese&#x2F;releases"></a>1、 下载汉化包下载汉化包: <a href="https://github.com/ender-zhao/Clash-for-Windows_Chinese/releases">https://github.com/ender-zhao/Clash-for-Windows_Chinese&#x2F;releases</a></h4><p>​<img src="/images/clash/image-20231207112543-37mxt8m.png" alt="image">​</p><h4 id="2、关闭退出刚刚打开的clash软件，打开clash软件的文件夹，找到resources文件并打开，把刚刚下载的汉化包asar给拖进去替换掉"><a href="#2、关闭退出刚刚打开的clash软件，打开clash软件的文件夹，找到resources文件并打开，把刚刚下载的汉化包asar给拖进去替换掉" class="headerlink" title="2、关闭退出刚刚打开的clash软件，打开clash软件的文件夹，找到resources文件并打开，把刚刚下载的汉化包asar给拖进去替换掉"></a>2、关闭退出刚刚打开的clash软件，打开clash软件的文件夹，找到resources文件并打开，把刚刚下载的汉化包asar给拖进去替换掉</h4><p>​<img src="/images/clash/image-20231207112645-bs4tpbr.png" alt="image">​</p><h4 id="3、在次打开小猫咪clash软件，就是汉化版的了，对于英文不是很好的同学还是解决了一个不错的问题，当然也有出现汉化后打不开系统代理System-Proxy这个按钮的情况，那这个时候只能把Clash文件夹里所有的文件删除，重新下载解压Clash软件，老老实实的用英文版。"><a href="#3、在次打开小猫咪clash软件，就是汉化版的了，对于英文不是很好的同学还是解决了一个不错的问题，当然也有出现汉化后打不开系统代理System-Proxy这个按钮的情况，那这个时候只能把Clash文件夹里所有的文件删除，重新下载解压Clash软件，老老实实的用英文版。" class="headerlink" title="3、在次打开小猫咪clash软件，就是汉化版的了，对于英文不是很好的同学还是解决了一个不错的问题，当然也有出现汉化后打不开系统代理System Proxy这个按钮的情况，那这个时候只能把Clash文件夹里所有的文件删除，重新下载解压Clash软件，老老实实的用英文版。"></a>3、在次打开小猫咪clash软件，就是汉化版的了，对于英文不是很好的同学还是解决了一个不错的问题，当然也有出现汉化后打不开系统代理System Proxy这个按钮的情况，那这个时候只能把Clash文件夹里所有的文件删除，重新下载解压Clash软件，老老实实的用英文版。</h4><p>​<img src="/images/clash/image-20231207112654-cjo2n7g.png" alt="image">​</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Clash-for-windows-配置&quot;&gt;&lt;a href=&quot;#Clash-for-windows-配置&quot; class=&quot;headerlink&quot; title=&quot;Clash for windows 配置&quot;&gt;&lt;/a&gt;Clash for windows 配置&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="配置" scheme="http://example.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>内网穿透 frp</title>
    <link href="http://example.com/2022/10/04/%E9%85%8D%E7%BD%AE/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%20frp/"/>
    <id>http://example.com/2022/10/04/%E9%85%8D%E7%BD%AE/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%20frp/</id>
    <published>2022-10-04T02:22:34.000Z</published>
    <updated>2023-12-10T08:58:22.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网穿透-frp"><a href="#内网穿透-frp" class="headerlink" title="内网穿透 frp"></a>内网穿透 frp</h1><h1 id="1、阿里云配置"><a href="#1、阿里云配置" class="headerlink" title="1、阿里云配置"></a>1、阿里云配置</h1><p>首先到frp的release界面下载适合自己电脑的程序<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a> 可以直接去这个页面下载</p><p>也可以通过wget命令下载</p><pre><code class="java">wget https://github.com/fatedier/frp/releases/download/v0.32.1/frp_0.32.1_linux_amd64.tar.gz</code></pre><p>然后解压</p><pre><code class="java">tar -zxvf  frp_0.32.1_linux_amd64.tar.gz</code></pre><p>然后进入cd到frp_0.32.1_linux_amd64目录，对于服务端的配置可以直接先将frpc和frpc.ini文件删除，之后配置frps.ini</p><pre><code class="java">[common]bind_port = 7000           #与客户端绑定的进行通信的端口</code></pre><p>保存后就可以启动服务端了</p><pre><code class="java"># 前台启动./frps -c ./frps.ini    # 后台启动（正常使用后推荐后台启动）nohup ./frps -c ./frps.ini &amp;</code></pre><h1 id="2、frp客户端（实验室服务器）配置"><a href="#2、frp客户端（实验室服务器）配置" class="headerlink" title="2、frp客户端（实验室服务器）配置"></a>2、<strong>frp客户端（实验室服务器）配置</strong></h1><p>首先还是程序下载并解压</p><pre><code class="java">wget https://github.com/fatedier/frp/releases/download/v0.32.1/frp_0.32.1_linux_amd64.tar.gz tar -zxvf  frp_0.32.1_linux_amd64.tar.gz</code></pre><p>然后进入cd到frp_0.32.1_linux_amd64目录，对于客户端的配置可以直接先将frps和frps.ini文件删除，之后配置frpc.ini</p><pre><code class="java"> [common]server_addr = 106.15.333.9  # 公网服务器ipserver_port = 7000          # 与服务端bind_port一致  #公网通过ssh访问内部服务器[ssh]type = tcp               # 连接协议local_ip = 192.168.3.48  # 内网服务器ip(127.0.0.1也行)local_port = 22          # ssh默认端口号remote_port = 6000       # 自定义的访问内部ssh端口号 # 解释一下local_port和remote_port# 我们ssh访问的是公网ip，remote_port是公网服务器的port，访问remote_port后会转发到local_port</code></pre><p>保存后就可以启动客户端了</p><pre><code class="java"># 前台启动./frpc -c ./frpc.ini    # 后台启动（正常使用后推荐后台启动）nohup ./frpc -c ./frpc.ini &amp;</code></pre><h1 id="3、ssh远程连接内网服务器"><a href="#3、ssh远程连接内网服务器" class="headerlink" title="3、ssh远程连接内网服务器"></a>3、<strong>ssh远程连接内网服务器</strong></h1><pre><code class="java">ssh -p remote_port username@公网ip # 举例ssh -p 7000 horizon@106.15.333.9</code></pre><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内网穿透-frp&quot;&gt;&lt;a href=&quot;#内网穿透-frp&quot; class=&quot;headerlink&quot; title=&quot;内网穿透 frp&quot;&gt;&lt;/a&gt;内网穿透 frp&lt;/h1&gt;&lt;h1 id=&quot;1、阿里云配置&quot;&gt;&lt;a href=&quot;#1、阿里云配置&quot; class=&quot;header</summary>
      
    
    
    
    <category term="配置" scheme="http://example.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Dataway</title>
    <link href="http://example.com/2022/08/16/%E9%83%A8%E7%BD%B2/Dataway/"/>
    <id>http://example.com/2022/08/16/%E9%83%A8%E7%BD%B2/Dataway/</id>
    <published>2022-08-15T23:25:30.000Z</published>
    <updated>2023-12-07T08:21:19.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dataway"><a href="#Dataway" class="headerlink" title="Dataway"></a>Dataway</h1><pre><code>Dataway 是基于 DataQL 服务聚合能力，为应用提供的一个接口配置工具，使得使用者无需开发任何代码就配置一个满足需求的接口。整个接口配置、测试、冒烟、发布，一站式都通过 Dataway 提供的 UI 界面完成。UI 会以 Jar 包方式提供并集成到应用中并和应用共享同一个 http 端口，应用无需单独为 Dataway 开辟新的管理端口。这种内嵌集成方式模式的优点是，可以使得大部分老项目都可以在无侵入的情况下直接应用 Dataway。进而改进老项目的迭代效率，大大减少企业项目研发成本。Dataway 工具化的提供 DataQL 配置能力。这种研发模式的变革使得，相当多的需求开发场景只需要配置即可完成交付。从而避免了从数据存取到前端接口之间的一系列开发任务，例如：Mapper、BO、VO、DO、DAO、Service、Controller 统统不在需要。Dataway 是 Hasor 生态中的一员，因此在 Spring 中使用 Dataway 首先要做的就是打通两个生态。根据官方文档中推荐的方式我们将 Hasor 和 Spring Boot 整合起来。</code></pre><h4 id="第一步：-引入相关依赖"><a href="#第一步：-引入相关依赖" class="headerlink" title="第一步： 引入相关依赖"></a>第一步： 引入相关依赖</h4><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;    &lt;version&gt;4.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;    &lt;version&gt;4.1.3-fix20200414&lt;/version&gt;&lt;!-- 4.1.3 包存在UI资源缺失问题 --&gt;&lt;/dependency&gt;</code></pre><p>hasor-spring 负责 Spring 和 Hasor 框架之间的整合。hasor-dataway 是工作在 Hasor 之上，利用 hasor-spring 我们就可以使用 dataway了。</p><h4 id="第二步：配置Dataway-并初始化数据表"><a href="#第二步：配置Dataway-并初始化数据表" class="headerlink" title="第二步：配置Dataway,并初始化数据表"></a>第二步：配置Dataway,并初始化数据表</h4><p>dataway 会提供一个界面让我们配置接口，这一点类似 Swagger 只要jar包集成就可以实现接口配置。找到我们 springboot 项目的配置文件 application.properties</p><pre><code class="java"># 是否启用 Dataway 功能（必选：默认false）HASOR_DATAQL_DATAWAY=true# 是否开启 Dataway 后台管理界面（必选：默认false）HASOR_DATAQL_DATAWAY_ADMIN=true# dataway  API工作路径（可选，默认：/api/）HASOR_DATAQL_DATAWAY_API_URL=/api/# dataway-ui 的工作路径（可选，默认：/interface-ui/）HASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/# SQL执行器方言设置（可选，建议设置）HASOR_DATAQL_FX_PAGE_DIALECT=mysql</code></pre><p>Dataway 一共涉及到 5个可以配置的配置项，但不是所有配置都是必须的。</p><p>其中 HASOR_DATAQL_DATAWAY、HASOR_DATAQL_DATAWAY_ADMIN 两个配置是必须要打开的，默认情况下 Datawaty 是不启用的。</p><p>Dataway 需要两个数据表才能工作，下面是这两个数据表的简表语句。下面这个 SQL 可以在 dataway的依赖 jar 包中 “META-INF&#x2F;hasor-framework&#x2F;mysql” 目录下面找到，建表语句是用 mysql 语法写的。</p><pre><code class="sql">CREATE TABLE `interface_info` (    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;ID&#39;,    `api_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `api_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `api_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0草稿，1发布，2有变更，3禁用&#39;,    `api_comment`     varchar(255)     NULL                  COMMENT &#39;注释&#39;,    `api_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `api_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `api_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `api_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,    PRIMARY KEY (`api_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway 中的API&#39;;CREATE TABLE `interface_release` (    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;Publish ID&#39;,    `pub_api_id`      int(11)      NOT NULL                  COMMENT &#39;所属API ID&#39;,    `pub_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `pub_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `pub_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0有效，1无效（可能被下线）&#39;,    `pub_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `pub_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT &#39;原始查询脚本，仅当类型为SQL时不同&#39;,    `pub_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `pub_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;发布时间（下线不更新）&#39;,    PRIMARY KEY (`pub_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway API 发布历史。&#39;;create index idx_interface_release on interface_release (pub_api_id);</code></pre><h4 id="第三步：-配置数据源"><a href="#第三步：-配置数据源" class="headerlink" title="第三步： 配置数据源"></a>第三步： 配置数据源</h4><p>作为 Spring Boot 项目有着自己完善的数据库方面工具支持。我们这次采用 druid + mysql + spring-boot-starter-jdbc 的方式。</p><p>首先引入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后添加数据源的配置</p><pre><code class="java"># dbspring.datasource.url=jdbc:mysql://xxxxxxx:3306/examplespring.datasource.username=xxxxxspring.datasource.password=xxxxxspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type:com.alibaba.druid.pool.DruidDataSource# druidspring.datasource.druid.initial-size=3spring.datasource.druid.min-idle=3spring.datasource.druid.max-active=10spring.datasource.druid.max-wait=60000spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=adminspring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=1</code></pre><p>如果项目已经集成了自己的数据源，那么可以忽略第三步。</p><h4 id="第四步：把数据源设置到Hasor容器中"><a href="#第四步：把数据源设置到Hasor容器中" class="headerlink" title="第四步：把数据源设置到Hasor容器中"></a>第四步：把数据源设置到Hasor容器中</h4><p>Spring Boot 和 Hasor 本是两个独立的容器框架，我们做整合之后为了使用 Dataway 的能力需要把 Spring 中的数据源设置到 Hasor 中。</p><p>首先新建一个 Hasor 的 模块，并且将其交给 Spring 管理。然后把数据源通过 Spring 注入进来。</p><pre><code class="java">@DimModule@Componentpublic class ExampleModule implements SpringModule &#123;    @Autowired    private DataSource dataSource = null;    @Override    public void loadModule(ApiBinder apiBinder) throws Throwable &#123;        // .DataSource form Spring boot into Hasor        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));    &#125;&#125;</code></pre><p>Hasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。</p><h4 id="第五步：-在springboot中启用Hasor"><a href="#第五步：-在springboot中启用Hasor" class="headerlink" title="第五步： 在springboot中启用Hasor"></a>第五步： 在springboot中启用Hasor</h4><pre><code class="java">@EnableHasor()@EnableHasorWeb()@SpringBootApplication(scanBasePackages = &#123; &quot;net.example.hasor&quot; &#125;)public class ExampleApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ExampleApplication.class, args);    &#125;&#125;</code></pre><p>这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。</p><h4 id="第六步：启动应用"><a href="#第六步：启动应用" class="headerlink" title="第六步：启动应用"></a>第六步：启动应用</h4><p>应用在启动过程中会看到 Hasor Boot 的欢迎信息</p><pre><code class="java"> _    _                        ____              _| |  | |                      |  _ \            | || |__| | __ _ ___  ___  _ __  | |_) | ___   ___ | |_|  __  |/ _` / __|/ _ \| &#39;__| |  _ &lt; / _ \ / _ \| __|| |  | | (_| \__ \ (_) | |    | |_) | (_) | (_) | |_|_|  |_|\__,_|___/\___/|_|    |____/ \___/ \___/ \__|</code></pre><p>在后面的日志中还可以看到类似下面这些日志。</p><pre><code class="java">2023-05-18 13:52:59.696 [main] INFO  n.h.core.context.TemplateAppContext - loadModule class net.hasor.dataway.config.DatawayModule2023-05-18 13:52:59.697 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway api workAt /api/2023-05-18 13:52:59.697 [main] INFO  n.h.c.e.AbstractEnvironment - var -&gt; HASOR_DATAQL_DATAWAY_API_URL = /api/.2023-05-18 13:52:59.704 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway admin workAt /interface-ui/2023-05-18 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[901d38f22faa419a8593bb349905ed0e] -&gt; bindType ‘class net.hasor.dataway.web.ApiDetailController’ mappingTo: ‘[/interface-ui/api/api-detail]’.2023-05-18 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[c6eb9f3b3d4c4c8d8a4f807435538172] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryListController’ mappingTo: ‘[/interface-ui/api/api-history]’.2023-05-18 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[eb841dc72ad54023957233ef602c4327] -&gt; bindType ‘class net.hasor.dataway.web.ApiInfoController’ mappingTo: ‘[/interface-ui/api/api-info]’.2023-05-18 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[96aebb46265245459ae21d558e530921] -&gt; bindType ‘class net.hasor.dataway.web.ApiListController’ mappingTo: ‘[/interface-ui/api/api-list]’.2023-05-18 13:52:59.718 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7467c07f160244df8f228321f6262d3d] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryGetController’ mappingTo: ‘[/interface-ui/api/get-history]’.2023-05-18 13:52:59.719 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[97d8da5363c741ba99d87c073a344412] -&gt; bindType ‘class net.hasor.dataway.web.DisableController’ mappingTo: ‘[/interface-ui/api/disable]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[8ddc3316ef2642dfa4395ca8ac0fff04] -&gt; bindType ‘class net.hasor.dataway.web.SmokeController’ mappingTo: ‘[/interface-ui/api/smoke]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[cc06c5fb343b471aacedc58fb2fe7bf8] -&gt; bindType ‘class net.hasor.dataway.web.SaveApiController’ mappingTo: ‘[/interface-ui/api/save-api]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7915b2b1f89a4e73891edab0264c9bd4] -&gt; bindType ‘class net.hasor.dataway.web.PublishController’ mappingTo: ‘[/interface-ui/api/publish]’.2023-05-18 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[0cfa34586455414591bdc389bff23ccb] -&gt; bindType ‘class net.hasor.dataway.web.PerformController’ mappingTo: ‘[/interface-ui/api/perform]’.2023-05-18 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[37fe4af3e2994acb8deb72d21f02217c] -&gt; bindType ‘class net.hasor.dataway.web.DeleteController’ mappingTo: ‘[/interface-ui/api/delete]’.</code></pre><p>当看到 “dataway api workAt &#x2F;api&#x2F;” 、 dataway admin workAt &#x2F;interface-ui&#x2F; 信息时，就可以确定 Dataway 的配置已经生效了。</p><h4 id="第七步：访问接口管理页面进行接口配置"><a href="#第七步：访问接口管理页面进行接口配置" class="headerlink" title="第七步：访问接口管理页面进行接口配置"></a>第七步：访问接口管理页面进行接口配置</h4><p>在浏览器中输入 “<a href="http://127.0.0.1:8080/interface-ui/%E2%80%9D">http://127.0.0.1:8080/interface-ui/”</a> 就可以看到期待已久的界面了。</p><p>​<img src="/images/dataway_01-20230725172609-ps05uve.png" alt="dataway_01">​</p><h4 id="第八步：-新建一个接口"><a href="#第八步：-新建一个接口" class="headerlink" title="第八步： 新建一个接口"></a>第八步： 新建一个接口</h4><p>Dataway 提供了2中语言模式，我们可以使用强大的 DataQL 查询语言，也可以直接使用 SQL 语言（在 Dataway 内部 SQL 语言也会被转换为 DataQL 的形式执行。）</p><p>​<img src="/images/dataway_02-20230725172622-doddtt6.png" alt="dataway_02">​</p><p>首先我们在 SQL 模式下尝试执行一条 select 查询，立刻就可以看到这条 SQL 的查询结果。</p><p>​<img src="/images/dataway_03-20230725172638-uv4y73g.png" alt="dataway_03">​</p><p>同样的方式我们使用 DataQL 的方式需要这样写：</p><pre><code class="java">var query = @@sql()&lt;%    select * from interface_info%&gt;return query()</code></pre><p>其中 var query &#x3D; @@sql()&lt;% … %&gt; 是用来定义SQL外部代码块，并将这个定义存入 query 变量名中。&lt;% %&gt; 中间的就是 SQL 语句。</p><p>最后在 DataQL 中调用这个代码块，并返回查询结果。</p><p>当接口写好之后就可以保存发布了，为了测试方便，我选用 GET 方式。</p><p>​<img src="/images/dataway_04-20230725172731-a2q09dl.png" alt="dataway_04">​</p><p>接口发布之后我们直接请求：<a href="http://127.0.0.1:8080/api/demos%EF%BC%8C%E5%B0%B1%E7%9C%8B%E5%88%B0%E6%9C%9F%E5%BE%85%E5%B7%B2%E4%B9%85%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BA%86%E3%80%82">http://127.0.0.1:8080/api/demos，就看到期待已久的接口返回值了。</a></p><p>​<img src="/images/dataway_05-20230725172743-p1b6cbj.png" alt="dataway_05">​</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>经过上面的几个步骤我们介绍了如何基于 Spring Boot 项目使用 Dataway 来简单的配置接口。Dataway 的方式确实给人耳目一新，一个接口竟然可以如此简单的配置出来无需开发任何一行代码，也不需要做任何 Mapping 实体映射绑定。</p><p>‍</p><h4 id="最后放几个有用的链接："><a href="#最后放几个有用的链接：" class="headerlink" title="最后放几个有用的链接："></a>最后放几个有用的链接：</h4><ul><li><p>Dataway官方手册：</p><p>​<code>https://www.hasor.net/web/dataway/about.html</code>​​</p></li><li><p>Dataway 在 OSC 上的项目地址，欢迎收藏：</p><p><a href="https://www.oschina.net/p/dataway">https://www.oschina.net/p/dataway</a></p></li><li><p>DataQL 手册地址：</p><p><a href="https://www.hasor.net/web/dataql/what_is_dataql.html">https://www.hasor.net/web/dataql/what_is_dataql.html</a></p></li><li><p>Hasor 项目的首页：</p><p><a href="https://www.hasor.net/web/index.html">https://www.hasor.net/web/index.html</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dataway&quot;&gt;&lt;a href=&quot;#Dataway&quot; class=&quot;headerlink&quot; title=&quot;Dataway&quot;&gt;&lt;/a&gt;Dataway&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Dataway 是基于 DataQL 服务聚合能力，为应用提供的一个接口配置工具，使</summary>
      
    
    
    
    <category term="配置" scheme="http://example.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
</feed>
