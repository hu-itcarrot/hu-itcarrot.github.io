<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/12/07/Java/index/"/>
      <url>/2023/12/07/Java/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/08/18/MySQL/"/>
      <url>/2023/08/18/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h1 id="1-优化"><a href="#1-优化" class="headerlink" title="1 优化"></a>1 优化</h1><h2 id="1-1-在MySQL中，如何定位慢查询？"><a href="#1-1-在MySQL中，如何定位慢查询？" class="headerlink" title="1.1 在MySQL中，如何定位慢查询？"></a>1.1 在MySQL中，如何定位慢查询？</h2><p>方案一： 开源工具</p><ol><li>调式工具：Arthas</li><li>运维工具： Prometheus , Skywalking</li></ol><p>方案二：MySQL 自带慢日志</p><pre><code>慢查询日志记录了所有的执行时间超过指定参数的所有SQL语句的日志如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf)中配置如下信息：</code></pre><pre><code class="mysql">#开启MySQL慢日志开关slow_query_log = 1 # 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time = 2 </code></pre><p>配置完成后，通过重启mysql</p><p>‍</p><h2 id="1-2-SQL语句执行很慢，如何分析？"><a href="#1-2-SQL语句执行很慢，如何分析？" class="headerlink" title="1.2 SQL语句执行很慢，如何分析？"></a>1.2 SQL语句执行很慢，如何分析？</h2><p>可以采用EXPLAIN或者DESC命令获取MySQL如何执行信息。</p><p>‍</p><p>‍</p><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2 索引"></a>2 索引</h2><p><strong>索引（ index ）</strong>是帮助 MySQL 高效获取数据的数据结构 ( 有序 ) 。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（ B+ 树），这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>mysql主要是是使用B+树作为索引</p><p>B-Tree ， B 树是一种多叉路衡查找树，相对于二叉树， B 树每个节点可以有多个分支，即多叉。</p><p>以一颗最大度数（ max-degree ）为 5(5 阶 ) 的 b-tree 为例，那这个 B 树每个节点最多存储 4 个 key</p><p>​<img src="/images/MySQL/image-20230813164649-bjlcuem.png" alt="image">​</p><p>B+树是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+ Tree实现其索引结构</p><p>​<img src="/images/MySQL/image-20230813164943-76leq0k.png" alt="image">​</p><p>B树和B+树的对比：</p><ol><li>磁盘读写代价B+树更低</li><li>查询效率B+更加稳定</li><li>B+ 树便于扫库和区间查询</li></ol><h3 id="2-1-什么是聚簇索引？什么是非聚簇索引？"><a href="#2-1-什么是聚簇索引？什么是非聚簇索引？" class="headerlink" title="2.1 什么是聚簇索引？什么是非聚簇索引？"></a>2.1 什么是聚簇索引？什么是非聚簇索引？</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>非聚集索引</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则：</p><ol><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一索引作为聚集索引</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ol><p>​<img src="/images/MySQL/image-20230813170234-9pfai8v.png" alt="image"></p><p>​<img src="/images/MySQL/image-20230813170349-vq8skek.png" alt="image">​​</p><h3 id="2-2-什么叫做覆盖索引？"><a href="#2-2-什么叫做覆盖索引？" class="headerlink" title="2.2 什么叫做覆盖索引？"></a>2.2 什么叫做覆盖索引？</h3><p><strong>覆盖索引</strong>是指查询使用了索引，并且需要返回的列在该索引中已经全部能够找到。</p><p>​<img src="/images/MySQL/image-20230813170710-mm25rxx.png" alt="image">​</p><p>使用覆盖索引进行超大分页处理。</p><p>​<img src="/images/MySQL/image-20230813171306-jyp7qsv.png" alt="image">​</p><h3 id="2-3-索引创建原则有哪些？"><a href="#2-3-索引创建原则有哪些？" class="headerlink" title="2.3 索引创建原则有哪些？"></a>2.3 索引创建原则有哪些？</h3><ol><li>针对数据量较大，且查询比较复杂的表建立索引。    单表超过10万数据</li><li>针对常作为查询条件(where) 、排序（order by) 、分组（group by) 操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代码就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确认哪个索引最有效的用于查询</li></ol><p>‍</p><h3 id="2-4-什么情况下索引会失效？"><a href="#2-4-什么情况下索引会失效？" class="headerlink" title="2.4 什么情况下索引会失效？"></a>2.4 什么情况下索引会失效？</h3><ol><li><p>违反最左前缀法则</p><p> 如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左列开始，并且不跳过索引中的列，匹配最左前缀法则，</p><p> ​<img src="/images/MySQL/image-20230813173148-y0sxvpr.png" alt="image">​</p><p> ​<img src="/images/MySQL/image-20230813173203-0uaaxs3.png" alt="image"></p></li><li><p>范围查询右边的列，不能使用索引。</p></li><li><p>不要在索引列上进行运算操作，索引将失效</p></li><li><p>字符串不加单引号，造成索引失效（类型转换）</p></li><li><p>以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p></li></ol><h3 id="2-5-谈谈你对sql的优化的经验？"><a href="#2-5-谈谈你对sql的优化的经验？" class="headerlink" title="2.5 谈谈你对sql的优化的经验？"></a>2.5 谈谈你对sql的优化的经验？</h3><ol><li><p>表的设计优化</p><ol><li>比如设置合适的数值（tinyint int bigint) ,要根据实际情况选择</li><li>比如设置合适的字符串类型（char 和 varchar）char定长效率高，varchar可变长度，效率稍低</li></ol></li><li><p>sql语句的优化</p><ol><li>select 语句务必指明字段名称（避免直接使用select * ）</li><li>SQL语句要避免造成索引失效的写法</li><li>尽量使用union all 代替union， union会多一次过滤，效率低</li><li>避免在where子句中对字段进行表达式操作</li><li>Join优化，能用innerjoin 就不用 left join right join，如必须使用一定要以表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里面。left join 或 right join ，不会重新调整顺序</li></ol></li><li><p>主从复制，读写分离</p><ol><li>如果数据库的使用场景都的操作比较多的时候，为了避免写的操作所造成的性能影响，可以采用读写分离结构，读写分离解决的是，数据库的写入，影响了查询的效率</li></ol></li></ol><p>‍</p><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3 事务"></a>3 事务</h2><h3 id="3-1-事务的特性是什么，可以详细说明一下吗"><a href="#3-1-事务的特性是什么，可以详细说明一下吗" class="headerlink" title="3.1 事务的特性是什么，可以详细说明一下吗?"></a>3.1 事务的特性是什么，可以详细说明一下吗?</h3><pre><code>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</code></pre><ol><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency):事务完成时，必须使所有的数据都保持一致的状态。</li><li>隔离性（Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability)：事务一旦提交或回滚，他对数据库中的数据的改变就是永久的。</li></ol><p>‍</p><h3 id="3-2-并发事务带来哪些问题？怎么解决这些问题？MySQL的默认隔离级别？"><a href="#3-2-并发事务带来哪些问题？怎么解决这些问题？MySQL的默认隔离级别？" class="headerlink" title="3.2 并发事务带来哪些问题？怎么解决这些问题？MySQL的默认隔离级别？"></a>3.2 并发事务带来哪些问题？怎么解决这些问题？MySQL的默认隔离级别？</h3><ol><li><strong>并发事务问题</strong></li></ol><p>|问题|描述||<br>|脏读|一个事务读到另一个事务还没有提交的数据||<br>|不可重复读|一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读||</p><table><thead><tr><th>幻读</th><th>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影。</th><th></th></tr></thead></table><ol start="2"><li><strong>怎么解决并发事务的问题</strong></li></ol><p>​<img src="/images/MySQL/image-20230814101103-931xoij.png" alt="image">​</p><ol start="3"><li><strong>默认隔离级别是：可重复读</strong></li></ol><h3 id="3-3-undo-log-和-redo-log的区别？"><a href="#3-3-undo-log-和-redo-log的区别？" class="headerlink" title="3.3 undo log 和 redo log的区别？"></a>3.3 undo log 和 redo log的区别？</h3><ul><li>缓冲池：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），以一定的频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li><li>数据页：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB，页中存储的是行数据。</li></ul><ol><li><p><strong>redo log</strong></p><p> 重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p> 该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中，当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到次磁盘，发生错误时，进行数据恢复使用。</p></li><li><p>undo log</p><p> 回滚日志，用于记录数据被修改前的信息，作用包括两个： 提供回滚和MVCC（多版本并发控制）。undo log 和redo log记录物理日志不一样，它是逻辑日志。</p><ul><li><p>可以认为当delete一条记录时，undo log 会记录一条对应的insert记录，反之亦然</p></li><li><p>当update一条记录时，他记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>‍</p></li></ul></li></ol><h3 id="3-4-事务中的隔离性是如何保证的呢？"><a href="#3-4-事务中的隔离性是如何保证的呢？" class="headerlink" title="3.4 事务中的隔离性是如何保证的呢？"></a>3.4 事务中的隔离性是如何保证的呢？</h3><p>MVCC：多版本并发控制，指维护一个数据的多个版本，使得读写操作没有冲突</p><p><strong>MVCC-实现原理</strong></p><ul><li><p>记录中的隐藏字段</p><p>|隐藏字段|描述||<br>|DB_TRX_ID|最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID||<br>|DB_ROLL_PTR|回滚指针，指向这条记录的上一个版本，用于配合undo log ，指向上一个版本||</p><table><thead><tr><th>DB_ROW_ID</th><th>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</th><th></th></tr></thead></table></li><li><p>undo log</p><p>回滚日志，在 insert 、 update 、 delete 的时候产生的便于数据回滚的日志。</p><p>当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而 update 、 delete 的时候，产生的 undo log 日志不仅在回滚时需要， mvcc 版本访问也需要，不会立即被删除。</p></li><li><p>undo log版本链</p></li><li><p>readview</p><p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p></li><li><p>当前读</p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行枷锁。</p></li><li><p>快照读</p><p>简单的select（不加锁）就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读</p><ul><li>Read Committed:每次select都生成一个快照读</li><li>Repeatable Read: 开启事务后第一个select语句才是快照读的地方</li></ul></li></ul><h3 id="3-5-MySQL主从原理"><a href="#3-5-MySQL主从原理" class="headerlink" title="3.5 MySQL主从原理"></a>3.5 MySQL主从原理</h3><p>MySQL主从复制的核心就是二进制日志</p><p>二进制日志（ BINLOG ）记录了所有的 DDL （数据定义语言）语句和 DML （数据操纵语言）语句，但不包括数据查询（ SELECT 、 SHOW ）语句。</p><p>‍</p><h3 id="3-6-分库分表"><a href="#3-6-分库分表" class="headerlink" title="3.6 分库分表"></a>3.6 分库分表</h3><ol><li><p>拆分策略</p><p> ​<img src="/images/MySQL/image-20230814111529-ddnmgyu.png" alt="image">​</p><ol><li><p>垂直分库</p><p> 以表为依据，根据业务将不同表拆分到不同库中。</p><ol><li>按业务对数据分级管理</li></ol></li><li><p>垂直分表</p><p> 以字段为依据，根据字段属性将不同字段拆分到不同表中</p><p> 拆分规则：</p><ol><li>把常用的字段单独放在一张表</li><li>把text，blob等大字段拆分出来放在附表中</li></ol><p> 特点：</p><ol><li>冷热数据分离</li><li>减少IO过度争抢，两表会不影响</li></ol></li><li><p>水平分库</p><p> 将一个库的数据分到多个库中</p><p> 特点：</p><ol><li>解决了单库大数量，高并发的性能瓶颈</li><li>提高了系统的稳定性和可用性</li></ol></li><li><p>水平分表</p><p> 将一个表的数据拆分到多个表中（可以在同一个库中）</p><p> 特点：</p><ol><li>优化单一表数据量过大而产生的性能问题</li><li>避免IO争抢并减少锁表的几率</li></ol></li></ol><p> ‍</p><p> ‍</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/08/18/Spring/"/>
      <url>/2023/08/18/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="1-Spring-框架中的单例bean是线程安全的吗？"><a href="#1-Spring-框架中的单例bean是线程安全的吗？" class="headerlink" title="1 Spring 框架中的单例bean是线程安全的吗？"></a>1 Spring 框架中的单例bean是线程安全的吗？</h2><p>不是线程安全的</p><p>Spring框架中有一个@Scope注解，默认的值是singleton，单例的</p><p>因为一般在spring的bean的中都是注入无状态的对象，没有线程安全的问题。如果在bean中定义了可修改的成员变量，是要考虑到线程安全的问题，可以使用多例或者加锁来解决。</p><h2 id="2-什么是AOP？"><a href="#2-什么是AOP？" class="headerlink" title="2 什么是AOP？"></a>2 什么是AOP？</h2><pre><code>AOP 称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（ Aspect ），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</code></pre><p>使用场景：</p><ol><li>记录操作日志</li><li>缓存处理</li><li>spring中内置的事务处理</li></ol><h3 id="2-1-Spring中的事务是如何实现的？"><a href="#2-1-Spring中的事务是如何实现的？" class="headerlink" title="2.1 Spring中的事务是如何实现的？"></a>2.1 Spring中的事务是如何实现的？</h3><p>Spring支持编程式事务管理和声明式事务管理两种方式：</p><ol><li>编程式事务控制：需使用Transaction Template来进行实现，对业务的代码又倾入性，项目很少使用</li><li>声明式事务管理：声明式事务管理建立再AOP之上的，其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编制到拦截的方法中，也就是再目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li></ol><h2 id="3-Spring中事务失效的场景有哪些？"><a href="#3-Spring中事务失效的场景有哪些？" class="headerlink" title="3 Spring中事务失效的场景有哪些？"></a>3 Spring中事务失效的场景有哪些？</h2><ol><li>异常捕获处理</li><li>抛出检查异常</li><li>非public方法</li></ol><p>情况一：异常捕获处理</p><p>​<img src="/images/Spring/image-20230815160415-engb6cc.png" alt="image">​</p><p>进行了try catch会直接抛出异常，导致结果不对。</p><p><strong>原因：</strong></p><pre><code>事务通知只会捉到目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉了异常，事务将无法进行回滚</code></pre><p><strong>解决：</strong></p><pre><code>在catch块中自己抛出异常，throw new RuntimeException()</code></pre><p>‍</p><p>情况二：抛出检查异常</p><p>​<img src="/images/Spring/image-20230815160804-9ob5ur8.png" alt="image">​</p><p>读取文件不存在，没办法进行回滚</p><p>原因：</p><pre><code>Spring只进行回滚非检查异常</code></pre><p>解决：</p><pre><code>配置rollbackFor属性，@Transactional(rollbackFor=Exception.class)</code></pre><p>‍</p><p>情况三：非 public 方法导致的事务失效</p><p>​<img src="/images/Spring/image-20230815161045-lgbk85u.png" alt="image">​</p><p>原因：</p><pre><code>Spring为方法创建代理、添加事务通知、前提条件都是该方法的public的</code></pre><p>‍</p><p>解决：</p><pre><code>改为public方法</code></pre><p>‍</p><h2 id="4-Spring-的bean-的生命周期？"><a href="#4-Spring-的bean-的生命周期？" class="headerlink" title="4 Spring 的bean 的生命周期？"></a>4 Spring 的bean 的生命周期？</h2><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><pre><code>Spring容器在进行实例化时，会将xml配置的&lt;bean&gt; 的信息封装成一个Bean Definition对象，Spring根据BeanDefinition来创建Bean对象，里面有很多的属性用来描述Bean。</code></pre><p>​<img src="/images/Spring/image-20230815161452-qgmnqbe.png" alt="image">​</p><p>​<img src="/images/Spring/image-20230815161840-wu0iflt.png" alt="image">​</p><p>‍</p><h2 id="5-Spring中的循环引用？"><a href="#5-Spring中的循环引用？" class="headerlink" title="5 Spring中的循环引用？"></a>5 Spring中的循环引用？</h2><p>多个对象互相使用</p><p>​<img src="/images/Spring/image-20230815162551-lx8xcgh.png" alt="image">​</p><p>‍</p><h3 id="5-1-三级缓存解决循环依赖"><a href="#5-1-三级缓存解决循环依赖" class="headerlink" title="5.1 三级缓存解决循环依赖"></a>5.1 三级缓存解决循环依赖</h3><table><thead><tr><th>缓存名称</th><th>源码名称</th><th>作用</th></tr></thead><tbody><tr><td>一级缓存</td><td>singletonObjects</td><td>单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td></tr><tr><td>二级缓存</td><td>earlySingletonObjects</td><td>缓存早期的bean对象（生命周期还没有走完）</td></tr><tr><td>三级缓存</td><td>singletonFactories</td><td>缓存的时ObjectFactory,表示对象工厂，用来创建某个对象的</td></tr></tbody></table><p>一级缓存的作用： 限制 bean 在 beanFactory 中只存一份，即实现 singleton scope ，解决不了循环依赖</p><p>​<img src="/images/Spring/image-20230815163209-pmm0kxm.png" alt="image">​</p><p>如果要想打破循环依赖，就需要一个中间人的参与，这个中间人就是二级缓存</p><p>​<img src="/images/Spring/image-20230815163312-igny66t.png" alt="image">​</p><p>‍</p><p>三级缓存</p><p>​<img src="/images/Spring/image-20230815164227-z9oys9k.png" alt="image">​</p><p>‍</p><p>‍</p><p>构造方法出现的循环依赖三级缓存无法解决。</p><p>解决方法：</p><pre><code>添加注解@Lazy</code></pre><p>‍</p><p>‍</p><h2 id="6-SpringMVC的执行流程？"><a href="#6-SpringMVC的执行流程？" class="headerlink" title="6 SpringMVC的执行流程？"></a>6 SpringMVC的执行流程？</h2><ol><li>试图阶段（老旧JSP）</li><li>前后端分离</li></ol><p>视图阶段（JSP）</p><p>​<img src="/images/Spring/image-20230815165025-m9oxu2y.png" alt="image">​</p><p>前后端分离阶段（接口开发，异步请求）</p><p>​<img src="/images/Spring/image-20230815165215-oamjx0e.png" alt="image">​</p><p>‍</p><p>‍</p><h2 id="7-SpringBoot的自动配置原理"><a href="#7-SpringBoot的自动配置原理" class="headerlink" title="7 SpringBoot的自动配置原理"></a>7 SpringBoot的自动配置原理</h2><p>​<img src="/images/Spring/image-20230815165448-fpcw8bt.png" alt="image">​</p><p>‍</p><h2 id="8-Spring框架的常见注解（Spring，SpringBoot，SpringMVC）"><a href="#8-Spring框架的常见注解（Spring，SpringBoot，SpringMVC）" class="headerlink" title="8 Spring框架的常见注解（Spring，SpringBoot，SpringMVC）"></a>8 Spring框架的常见注解（Spring，SpringBoot，SpringMVC）</h2><p>‍</p><p><strong>Spring注解</strong>：</p><p>|注解|说明||<br>|@Component、@Controller、@Service、@Respository|使用类上用于实例化Bean||<br>|@Autowired|使用在字段上用于根据类型依赖注入||</p><table><thead><tr><th>@Qualifier</th><th>结合@Autowired一起使用用于根据名称进行依赖注入</th><th></th></tr></thead><tbody><tr><td><strong>@Scope</strong></td><td><strong>标注Bean的作用范围</strong></td><td></td></tr><tr><td><strong>@Configure</strong></td><td><strong>指定当前类是一个spring配置类，当创建容器时会从该类上加载注解</strong></td><td></td></tr><tr><td><strong>@ComponentsScan</strong></td><td><strong>用于指定spring在初始化容器上要扫描的包</strong></td><td></td></tr><tr><td><strong>@Bean</strong></td><td><strong>使用在方法上，标注将该方法的返回值存储到Spring容器中</strong></td><td></td></tr><tr><td><strong>@Import</strong></td><td><strong>使用@Import导入的类会被Spring加载到IOC容器中</strong></td><td></td></tr><tr><td><strong>@Aspect、@Before、@After、@Around、@Pointcut</strong></td><td><strong>用于切面编程</strong>​</td><td></td></tr></tbody></table><p>‍</p><p><strong>SpringMVC相关注解：</strong></p><p>|注解|说明||<br>|@RequestMapping|用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径||<br>|@RequestBody|注解实现接收 http 请求的 json 数据，将 json 转换为 java 对象||</p><table><thead><tr><th>@RequestParam</th><th>指定请求参数的名称</th><th></th></tr></thead><tbody><tr><td><strong>@PathViriable</strong></td><td><strong>从请求路径下中获取请求参数 (&#x2F;user&#x2F;{id}) ，传递给方法的形式参数</strong></td><td></td></tr><tr><td><strong>@ResponseBody</strong></td><td><strong>注解实现将 controller 方法返回对象转化为 json 对象响应给客户端</strong></td><td></td></tr><tr><td><strong>@RequestHeader</strong></td><td><strong>获取指定的请求头数据</strong></td><td></td></tr><tr><td><strong>@RestController</strong></td><td><strong>@Controller + @ResponseBody</strong></td><td></td></tr></tbody></table><p>‍</p><h2 id="9-MyBatisz的执行流程？"><a href="#9-MyBatisz的执行流程？" class="headerlink" title="9 MyBatisz的执行流程？"></a>9 MyBatisz的执行流程？</h2><p>​<img src="/images/Spring/image-20230816145351-xdi2k5c.png" alt="image">​</p><p>‍</p><p>‍</p><h2 id="10-Mybatis是否支持延迟加载？"><a href="#10-Mybatis是否支持延迟加载？" class="headerlink" title="10 Mybatis是否支持延迟加载？"></a>10 Mybatis是否支持延迟加载？</h2><p>Mybatis支持延迟加载，但是默认没有开启</p><p>​<img src="/images/Spring/image-20230816150103-c4s3x0h.png" alt="image">​</p><p>‍</p><p>延迟加载的原理：</p><ol><li>使用CGLIB创建目标对象的代理对象</li><li>当调用目标方法user.getOrderList()时，进入拦截器invoke方法，发现user.getOrderList()时null值，执行sql查询order列表</li><li>把order查询上来，然后调用user.setOrderList(List<Order> orderList)，接着完成user.getOrderList()方法的调用</li></ol><p>​<img src="/images/Spring/image-20230816150352-gap1jjo.png" alt="image">​</p><p>‍</p><p>‍</p><h2 id="10-Mybatis的一级、二级缓存用过吗？"><a href="#10-Mybatis的一级、二级缓存用过吗？" class="headerlink" title="10 Mybatis的一级、二级缓存用过吗？"></a>10 Mybatis的一级、二级缓存用过吗？</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><pre><code>基于PerpetualCache的HashMap本地缓存，其储存作用域为session，当session进行flush或者close之后，该session中的所有的cache就将清空，默认打开一级缓存</code></pre><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><pre><code>是基于namespace和mapper的作用域起作用，不是依赖于SQL session，默认采用PerpetualCache HashMap存储</code></pre><p>注意事项：</p><ol><li>对于缓存数据更新机制，当某一个作用域（一级缓存session&#x2F;二级缓存Namespace)的进行了新增、修改、删除操作后，默认该作用域下所有的select中的缓存将被clear</li><li>二级缓存需要缓存的数据实现Serializable接口</li><li>只有会话提交或者关闭之后，一级缓存中的数据才会转移到二级缓存中</li></ol><p>‍</p><p>‍</p><p>‍</p><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试</title>
      <link href="/2023/08/11/Redis/"/>
      <url>/2023/08/11/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h1><h2 id="1、缓存穿透"><a href="#1、缓存穿透" class="headerlink" title="1、缓存穿透"></a>1、缓存穿透</h2><p>查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，导致每次请求都会查询数据库</p><h3 id="1-1-解决方法"><a href="#1-1-解决方法" class="headerlink" title="1.1 解决方法"></a>1.1 解决方法</h3><ol><li><p>缓存空数据，查询返回的数据为空，仍把这个数据缓存</p><p> 1.1 缺点：消耗内存，可能会发生不一致的问题</p></li><li><p>布隆过滤器</p><p> ​<img src="/images/Redis/image-20230808162355-thy0rgk.png" alt="image">​</p><p> 主要是通过数组来判断的，但是会出现误判</p><p> 2.1 缺点： 实现复杂，存在误判</p></li></ol><h2 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h2><p>当给某个key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把数据库压垮</p><p>​<img src="/images/Redis/image-20230808163212-ex1ivgu.png" alt="image">​</p><h3 id="2-1-解决方法"><a href="#2-1-解决方法" class="headerlink" title="2.1 解决方法"></a>2.1 解决方法</h3><ol><li><p>互斥锁</p><p> ​<img src="/images/Redis/image-20230808163423-5qnd3cs.png" alt="image"></p><p> 强一致，性能差</p></li><li><p>逻辑过期</p><p> ​<img src="/images/Redis/image-20230808163644-3hoxaas.png" alt="image"></p><p> 高可用，性能优，不能保证数据的绝对一致</p><p> ‍</p></li></ol><h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3 缓存雪崩"></a>3 缓存雪崩</h2><p>指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量的请求到达数据库，带来巨大的压力</p><p>​<img src="/images/Redis/image-20230808163953-je11knl.png" alt="image">​</p><h3 id="3-1-解决方法"><a href="#3-1-解决方法" class="headerlink" title="3.1 解决方法"></a>3.1 解决方法</h3><ol><li>给不同的key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性   如：哨兵模式，集群模式</li><li>给缓存业务添加降级限流策略        如：nigix或者springcloud gateway</li><li>给业务添加多级缓存</li></ol><h2 id="4-redis作为缓存，mysql的数据如何与redis进行同步？（双写一致性）"><a href="#4-redis作为缓存，mysql的数据如何与redis进行同步？（双写一致性）" class="headerlink" title="4 redis作为缓存，mysql的数据如何与redis进行同步？（双写一致性）"></a>4 redis作为缓存，mysql的数据如何与redis进行同步？（双写一致性）</h2><h3 id="4-1-双写一致性"><a href="#4-1-双写一致性" class="headerlink" title="4.1 双写一致性"></a>4.1 双写一致性</h3><p>当修改了数据库中的数据也要同时更新缓存中的数据，缓存中的数据要和数据库中的数据保存一致</p><p>​<img src="/images/Redis/image-20230808164715-hkasqms.png" alt="image">​</p><ol><li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，然后写入缓存，设置超时时间</p></li><li><p>写操作：延迟双删</p><p> ​<img src="/images/Redis/image-20230808165328-k87t9b6.png" alt="image">​</p><p> 应该是先删除缓存还是先删除数据库？</p><ol><li><p>先删除缓存，在操作数据库</p><p> ​​<img src="/images/Redis/image-20230808165122-62xckbu.png" alt="image">​</p><p> 会出现脏数据的现象</p></li><li><p>先操作数据库，在删除缓存</p><p> ​<img src="/images/Redis/image-20230808165301-9hhowvf.png" alt="image">​</p><p> 也会出现问题</p></li><li><p>可以使用分布式锁实现</p><p> ​<img src="/images/Redis/image-20230808165524-bf2r5ms.png" alt="image">​</p></li><li><p>​<img src="/images/Redis/image-20230808165623-sf8h7bz.png" alt="image">​</p></li><li><p>最好的方式</p><p> 使用mq实现</p><p> ​<img src="/images/Redis/image-20230808165954-7v6voiv.png" alt="image">​</p></li></ol></li></ol><h2 id="5-redis-作为缓存，数据的持久化是怎么做的？"><a href="#5-redis-作为缓存，数据的持久化是怎么做的？" class="headerlink" title="5 redis 作为缓存，数据的持久化是怎么做的？"></a>5 redis 作为缓存，数据的持久化是怎么做的？</h2><h3 id="5-1-RDB"><a href="#5-1-RDB" class="headerlink" title="5.1 RDB"></a>5.1 RDB</h3><pre><code>RDB 全称 Redis Database Backup file （ Redis 数据备份文件），也被叫做 Redis 数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据</code></pre><h4 id="5-1-1-RDB的执行原理"><a href="#5-1-1-RDB的执行原理" class="headerlink" title="5.1.1 RDB的执行原理"></a>5.1.1 RDB的执行原理</h4><pre><code>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RGB文件。</code></pre><p>​<img src="/images/Redis/image-20230809141944-yfp19h5.png" alt="image">​</p><h3 id="5-2-AOF"><a href="#5-2-AOF" class="headerlink" title="5.2 AOF"></a>5.2 AOF</h3><p>​<img src="/images/Redis/image-20230809142125-ib692pw.png" alt="image">​</p><p>​<img src="/images/Redis/image-20230809142416-jd2sk3o.png" alt="image">​</p><h2 id="6-假如redis的key过期后，会立即删除吗？"><a href="#6-假如redis的key过期后，会立即删除吗？" class="headerlink" title="6 假如redis的key过期后，会立即删除吗？"></a>6 假如redis的key过期后，会立即删除吗？</h2><h3 id="6-1-惰性删除"><a href="#6-1-惰性删除" class="headerlink" title="6.1 惰性删除"></a>6.1 惰性删除</h3><pre><code>置该key过期时间后，我们不需要去管他，当需要该key时，我们再检查其是否过期，如果过期，我们就删除，反之返回该key</code></pre><h3 id="6-2-定期删除"><a href="#6-2-定期删除" class="headerlink" title="6.2 定期删除"></a>6.2 定期删除</h3><pre><code>每隔一段时间，我们就对key进行检查，删除里面过期的key（从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key）</code></pre><p>两种模式：</p><ol><li>Slow模式是定时任务，执行频率默认为 10hz ，每次不超过 25ms ，以通过修改配置文件 redis.conf 的 hz 选项来调整这个次数</li><li>FAST 模式执行频率不固定，但两次间隔不低于 2ms ，每次耗时不超过 1ms</li></ol><h2 id="7-假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）"><a href="#7-假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）" class="headerlink" title="7 假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）"></a>7 假如缓存过多，内存是有限的，内存被占满了怎么办？（数据淘汰策略）</h2><pre><code>数据的淘汰策略：当 Redis 中的内存不够用时，此时在向 Redis 中添加新的 key ，那么 Redis 就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</code></pre><p>Redis支持8种不同的策略来选择要删除的key:</p><ol><li>noeviction ： 不淘汰任何 key ，但是内存满时不允许写入新数据，默认就是这种策略</li><li>volatile-ttl ： 对设置了 TTL 的 key ，比较 key 的剩余 TTL 值， TTL 越小越先被淘汰</li><li>allkeys-random ：对全体 key ，随机进行淘汰。</li><li>volatile-random ：对设置了 TTL 的 key ，随机进行淘汰。</li><li>allkeys-lru ： 对全体 key ，基于 LRU 算法进行淘汰。LRU 最近最少使用，LFU：最少频率使用</li><li>volatile-lru ： 对设置了 TTL 的 key ，基于 LRU 算法进行淘汰</li><li>allkeys-lfu ： 对全体 key ，基于 LFU 算法进行淘汰</li><li>volatile-lfu ： 对设置了 TTL 的 key ，基于 LFU 算法进行淘汰</li></ol><h3 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h3><ol><li>优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。</li><li>如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用allkeys-random ，随机选择淘汰。</li><li>如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。</li><li>如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。</li></ol><p>​<img src="/images/Redis/image-20230809144042-ilo0hwj.png" alt="image">​</p><h2 id="8-redis-分布式锁，是如何实现的？（场景：集群情况下的定时任务，抢单，幂等性）"><a href="#8-redis-分布式锁，是如何实现的？（场景：集群情况下的定时任务，抢单，幂等性）" class="headerlink" title="8 redis 分布式锁，是如何实现的？（场景：集群情况下的定时任务，抢单，幂等性）"></a>8 redis 分布式锁，是如何实现的？（场景：集群情况下的定时任务，抢单，幂等性）</h2><p>​<img src="/images/Redis/image-20230809152440-30ijpgb.png" alt="image">​</p><p>redisson实现的分布式锁可重入</p><h4 id="主从一致性"><a href="#主从一致性" class="headerlink" title="主从一致性"></a>主从一致性</h4><p>使用红锁：不能只在一个redis实例上创建锁，应该在多个redis实例上进行创建锁</p><p>‍</p><h3 id="9-Redis集群有哪些方案？"><a href="#9-Redis集群有哪些方案？" class="headerlink" title="9 Redis集群有哪些方案？"></a>9 Redis集群有哪些方案？</h3><p>在redis中提供的集群方案总共有三种</p><ol><li>主从复制</li><li>哨兵模式</li><li>分片集群</li></ol><h3 id="9-1-主从复制"><a href="#9-1-主从复制" class="headerlink" title="9.1 主从复制"></a>9.1 主从复制</h3><pre><code>​![image](images/Redis/image-20230809153853-mqeh8xp.png)​</code></pre><p>​<img src="/images/Redis/image-20230809154024-2ryn0dj.png" alt="image">​</p><h3 id="9-2-哨兵模式"><a href="#9-2-哨兵模式" class="headerlink" title="9.2 哨兵模式"></a>9.2 哨兵模式</h3><p>redis提供了哨兵机制来实现主从集群的自动故障恢复，主要作用：</p><ol><li><p>监控：哨兵会不断检查master和slave是否按预期工作</p></li><li><p>自动故障恢复：如果master故障，哨兵会将一个slave提升为master。当故障实例恢复后也以新的master为主</p></li><li><p>通知：哨兵充当redis客户端的服务发现来源，当集群发生故障转移时，会将最新的信息推送给redis客户端</p><p> ‍</p></li></ol><h4 id="哨兵选主的规则"><a href="#哨兵选主的规则" class="headerlink" title="哨兵选主的规则"></a>哨兵选主的规则</h4><ol><li>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</li><li>然后判断从节点的 slave-priority 值，越小优先级越高</li><li>如果 slave-prority 一样，则判断 slave 节点的 offset 值，越大优先级越高</li><li>最后是判断 slave 节点的运行 id 大小，越小优先级越高。</li></ol><h4 id="redis集群（哨兵模式-脑裂"><a href="#redis集群（哨兵模式-脑裂" class="headerlink" title="redis集群（哨兵模式)脑裂"></a>redis集群（哨兵模式)脑裂</h4><h3 id="9-3-分片集群结构"><a href="#9-3-分片集群结构" class="headerlink" title="9.3 分片集群结构"></a>9.3 分片集群结构</h3><p>​<img src="/images/Redis/image-20230810155824-giv8bdl.png" alt="image">​</p><p>‍</p><h3 id="10-其他问题"><a href="#10-其他问题" class="headerlink" title="10 其他问题"></a>10 其他问题</h3><p>‍</p><p>​<img src="/images/Redis/image-20230810160110-cjjfubw.png" alt="image">​</p><p>‍</p><h4 id="10-1-用户空间和内核空间"><a href="#10-1-用户空间和内核空间" class="headerlink" title="10.1 用户空间和内核空间"></a>10.1 用户空间和内核空间</h4><p>​<img src="/images/Redis/image-20230810160326-2xgdntq.png" alt="image">​</p><h4 id="10-2-阻塞IO"><a href="#10-2-阻塞IO" class="headerlink" title="10.2 阻塞IO"></a>10.2 阻塞IO</h4><p>阶段一：</p><ol><li>用户进程尝试读取数据（比如网卡数据)</li><li>此时数据尚未到达，内核需要等待数据</li><li>此时用户进程也处于阻塞状态</li></ol><p>阶段二：</p><ol><li>数据到达并拷贝到内核缓冲去，代表已就绪</li><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程接触阻塞，处理数据</li></ol><p>​<img src="/images/Redis/image-20230810160820-nxdnvl1.png" alt="image">​</p><h4 id="10-3-非阻塞IO"><a href="#10-3-非阻塞IO" class="headerlink" title="10.3 非阻塞IO"></a>10.3 非阻塞IO</h4><p>阶段一：</p><ol><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，知道数据就绪</li></ol><p>阶段二：</p><ol><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程接触阻塞，处理数据</li></ol><p>‍</p><p>​<img src="/images/Redis/image-20230810161058-khx69qo.png" alt="image">​</p><h4 id="10-4-IO多路复用"><a href="#10-4-IO多路复用" class="headerlink" title="10.4 IO多路复用"></a>10.4 IO多路复用</h4><p>IO多路复用：是利用单个线程来同时监听多个 Socket ，并在某个 Socket 可读、可写时得到通知，从而避免无效的等待，充分利用 CPU 资源。</p><p>阶段一：</p><ol><li>用户进程调用 select ，指定要监听的 Socket 集合</li><li>内核监听对应的多个 socket</li><li>任意一个或多个 socket 数据就绪则返回 readable</li><li>此过程中用户进程阻塞</li></ol><p>阶段二：</p><ol><li>用户进程找到就绪的 socket</li><li>依次调用 recvfrom 读取数据</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ol><p>​<img src="/images/Redis/image-20230810161339-yz88h2v.png" alt="image">​</p><p>‍</p><p>‍</p><p>‍</p><h2 id="End-SpringBoot整合Redis"><a href="#End-SpringBoot整合Redis" class="headerlink" title="End SpringBoot整合Redis"></a>End SpringBoot整合Redis</h2><h3 id="1、-配置类"><a href="#1、-配置类" class="headerlink" title="1、 配置类"></a>1、 配置类</h3><pre><code class="java">@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        template.setConnectionFactory(factory);        //key序列化方式        template.setKeySerializer(redisSerializer);        //value序列化        template.setValueSerializer(jackson2JsonRedisSerializer);        //value hashmap序列化        template.setHashValueSerializer(jackson2JsonRedisSerializer);        return template;    &#125;    @Bean    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        //解决查询缓存转换异常的问题        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        // 配置序列化（解决乱码的问题）,过期时间600秒        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofSeconds(600))                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))                .disableCachingNullValues();        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)                .cacheDefaults(config)                .build();        return cacheManager;    &#125;&#125;</code></pre><h3 id="2、springboot-缓存注解说明"><a href="#2、springboot-缓存注解说明" class="headerlink" title="2、springboot 缓存注解说明"></a>2、springboot 缓存注解说明</h3><h4 id="2-1-缓存-Cacheable"><a href="#2-1-缓存-Cacheable" class="headerlink" title="2.1 缓存@Cacheable"></a>2.1 缓存@Cacheable</h4><pre><code>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不 存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</code></pre><table><thead><tr><th>属性&#x2F;方法名</th><th>解释</th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><h4 id="2-2-缓存-CachePut"><a href="#2-2-缓存-CachePut" class="headerlink" title="2.2 缓存@CachePut"></a>2.2 缓存@CachePut</h4><pre><code>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存 中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。</code></pre><table><thead><tr><th>属性&#x2F;方法名</th><th>解释</th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table><h4 id="2-3-缓存-CacheEvict"><a href="#2-3-缓存-CacheEvict" class="headerlink" title="2.3 缓存@CacheEvict"></a>2.3 缓存@CacheEvict</h4><pre><code>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上</code></pre><table><thead><tr><th>属性&#x2F;方法名</th><th>解释</th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr><tr><td>allEntries</td><td>是否清空所有缓存，默认为 false。如果指定为 true，则方法调用 后将立即清空所有的缓存</td></tr><tr><td>beforeInvo cation</td><td>是否在方法执行前就清空，默认为 false。如果指定为 true，则在 方法执行前就会清空缓存</td></tr></tbody></table><h3 id="3-使用过程"><a href="#3-使用过程" class="headerlink" title="3 使用过程"></a>3 使用过程</h3><p>在需要存储数据的方法上面添加@Cacheable注解，注解里面写入需要添加的key和value</p><p>​<img src="/images/Redis/image-20230810113504-vc3csy9.png" alt="image">​</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="/2023/08/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2023/08/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><h3 id="三种常见方式"><a href="#三种常见方式" class="headerlink" title="三种常见方式"></a>三种常见方式</h3><ol><li>使用session广播机制实现      session复制 会导致空间浪费（不在用）</li><li>使用cookie + redis实现</li><li>使用token实现</li></ol><h2 id="cookie-redis"><a href="#cookie-redis" class="headerlink" title="cookie + redis"></a>cookie + redis</h2><ol><li><p>在项目中任何一个模块进行登录，登录之后，把数据放到两个地方</p><p> 1.1 redis：在key：生成唯一随机值，在value： 用户数据</p><p> 1.2 cookie：把redis里面生成的key值放到cookie中</p></li><li><p>访问项目中其他模块时，发送请求带着cookie发送，获取cookie值，拿着cookie做事情</p><p> 2.1 把cookie获取值，到redis进行查询，根据key进行查询，如果查询到数据就是登录</p></li></ol><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token:按照一定规制生成字符串，字符串可以包含用户信息</p><ol><li><p>在项目的某个模块中进行登录，登录之后，按照规则生成字符串，把登录之后的用户包含到字符串里面，把字符串返回</p><p> 1.1 可以把字符串通过cookie返回</p><p> 1.2 把字符串通过地址栏返回</p></li><li><p>再去访问项目其他模块，每次访问都在地址栏带着生成字符串，在访问模块里面获取地址栏字符串，根据字符串获取用户信息，如果可以获取到就是登录</p></li></ol><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>热部署</title>
      <link href="/2023/08/04/Devtools/"/>
      <url>/2023/08/04/Devtools/</url>
      
        <content type="html"><![CDATA[<h1 id="热部署Devtools"><a href="#热部署Devtools" class="headerlink" title="热部署Devtools"></a>热部署Devtools</h1><h4 id="第一步-添加依赖"><a href="#第一步-添加依赖" class="headerlink" title="第一步 添加依赖"></a>第一步 添加依赖</h4><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><h4 id="第二步-添加配置"><a href="#第二步-添加配置" class="headerlink" title="第二步 添加配置"></a>第二步 添加配置</h4><pre><code class="java">&lt;build&gt;    &lt;finalName&gt;你自己的工程名字&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;                &lt;addResources&gt;true&lt;/addResources&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><h4 id="第三步-修改配置"><a href="#第三步-修改配置" class="headerlink" title="第三步 修改配置"></a>第三步 修改配置</h4><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105429-fu9m0yn.png" alt="image">​</p><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105433-2h97hee.png" alt="image">​</p><h4 id="第四步-添加配置"><a href="#第四步-添加配置" class="headerlink" title="第四步 添加配置"></a>第四步 添加配置</h4><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105507-n40ldyf.png" alt="image">​</p><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105512-evt811g.png" alt="image">​</p><p>新版本可能在修改时找不到第一项，需要打开设置进行设置</p><p>​<img src="/images/%E7%83%AD%E9%83%A8%E7%BD%B2/image-20230801105627-ficn5z7.png" alt="image">​</p><h4 id="第五步-重启idea"><a href="#第五步-重启idea" class="headerlink" title="第五步 重启idea"></a>第五步 重启idea</h4><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/03/Java/hello-world/"/>
      <url>/2023/07/03/Java/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dataway</title>
      <link href="/2022/07/16/Dataway/"/>
      <url>/2022/07/16/Dataway/</url>
      
        <content type="html"><![CDATA[<h1 id="Dataway"><a href="#Dataway" class="headerlink" title="Dataway"></a>Dataway</h1><pre><code>测试、冒烟、发布，一站式都通过Dataway 是基于 DataQL 服务聚合能力，为应用提供的一个接口配置工具，使得使用者无需开发任何代码就配置一个满足需求的接口。整个接口配置、测试、冒烟、发布，一站式都通过 Dataway 提供的 UI 界面完成。UI 会以 Jar 包方式提供并集成到应用中并和应用共享同一个 http 端口，应用无需单独为 Dataway 开辟新的管理端口。这种内嵌集成方式模式的优点是，可以使得大部分老项目都可以在无侵入的情况下直接应用 Dataway。进而改进老项目的迭代效率，大大减少企业项目研发成本。Dataway 工具化的提供 DataQL 配置能力。这种研发模式的变革使得，相当多的需求开发场景只需要配置即可完成交付。从而避免了从数据存取到前端接口之间的一系列开发任务，例如：Mapper、BO、VO、DO、DAO、Service、Controller 统统不在需要。Dataway 是 Hasor 生态中的一员，因此在 Spring 中使用 Dataway 首先要做的就是打通两个生态。根据官方文档中推荐的方式我们将 Hasor 和 Spring Boot 整合起来。</code></pre><h4 id="第一步：-引入相关依赖"><a href="#第一步：-引入相关依赖" class="headerlink" title="第一步： 引入相关依赖"></a>第一步： 引入相关依赖</h4><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;    &lt;version&gt;4.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;    &lt;version&gt;4.1.3-fix20200414&lt;/version&gt;&lt;!-- 4.1.3 包存在UI资源缺失问题 --&gt;&lt;/dependency&gt;</code></pre><p>hasor-spring 负责 Spring 和 Hasor 框架之间的整合。hasor-dataway 是工作在 Hasor 之上，利用 hasor-spring 我们就可以使用 dataway了。</p><h4 id="第二步：配置Dataway-并初始化数据表"><a href="#第二步：配置Dataway-并初始化数据表" class="headerlink" title="第二步：配置Dataway,并初始化数据表"></a>第二步：配置Dataway,并初始化数据表</h4><p>dataway 会提供一个界面让我们配置接口，这一点类似 Swagger 只要jar包集成就可以实现接口配置。找到我们 springboot 项目的配置文件 application.properties</p><pre><code class="java"># 是否启用 Dataway 功能（必选：默认false）HASOR_DATAQL_DATAWAY=true# 是否开启 Dataway 后台管理界面（必选：默认false）HASOR_DATAQL_DATAWAY_ADMIN=true# dataway  API工作路径（可选，默认：/api/）HASOR_DATAQL_DATAWAY_API_URL=/api/# dataway-ui 的工作路径（可选，默认：/interface-ui/）HASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/# SQL执行器方言设置（可选，建议设置）HASOR_DATAQL_FX_PAGE_DIALECT=mysql</code></pre><p>Dataway 一共涉及到 5个可以配置的配置项，但不是所有配置都是必须的。</p><p>其中 HASOR_DATAQL_DATAWAY、HASOR_DATAQL_DATAWAY_ADMIN 两个配置是必须要打开的，默认情况下 Datawaty 是不启用的。</p><p>Dataway 需要两个数据表才能工作，下面是这两个数据表的简表语句。下面这个 SQL 可以在 dataway的依赖 jar 包中 “META-INF&#x2F;hasor-framework&#x2F;mysql” 目录下面找到，建表语句是用 mysql 语法写的。</p><pre><code class="sql">CREATE TABLE `interface_info` (    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;ID&#39;,    `api_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `api_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `api_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0草稿，1发布，2有变更，3禁用&#39;,    `api_comment`     varchar(255)     NULL                  COMMENT &#39;注释&#39;,    `api_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `api_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `api_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `api_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,    PRIMARY KEY (`api_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway 中的API&#39;;CREATE TABLE `interface_release` (    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;Publish ID&#39;,    `pub_api_id`      int(11)      NOT NULL                  COMMENT &#39;所属API ID&#39;,    `pub_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `pub_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `pub_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0有效，1无效（可能被下线）&#39;,    `pub_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `pub_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT &#39;原始查询脚本，仅当类型为SQL时不同&#39;,    `pub_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `pub_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;发布时间（下线不更新）&#39;,    PRIMARY KEY (`pub_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway API 发布历史。&#39;;create index idx_interface_release on interface_release (pub_api_id);</code></pre><h4 id="第三步：-配置数据源"><a href="#第三步：-配置数据源" class="headerlink" title="第三步： 配置数据源"></a>第三步： 配置数据源</h4><p>作为 Spring Boot 项目有着自己完善的数据库方面工具支持。我们这次采用 druid + mysql + spring-boot-starter-jdbc 的方式。</p><p>首先引入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后添加数据源的配置</p><pre><code class="java"># dbspring.datasource.url=jdbc:mysql://xxxxxxx:3306/examplespring.datasource.username=xxxxxspring.datasource.password=xxxxxspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type:com.alibaba.druid.pool.DruidDataSource# druidspring.datasource.druid.initial-size=3spring.datasource.druid.min-idle=3spring.datasource.druid.max-active=10spring.datasource.druid.max-wait=60000spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=adminspring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=1</code></pre><p>如果项目已经集成了自己的数据源，那么可以忽略第三步。</p><h4 id="第四步：把数据源设置到Hasor容器中"><a href="#第四步：把数据源设置到Hasor容器中" class="headerlink" title="第四步：把数据源设置到Hasor容器中"></a>第四步：把数据源设置到Hasor容器中</h4><p>Spring Boot 和 Hasor 本是两个独立的容器框架，我们做整合之后为了使用 Dataway 的能力需要把 Spring 中的数据源设置到 Hasor 中。</p><p>首先新建一个 Hasor 的 模块，并且将其交给 Spring 管理。然后把数据源通过 Spring 注入进来。</p><pre><code class="java">@DimModule@Componentpublic class ExampleModule implements SpringModule &#123;    @Autowired    private DataSource dataSource = null;    @Override    public void loadModule(ApiBinder apiBinder) throws Throwable &#123;        // .DataSource form Spring boot into Hasor        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));    &#125;&#125;</code></pre><p>Hasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。</p><h4 id="第五步：-在springboot中启用Hasor"><a href="#第五步：-在springboot中启用Hasor" class="headerlink" title="第五步： 在springboot中启用Hasor"></a>第五步： 在springboot中启用Hasor</h4><pre><code class="java">@EnableHasor()@EnableHasorWeb()@SpringBootApplication(scanBasePackages = &#123; &quot;net.example.hasor&quot; &#125;)public class ExampleApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ExampleApplication.class, args);    &#125;&#125;</code></pre><p>这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。</p><h4 id="第六步：启动应用"><a href="#第六步：启动应用" class="headerlink" title="第六步：启动应用"></a>第六步：启动应用</h4><p>应用在启动过程中会看到 Hasor Boot 的欢迎信息</p><pre><code class="java"> _    _                        ____              _| |  | |                      |  _ \            | || |__| | __ _ ___  ___  _ __  | |_) | ___   ___ | |_|  __  |/ _` / __|/ _ \| &#39;__| |  _ &lt; / _ \ / _ \| __|| |  | | (_| \__ \ (_) | |    | |_) | (_) | (_) | |_|_|  |_|\__,_|___/\___/|_|    |____/ \___/ \___/ \__|</code></pre><p>在后面的日志中还可以看到类似下面这些日志。</p><pre><code class="java">2023-05-18 13:52:59.696 [main] INFO  n.h.core.context.TemplateAppContext - loadModule class net.hasor.dataway.config.DatawayModule2023-05-18 13:52:59.697 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway api workAt /api/2023-05-18 13:52:59.697 [main] INFO  n.h.c.e.AbstractEnvironment - var -&gt; HASOR_DATAQL_DATAWAY_API_URL = /api/.2023-05-18 13:52:59.704 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway admin workAt /interface-ui/2023-05-18 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[901d38f22faa419a8593bb349905ed0e] -&gt; bindType ‘class net.hasor.dataway.web.ApiDetailController’ mappingTo: ‘[/interface-ui/api/api-detail]’.2023-05-18 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[c6eb9f3b3d4c4c8d8a4f807435538172] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryListController’ mappingTo: ‘[/interface-ui/api/api-history]’.2023-05-18 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[eb841dc72ad54023957233ef602c4327] -&gt; bindType ‘class net.hasor.dataway.web.ApiInfoController’ mappingTo: ‘[/interface-ui/api/api-info]’.2023-05-18 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[96aebb46265245459ae21d558e530921] -&gt; bindType ‘class net.hasor.dataway.web.ApiListController’ mappingTo: ‘[/interface-ui/api/api-list]’.2023-05-18 13:52:59.718 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7467c07f160244df8f228321f6262d3d] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryGetController’ mappingTo: ‘[/interface-ui/api/get-history]’.2023-05-18 13:52:59.719 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[97d8da5363c741ba99d87c073a344412] -&gt; bindType ‘class net.hasor.dataway.web.DisableController’ mappingTo: ‘[/interface-ui/api/disable]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[8ddc3316ef2642dfa4395ca8ac0fff04] -&gt; bindType ‘class net.hasor.dataway.web.SmokeController’ mappingTo: ‘[/interface-ui/api/smoke]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[cc06c5fb343b471aacedc58fb2fe7bf8] -&gt; bindType ‘class net.hasor.dataway.web.SaveApiController’ mappingTo: ‘[/interface-ui/api/save-api]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7915b2b1f89a4e73891edab0264c9bd4] -&gt; bindType ‘class net.hasor.dataway.web.PublishController’ mappingTo: ‘[/interface-ui/api/publish]’.2023-05-18 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[0cfa34586455414591bdc389bff23ccb] -&gt; bindType ‘class net.hasor.dataway.web.PerformController’ mappingTo: ‘[/interface-ui/api/perform]’.2023-05-18 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[37fe4af3e2994acb8deb72d21f02217c] -&gt; bindType ‘class net.hasor.dataway.web.DeleteController’ mappingTo: ‘[/interface-ui/api/delete]’.</code></pre><p>当看到 “dataway api workAt &#x2F;api&#x2F;” 、 dataway admin workAt &#x2F;interface-ui&#x2F; 信息时，就可以确定 Dataway 的配置已经生效了。</p><h4 id="第七步：访问接口管理页面进行接口配置"><a href="#第七步：访问接口管理页面进行接口配置" class="headerlink" title="第七步：访问接口管理页面进行接口配置"></a>第七步：访问接口管理页面进行接口配置</h4><p>在浏览器中输入 “<a href="http://127.0.0.1:8080/interface-ui/%E2%80%9D">http://127.0.0.1:8080/interface-ui/”</a> 就可以看到期待已久的界面了。</p><p>​<img src="/images/dataway_01-20230725172609-ps05uve.png" alt="dataway_01">​</p><h4 id="第八步：-新建一个接口"><a href="#第八步：-新建一个接口" class="headerlink" title="第八步： 新建一个接口"></a>第八步： 新建一个接口</h4><p>Dataway 提供了2中语言模式，我们可以使用强大的 DataQL 查询语言，也可以直接使用 SQL 语言（在 Dataway 内部 SQL 语言也会被转换为 DataQL 的形式执行。）</p><p>​<img src="/images/dataway_02-20230725172622-doddtt6.png" alt="dataway_02">​</p><p>首先我们在 SQL 模式下尝试执行一条 select 查询，立刻就可以看到这条 SQL 的查询结果。</p><p>​<img src="/images/dataway_03-20230725172638-uv4y73g.png" alt="dataway_03">​</p><p>同样的方式我们使用 DataQL 的方式需要这样写：</p><pre><code class="java">var query = @@sql()&lt;%    select * from interface_info%&gt;return query()</code></pre><p>其中 var query &#x3D; @@sql()&lt;% … %&gt; 是用来定义SQL外部代码块，并将这个定义存入 query 变量名中。&lt;% %&gt; 中间的就是 SQL 语句。</p><p>最后在 DataQL 中调用这个代码块，并返回查询结果。</p><p>当接口写好之后就可以保存发布了，为了测试方便，我选用 GET 方式。</p><p>​<img src="/images/dataway_04-20230725172731-a2q09dl.png" alt="dataway_04">​</p><p>接口发布之后我们直接请求：<a href="http://127.0.0.1:8080/api/demos%EF%BC%8C%E5%B0%B1%E7%9C%8B%E5%88%B0%E6%9C%9F%E5%BE%85%E5%B7%B2%E4%B9%85%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BA%86%E3%80%82">http://127.0.0.1:8080/api/demos，就看到期待已久的接口返回值了。</a></p><p>​<img src="/images/dataway_05-20230725172743-p1b6cbj.png" alt="dataway_05">​</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>经过上面的几个步骤我们介绍了如何基于 Spring Boot 项目使用 Dataway 来简单的配置接口。Dataway 的方式确实给人耳目一新，一个接口竟然可以如此简单的配置出来无需开发任何一行代码，也不需要做任何 Mapping 实体映射绑定。</p><p>‍</p><h4 id="最后放几个有用的链接："><a href="#最后放几个有用的链接：" class="headerlink" title="最后放几个有用的链接："></a>最后放几个有用的链接：</h4><ul><li><p>Dataway官方手册：</p><p>​<code>https://www.hasor.net/web/dataway/about.html</code>​​</p></li><li><p>Dataway 在 OSC 上的项目地址，欢迎收藏：</p><p><a href="https://www.oschina.net/p/dataway">https://www.oschina.net/p/dataway</a></p></li><li><p>DataQL 手册地址：</p><p><a href="https://www.hasor.net/web/dataql/what_is_dataql.html">https://www.hasor.net/web/dataql/what_is_dataql.html</a></p></li><li><p>Hasor 项目的首页：</p><p><a href="https://www.hasor.net/web/index.html">https://www.hasor.net/web/index.html</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
