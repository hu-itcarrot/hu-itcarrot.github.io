<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dataway</title>
      <link href="/2023/07/28/Dataway/"/>
      <url>/2023/07/28/Dataway/</url>
      
        <content type="html"><![CDATA[<h1 id="Dataway"><a href="#Dataway" class="headerlink" title="Dataway"></a>Dataway</h1><pre><code>Dataway 是基于 DataQL 服务聚合能力，为应用提供的一个接口配置工具，使得使用者无需开发任何代码就配置一个满足需求的接口。整个接口配置、测试、冒烟、发布，一站式都通过 Dataway 提供的 UI 界面完成。UI 会以 Jar 包方式提供并集成到应用中并和应用共享同一个 http 端口，应用无需单独为 Dataway 开辟新的管理端口。这种内嵌集成方式模式的优点是，可以使得大部分老项目都可以在无侵入的情况下直接应用 Dataway。进而改进老项目的迭代效率，大大减少企业项目研发成本。Dataway 工具化的提供 DataQL 配置能力。这种研发模式的变革使得，相当多的需求开发场景只需要配置即可完成交付。从而避免了从数据存取到前端接口之间的一系列开发任务，例如：Mapper、BO、VO、DO、DAO、Service、Controller 统统不在需要。Dataway 是 Hasor 生态中的一员，因此在 Spring 中使用 Dataway 首先要做的就是打通两个生态。根据官方文档中推荐的方式我们将 Hasor 和 Spring Boot 整合起来。</code></pre><h4 id="第一步：-引入相关依赖"><a href="#第一步：-引入相关依赖" class="headerlink" title="第一步： 引入相关依赖"></a>第一步： 引入相关依赖</h4><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;    &lt;version&gt;4.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;    &lt;version&gt;4.1.3-fix20200414&lt;/version&gt;&lt;!-- 4.1.3 包存在UI资源缺失问题 --&gt;&lt;/dependency&gt;</code></pre><p>hasor-spring 负责 Spring 和 Hasor 框架之间的整合。hasor-dataway 是工作在 Hasor 之上，利用 hasor-spring 我们就可以使用 dataway了。</p><h4 id="第二步：配置Dataway-并初始化数据表"><a href="#第二步：配置Dataway-并初始化数据表" class="headerlink" title="第二步：配置Dataway,并初始化数据表"></a>第二步：配置Dataway,并初始化数据表</h4><p>dataway 会提供一个界面让我们配置接口，这一点类似 Swagger 只要jar包集成就可以实现接口配置。找到我们 springboot 项目的配置文件 application.properties</p><pre><code class="java"># 是否启用 Dataway 功能（必选：默认false）HASOR_DATAQL_DATAWAY=true# 是否开启 Dataway 后台管理界面（必选：默认false）HASOR_DATAQL_DATAWAY_ADMIN=true# dataway  API工作路径（可选，默认：/api/）HASOR_DATAQL_DATAWAY_API_URL=/api/# dataway-ui 的工作路径（可选，默认：/interface-ui/）HASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/# SQL执行器方言设置（可选，建议设置）HASOR_DATAQL_FX_PAGE_DIALECT=mysql</code></pre><p>Dataway 一共涉及到 5个可以配置的配置项，但不是所有配置都是必须的。</p><p>其中 HASOR_DATAQL_DATAWAY、HASOR_DATAQL_DATAWAY_ADMIN 两个配置是必须要打开的，默认情况下 Datawaty 是不启用的。</p><p>Dataway 需要两个数据表才能工作，下面是这两个数据表的简表语句。下面这个 SQL 可以在 dataway的依赖 jar 包中 “META-INF&#x2F;hasor-framework&#x2F;mysql” 目录下面找到，建表语句是用 mysql 语法写的。</p><pre><code class="sql">CREATE TABLE `interface_info` (    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;ID&#39;,    `api_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `api_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `api_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0草稿，1发布，2有变更，3禁用&#39;,    `api_comment`     varchar(255)     NULL                  COMMENT &#39;注释&#39;,    `api_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `api_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `api_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `api_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,    PRIMARY KEY (`api_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway 中的API&#39;;CREATE TABLE `interface_release` (    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT &#39;Publish ID&#39;,    `pub_api_id`      int(11)      NOT NULL                  COMMENT &#39;所属API ID&#39;,    `pub_method`      varchar(12)  NOT NULL                  COMMENT &#39;HttpMethod：GET、PUT、POST&#39;,    `pub_path`        varchar(512) NOT NULL                  COMMENT &#39;拦截路径&#39;,    `pub_status`      int(2)       NOT NULL                  COMMENT &#39;状态：0有效，1无效（可能被下线）&#39;,    `pub_type`        varchar(24)  NOT NULL                  COMMENT &#39;脚本类型：SQL、DataQL&#39;,    `pub_script`      mediumtext   NOT NULL                  COMMENT &#39;查询脚本：xxxxxxx&#39;,    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT &#39;原始查询脚本，仅当类型为SQL时不同&#39;,    `pub_schema`      mediumtext       NULL                  COMMENT &#39;接口的请求/响应数据结构&#39;,    `pub_sample`      mediumtext       NULL                  COMMENT &#39;请求/响应/请求头样本数据&#39;,    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT &#39;发布时间（下线不更新）&#39;,    PRIMARY KEY (`pub_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;Dataway API 发布历史。&#39;;create index idx_interface_release on interface_release (pub_api_id);</code></pre><h4 id="第三步：-配置数据源"><a href="#第三步：-配置数据源" class="headerlink" title="第三步： 配置数据源"></a>第三步： 配置数据源</h4><p>作为 Spring Boot 项目有着自己完善的数据库方面工具支持。我们这次采用 druid + mysql + spring-boot-starter-jdbc 的方式。</p><p>首先引入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后添加数据源的配置</p><pre><code class="java"># dbspring.datasource.url=jdbc:mysql://xxxxxxx:3306/examplespring.datasource.username=xxxxxspring.datasource.password=xxxxxspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type:com.alibaba.druid.pool.DruidDataSource# druidspring.datasource.druid.initial-size=3spring.datasource.druid.min-idle=3spring.datasource.druid.max-active=10spring.datasource.druid.max-wait=60000spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=adminspring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=1</code></pre><p>如果项目已经集成了自己的数据源，那么可以忽略第三步。</p><h4 id="第四步：把数据源设置到Hasor容器中"><a href="#第四步：把数据源设置到Hasor容器中" class="headerlink" title="第四步：把数据源设置到Hasor容器中"></a>第四步：把数据源设置到Hasor容器中</h4><p>Spring Boot 和 Hasor 本是两个独立的容器框架，我们做整合之后为了使用 Dataway 的能力需要把 Spring 中的数据源设置到 Hasor 中。</p><p>首先新建一个 Hasor 的 模块，并且将其交给 Spring 管理。然后把数据源通过 Spring 注入进来。</p><pre><code class="java">@DimModule@Componentpublic class ExampleModule implements SpringModule &#123;    @Autowired    private DataSource dataSource = null;    @Override    public void loadModule(ApiBinder apiBinder) throws Throwable &#123;        // .DataSource form Spring boot into Hasor        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));    &#125;&#125;</code></pre><p>Hasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。</p><h4 id="第五步：-在springboot中启用Hasor"><a href="#第五步：-在springboot中启用Hasor" class="headerlink" title="第五步： 在springboot中启用Hasor"></a>第五步： 在springboot中启用Hasor</h4><pre><code class="java">@EnableHasor()@EnableHasorWeb()@SpringBootApplication(scanBasePackages = &#123; &quot;net.example.hasor&quot; &#125;)public class ExampleApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ExampleApplication.class, args);    &#125;&#125;</code></pre><p>这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。</p><h4 id="第六步：启动应用"><a href="#第六步：启动应用" class="headerlink" title="第六步：启动应用"></a>第六步：启动应用</h4><p>应用在启动过程中会看到 Hasor Boot 的欢迎信息</p><pre><code class="java"> _    _                        ____              _| |  | |                      |  _ \            | || |__| | __ _ ___  ___  _ __  | |_) | ___   ___ | |_|  __  |/ _` / __|/ _ \| &#39;__| |  _ &lt; / _ \ / _ \| __|| |  | | (_| \__ \ (_) | |    | |_) | (_) | (_) | |_|_|  |_|\__,_|___/\___/|_|    |____/ \___/ \___/ \__|</code></pre><p>在后面的日志中还可以看到类似下面这些日志。</p><pre><code class="java">2023-05-18 13:52:59.696 [main] INFO  n.h.core.context.TemplateAppContext - loadModule class net.hasor.dataway.config.DatawayModule2023-05-18 13:52:59.697 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway api workAt /api/2023-05-18 13:52:59.697 [main] INFO  n.h.c.e.AbstractEnvironment - var -&gt; HASOR_DATAQL_DATAWAY_API_URL = /api/.2023-05-18 13:52:59.704 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway admin workAt /interface-ui/2023-05-18 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[901d38f22faa419a8593bb349905ed0e] -&gt; bindType ‘class net.hasor.dataway.web.ApiDetailController’ mappingTo: ‘[/interface-ui/api/api-detail]’.2023-05-18 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[c6eb9f3b3d4c4c8d8a4f807435538172] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryListController’ mappingTo: ‘[/interface-ui/api/api-history]’.2023-05-18 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[eb841dc72ad54023957233ef602c4327] -&gt; bindType ‘class net.hasor.dataway.web.ApiInfoController’ mappingTo: ‘[/interface-ui/api/api-info]’.2023-05-18 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[96aebb46265245459ae21d558e530921] -&gt; bindType ‘class net.hasor.dataway.web.ApiListController’ mappingTo: ‘[/interface-ui/api/api-list]’.2023-05-18 13:52:59.718 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7467c07f160244df8f228321f6262d3d] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryGetController’ mappingTo: ‘[/interface-ui/api/get-history]’.2023-05-18 13:52:59.719 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[97d8da5363c741ba99d87c073a344412] -&gt; bindType ‘class net.hasor.dataway.web.DisableController’ mappingTo: ‘[/interface-ui/api/disable]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[8ddc3316ef2642dfa4395ca8ac0fff04] -&gt; bindType ‘class net.hasor.dataway.web.SmokeController’ mappingTo: ‘[/interface-ui/api/smoke]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[cc06c5fb343b471aacedc58fb2fe7bf8] -&gt; bindType ‘class net.hasor.dataway.web.SaveApiController’ mappingTo: ‘[/interface-ui/api/save-api]’.2023-05-18 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7915b2b1f89a4e73891edab0264c9bd4] -&gt; bindType ‘class net.hasor.dataway.web.PublishController’ mappingTo: ‘[/interface-ui/api/publish]’.2023-05-18 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[0cfa34586455414591bdc389bff23ccb] -&gt; bindType ‘class net.hasor.dataway.web.PerformController’ mappingTo: ‘[/interface-ui/api/perform]’.2023-05-18 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[37fe4af3e2994acb8deb72d21f02217c] -&gt; bindType ‘class net.hasor.dataway.web.DeleteController’ mappingTo: ‘[/interface-ui/api/delete]’.</code></pre><p>当看到 “dataway api workAt &#x2F;api&#x2F;” 、 dataway admin workAt &#x2F;interface-ui&#x2F; 信息时，就可以确定 Dataway 的配置已经生效了。</p><h4 id="第七步：访问接口管理页面进行接口配置"><a href="#第七步：访问接口管理页面进行接口配置" class="headerlink" title="第七步：访问接口管理页面进行接口配置"></a>第七步：访问接口管理页面进行接口配置</h4><p>在浏览器中输入 “<a href="http://127.0.0.1:8080/interface-ui/%E2%80%9D">http://127.0.0.1:8080/interface-ui/”</a> 就可以看到期待已久的界面了。</p><p>​<img src="/images/dataway_01-20230725172609-ps05uve.png" alt="dataway_01">​</p><h4 id="第八步：-新建一个接口"><a href="#第八步：-新建一个接口" class="headerlink" title="第八步： 新建一个接口"></a>第八步： 新建一个接口</h4><p>Dataway 提供了2中语言模式，我们可以使用强大的 DataQL 查询语言，也可以直接使用 SQL 语言（在 Dataway 内部 SQL 语言也会被转换为 DataQL 的形式执行。）</p><p>​<img src="/images/dataway_02-20230725172622-doddtt6.png" alt="dataway_02">​</p><p>首先我们在 SQL 模式下尝试执行一条 select 查询，立刻就可以看到这条 SQL 的查询结果。</p><p>​<img src="/images/dataway_03-20230725172638-uv4y73g.png" alt="dataway_03">​</p><p>同样的方式我们使用 DataQL 的方式需要这样写：</p><pre><code class="java">var query = @@sql()&lt;%    select * from interface_info%&gt;return query()</code></pre><p>其中 var query &#x3D; @@sql()&lt;% … %&gt; 是用来定义SQL外部代码块，并将这个定义存入 query 变量名中。&lt;% %&gt; 中间的就是 SQL 语句。</p><p>最后在 DataQL 中调用这个代码块，并返回查询结果。</p><p>当接口写好之后就可以保存发布了，为了测试方便，我选用 GET 方式。</p><p>​<img src="/images/dataway_04-20230725172731-a2q09dl.png" alt="dataway_04">​</p><p>接口发布之后我们直接请求：<a href="http://127.0.0.1:8080/api/demos%EF%BC%8C%E5%B0%B1%E7%9C%8B%E5%88%B0%E6%9C%9F%E5%BE%85%E5%B7%B2%E4%B9%85%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BA%86%E3%80%82">http://127.0.0.1:8080/api/demos，就看到期待已久的接口返回值了。</a></p><p>​<img src="/images/dataway_05-20230725172743-p1b6cbj.png" alt="dataway_05">​</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>经过上面的几个步骤我们介绍了如何基于 Spring Boot 项目使用 Dataway 来简单的配置接口。Dataway 的方式确实给人耳目一新，一个接口竟然可以如此简单的配置出来无需开发任何一行代码，也不需要做任何 Mapping 实体映射绑定。</p><p>‍</p><h4 id="最后放几个有用的链接："><a href="#最后放几个有用的链接：" class="headerlink" title="最后放几个有用的链接："></a>最后放几个有用的链接：</h4><ul><li><p>Dataway官方手册：</p><p>​<code>https://www.hasor.net/web/dataway/about.html</code>​​</p></li><li><p>Dataway 在 OSC 上的项目地址，欢迎收藏：</p><p><a href="https://www.oschina.net/p/dataway">https://www.oschina.net/p/dataway</a></p></li><li><p>DataQL 手册地址：</p><p><a href="https://www.hasor.net/web/dataql/what_is_dataql.html">https://www.hasor.net/web/dataql/what_is_dataql.html</a></p></li><li><p>Hasor 项目的首页：</p><p><a href="https://www.hasor.net/web/index.html">https://www.hasor.net/web/index.html</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2023/07/04/docker/"/>
      <url>/2023/07/04/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h2><h3 id="1、查看镜像——docker-images"><a href="#1、查看镜像——docker-images" class="headerlink" title="1、查看镜像——docker images"></a>1、查看镜像——docker images</h3><pre><code># 查看下载到本地的所有镜像docker imagesREPOSITORY   TAG       IMAGE ID       CREATED      SIZEnginx        latest    ae2feff98a0c   9 days ago   133MB--------------------------------------------------------------------------------REPOSITORY：镜像属于的仓库；TAG：镜像的标签信息，标记同一个仓库中的不同镜像；IMAGE ID：镜像的唯一ID 号，唯一标识一个镜像，经过md5方式加密过；CREATED：镜像创建时间；VIRTUAL SIZE：镜像大小；</code></pre><p><img src="/images/docker_images.png" alt="图片"></p><h3 id="2、查看所有状态容器——docker-ps-a"><a href="#2、查看所有状态容器——docker-ps-a" class="headerlink" title="2、查看所有状态容器——docker ps -a"></a>2、查看所有状态容器——docker ps -a</h3><pre><code>docker ps -a    #-a 选项可以显示所有的容器 CONTAINER ID   IMAGE         COMMAND                  CREATED        STATUS                      PORTS     NAMES58a0aad139d3   nginx         &quot;/docker-entrypoint.…&quot;   2 hours ago    Exited (0) 21 minutes ago             dazzling_wescoff ##字段说明CONTAINER ID：容器的ID号IMAGE：加载的镜像COMMAND ：运行的程序CREATED ：创建时间STATUS：当前的状态PORTS：端口映射NAMES：名称</code></pre><h3 id="3、docker——run-命令"><a href="#3、docker——run-命令" class="headerlink" title="3、docker——run 命令"></a>3、docker——run 命令</h3><pre><code>docker run hello-world</code></pre><h3 id="4、查看docker版本信息——docker-v"><a href="#4、查看docker版本信息——docker-v" class="headerlink" title="4、查看docker版本信息——docker -v"></a>4、查看docker版本信息——docker -v</h3><pre><code>docker versiondocker -v</code></pre><h3 id="5、查看docker信息——docker-info"><a href="#5、查看docker信息——docker-info" class="headerlink" title="5、查看docker信息——docker info"></a>5、查看docker信息——docker info</h3><pre><code>docker info#可以用该命令统计每一个状态的容器有多少个 Client: Context:    default  Debug Mode: false Plugins:  app: Docker App (Docker Inc., v0.9.1-beta3)  buildx: Docker Buildx (Docker Inc., v0.7.1-docker)  scan: Docker Scan (Docker Inc., v0.12.0) Server: Containers: 1  #容器连接数量  Running: 0   #正在运行的容器数量  Paused: 0   #暂停的容器数量  Stopped: 1  #停止的容器数量 Images: 2    #统计的镜像数量 Server Version: 20.10.12   #docker版本 Storage Driver: overlay2   #存储引擎，早期有一段用的是aufa存储引擎，可以把多个目录叠在在一起后挂载到同一个目录一下  Backing Filesystem: xfs    #后端的文件系统  Supports d_type: true           Native Overlay Diff: true  userxattr: false Logging Driver: json-file Cgroup Driver: cgroupfs   #linux中资源控制，资源管理的驱动：cgroupfs  Cgroup Version: 1     Plugins:  #插件  Volume: local  #镜像默认保存位置。可以不保存在本地，docker是以引擎的方式架设在linux之上的。  Network: bridge host ipvlan macvlan null overlay  #所支持的默认的网络类型。bridge（桥接）、host（主机）、ipvlan（三层模式划分vlan）、macvlan（二层模式划分vlan）、null（躺平：不与别人交互）、overlay（叠加网络）  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive   Runtimes: io.containerd.runc.v2   io.containerd.runtime.v1.linux runc  #运行时 Default Runtime: runc  #默认运行时的版本 Init Binary: docker-init containerd version: 7b11cfaabd73bb80907dd23182b9347b4245eb5d runc version: v1.0.2-0-g52b36a2 init version: de40ad0 Security Options:  seccomp   Profile: default Kernel Version: 3.10.0-693.el7.x86_64 Operating System: CentOS Linux 7 (Core) OSType: linux Architecture: x86_64 CPUs: 4   #总计cpu Total Memory: 1.718GiB #总计内存 Name: docker ID: DT7Y:MDZR:NVOS:NQBJ:C2RV:L5IS:OSLD:E3DG:3PSN:EJDH:ZYMU:42HS Docker Root Dir: /var/lib/docker  #docker家目录 Debug Mode: false Registry: https://index.docker.io/v1/  #默认仓库 Labels: Experimental: false Insecure Registries:  127.0.0.0/8 Registry Mirrors:    https://4abdkxlk.mirror.aliyuncs.com/ Live Restore Enabled: false</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基本操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/03/hello-world/"/>
      <url>/2023/07/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
